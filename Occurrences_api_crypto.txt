crypto/acompress.c:110:struct crypto_acomp *crypto_alloc_acomp(const char *alg_name, u32 type,
crypto/acompress.c:113:	return crypto_alloc_tfm(alg_name, &crypto_acomp_type, type, mask);
crypto/acompress.c:115:EXPORT_SYMBOL_GPL(crypto_alloc_acomp);
crypto/aead.c:347:struct crypto_aead *crypto_alloc_aead(const char *alg_name, u32 type, u32 mask)
crypto/aead.c:349:	return crypto_alloc_tfm(alg_name, &crypto_aead_type, type, mask);
crypto/aead.c:351:EXPORT_SYMBOL_GPL(crypto_alloc_aead);
crypto/ahash.c:564:struct crypto_ahash *crypto_alloc_ahash(const char *alg_name, u32 type,
crypto/ahash.c:567:	return crypto_alloc_tfm(alg_name, &crypto_ahash_type, type, mask);
crypto/ahash.c:569:EXPORT_SYMBOL_GPL(crypto_alloc_ahash);
crypto/akcipher.c:106:struct crypto_akcipher *crypto_alloc_akcipher(const char *alg_name, u32 type,
crypto/akcipher.c:109:	return crypto_alloc_tfm(alg_name, &crypto_akcipher_type, type, mask);
crypto/akcipher.c:111:EXPORT_SYMBOL_GPL(crypto_alloc_akcipher);
crypto/algapi.c:735:	tfm = __crypto_alloc_tfm(alg, type, mask);
crypto/algapi.c:878:void *crypto_alloc_instance(const char *name, struct crypto_alg *alg,
crypto/algapi.c:902:EXPORT_SYMBOL_GPL(crypto_alloc_instance);
crypto/algif_aead.c:487:	aead = crypto_alloc_aead(name, type, mask);
Binary file crypto/algif_aead.ko matches
Binary file crypto/algif_aead.o matches
crypto/algif_hash.c:408:	return crypto_alloc_ahash(name, type, mask);
Binary file crypto/algif_hash.ko matches
Binary file crypto/algif_hash.o matches
crypto/algif_rng.c:118:	return crypto_alloc_rng(name, type, mask);
Binary file crypto/algif_rng.ko matches
Binary file crypto/algif_rng.o matches
crypto/algif_skcipher.c:310:	return crypto_alloc_skcipher(name, type, mask);
Binary file crypto/algif_skcipher.ko matches
Binary file crypto/algif_skcipher.o matches
crypto/ansi_cprng.c:330:	ctx->tfm = crypto_alloc_cipher("aes", 0, 0);
Binary file crypto/ansi_cprng.ko matches
Binary file crypto/ansi_cprng.o matches
crypto/api.c:360:struct crypto_tfm *__crypto_alloc_tfm(struct crypto_alg *alg, u32 type,
crypto/api.c:394:EXPORT_SYMBOL_GPL(__crypto_alloc_tfm);
crypto/api.c:397: *	crypto_alloc_base - Locate algorithm and allocate transform
crypto/api.c:403: *	Please use crypto_alloc_tfm instead.
crypto/api.c:405: *	crypto_alloc_base() will first attempt to locate an already loaded
crypto/api.c:414: *	crypto_alloc_blkcipher.
crypto/api.c:418:struct crypto_tfm *crypto_alloc_base(const char *alg_name, u32 type, u32 mask)
crypto/api.c:432:		tfm = __crypto_alloc_tfm(alg, type, mask);
crypto/api.c:450:EXPORT_SYMBOL_GPL(crypto_alloc_base);
crypto/api.c:509: *	crypto_alloc_tfm - Locate algorithm and allocate transform
crypto/api.c:515: *	crypto_alloc_tfm() will first attempt to locate an already loaded
crypto/api.c:524: *	crypto_alloc_blkcipher.
crypto/api.c:528:void *crypto_alloc_tfm(const char *alg_name,
crypto/api.c:561:EXPORT_SYMBOL_GPL(crypto_alloc_tfm);
Binary file crypto/api.o matches




crypto/adiantum.c:65:	struct crypto_skcipher_spawn streamcipher_spawn;
crypto/adiantum.c:71:	struct crypto_skcipher *streamcipher;
crypto/adiantum.c:117:static int adiantum_setkey(struct crypto_skcipher *tfm, const u8 *key,
crypto/adiantum.c:120:	struct adiantum_tfm_ctx *tctx = crypto_skcipher_ctx(tfm);
crypto/adiantum.c:132:	crypto_skcipher_clear_flags(tctx->streamcipher, CRYPTO_TFM_REQ_MASK);
crypto/adiantum.c:133:	crypto_skcipher_set_flags(tctx->streamcipher,
crypto/adiantum.c:134:				  crypto_skcipher_get_flags(tfm) &
crypto/adiantum.c:136:	err = crypto_skcipher_setkey(tctx->streamcipher, key, keylen);
crypto/adiantum.c:137:	crypto_skcipher_set_flags(tfm,
crypto/adiantum.c:138:				crypto_skcipher_get_flags(tctx->streamcipher) &
crypto/adiantum.c:145:		       crypto_skcipher_reqsize(tctx->streamcipher), GFP_KERNEL);
crypto/adiantum.c:157:	err = crypto_wait_req(crypto_skcipher_encrypt(&data->req), &data->wait);
crypto/adiantum.c:165:				crypto_skcipher_get_flags(tfm) &
crypto/adiantum.c:169:	crypto_skcipher_set_flags(tfm,
crypto/adiantum.c:181:	crypto_shash_set_flags(tctx->hash, crypto_skcipher_get_flags(tfm) &
crypto/adiantum.c:184:	crypto_skcipher_set_flags(tfm, crypto_shash_get_flags(tctx->hash) &
crypto/adiantum.c:229:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
crypto/adiantum.c:230:	const struct adiantum_tfm_ctx *tctx = crypto_skcipher_ctx(tfm);
crypto/adiantum.c:258:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
crypto/adiantum.c:259:	const struct adiantum_tfm_ctx *tctx = crypto_skcipher_ctx(tfm);
crypto/adiantum.c:292:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
crypto/adiantum.c:293:	const struct adiantum_tfm_ctx *tctx = crypto_skcipher_ctx(tfm);
crypto/adiantum.c:332:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
crypto/adiantum.c:333:	const struct adiantum_tfm_ctx *tctx = crypto_skcipher_ctx(tfm);
crypto/adiantum.c:391:	return crypto_skcipher_encrypt(&rctx->u.streamcipher_req) ?:
crypto/adiantum.c:405:static int adiantum_init_tfm(struct crypto_skcipher *tfm)
crypto/adiantum.c:409:	struct adiantum_tfm_ctx *tctx = crypto_skcipher_ctx(tfm);
crypto/adiantum.c:410:	struct crypto_skcipher *streamcipher;
crypto/adiantum.c:443:			  crypto_skcipher_reqsize(streamcipher));
crypto/adiantum.c:445:	crypto_skcipher_set_reqsize(tfm,
crypto/adiantum.c:457:static void adiantum_exit_tfm(struct crypto_skcipher *tfm)
crypto/adiantum.c:459:	struct adiantum_tfm_ctx *tctx = crypto_skcipher_ctx(tfm);
crypto/adiantum.c:618:	inst->alg.min_keysize = crypto_skcipher_alg_min_keysize(streamcipher_alg);
crypto/adiantum.c:619:	inst->alg.max_keysize = crypto_skcipher_alg_max_keysize(streamcipher_alg);
crypto/algif_aead.c:89:	return crypto_skcipher_encrypt(skreq);
Binary file crypto/algif_aead.ko matches
Binary file crypto/algif_aead.o matches
crypto/algif_skcipher.c:48:	struct crypto_skcipher *tfm = pask->private;
crypto/algif_skcipher.c:49:	unsigned ivsize = crypto_skcipher_ivsize(tfm);
crypto/algif_skcipher.c:62:	struct crypto_skcipher *tfm = pask->private;
crypto/algif_skcipher.c:63:	unsigned int bs = crypto_skcipher_blocksize(tfm);
crypto/algif_skcipher.c:76:				     crypto_skcipher_reqsize(tfm));
crypto/algif_skcipher.c:130:			crypto_skcipher_encrypt(&areq->cra_u.skcipher_req) :
crypto/algif_skcipher.c:131:			crypto_skcipher_decrypt(&areq->cra_u.skcipher_req);
crypto/algif_skcipher.c:145:			crypto_skcipher_encrypt(&areq->cra_u.skcipher_req) :
crypto/algif_skcipher.c:146:			crypto_skcipher_decrypt(&areq->cra_u.skcipher_req),
crypto/algif_skcipher.c:217:	struct crypto_skcipher *tfm;
crypto/algif_skcipher.c:231:	if (crypto_skcipher_get_flags(tfm) & CRYPTO_TFM_NEED_KEY)
crypto/algif_skcipher.c:320:	return crypto_skcipher_setkey(private, key, keylen);
crypto/algif_skcipher.c:329:	struct crypto_skcipher *tfm = pask->private;
crypto/algif_skcipher.c:332:	sock_kzfree_s(sk, ctx->iv, crypto_skcipher_ivsize(tfm));
crypto/algif_skcipher.c:341:	struct crypto_skcipher *tfm = private;
crypto/algif_skcipher.c:348:	ctx->iv = sock_kmalloc(sk, crypto_skcipher_ivsize(tfm),
crypto/algif_skcipher.c:355:	memset(ctx->iv, 0, crypto_skcipher_ivsize(tfm));
crypto/algif_skcipher.c:375:	struct crypto_skcipher *tfm = private;
crypto/algif_skcipher.c:377:	if (crypto_skcipher_get_flags(tfm) & CRYPTO_TFM_NEED_KEY)
Binary file crypto/algif_skcipher.ko matches
Binary file crypto/algif_skcipher.o matches
crypto/arc4.c:50:static int arc4_set_key_skcipher(struct crypto_skcipher *tfm, const u8 *in_key,
crypto/arc4.c:100:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
crypto/arc4.c:101:	struct arc4_ctx *ctx = crypto_skcipher_ctx(tfm);
Binary file crypto/arc4.ko matches
Binary file crypto/arc4.o matches
grep: crypto/asymmetric_keys: Is a directory
grep: crypto/async_tx: Is a directory
crypto/authenc.c:29:	struct crypto_skcipher_spawn enc;
crypto/authenc.c:35:	struct crypto_skcipher *enc;
crypto/authenc.c:94:	struct crypto_skcipher *enc = ctx->enc;
crypto/authenc.c:111:	crypto_skcipher_clear_flags(enc, CRYPTO_TFM_REQ_MASK);
crypto/authenc.c:112:	crypto_skcipher_set_flags(enc, crypto_aead_get_flags(authenc) &
crypto/authenc.c:114:	err = crypto_skcipher_setkey(enc, keys.enckey, keys.enckeylen);
crypto/authenc.c:115:	crypto_aead_set_flags(authenc, crypto_skcipher_get_flags(enc) &
crypto/authenc.c:204:	return crypto_skcipher_encrypt(skreq);
crypto/authenc.c:214:	struct crypto_skcipher *enc = ctx->enc;
crypto/authenc.c:237:	err = crypto_skcipher_encrypt(skreq);
crypto/authenc.c:276:	return crypto_skcipher_decrypt(skreq);
crypto/authenc.c:328:	struct crypto_skcipher *enc;
crypto/authenc.c:358:		      crypto_skcipher_reqsize(enc)));
crypto/authenc.c:464:	inst->alg.ivsize = crypto_skcipher_alg_ivsize(enc);
crypto/authenc.c:465:	inst->alg.chunksize = crypto_skcipher_alg_chunksize(enc);
crypto/authencesn.c:32:	struct crypto_skcipher_spawn enc;
crypto/authencesn.c:38:	struct crypto_skcipher *enc;
crypto/authencesn.c:68:	struct crypto_skcipher *enc = ctx->enc;
crypto/authencesn.c:85:	crypto_skcipher_clear_flags(enc, CRYPTO_TFM_REQ_MASK);
crypto/authencesn.c:86:	crypto_skcipher_set_flags(enc, crypto_aead_get_flags(authenc_esn) &
crypto/authencesn.c:88:	err = crypto_skcipher_setkey(enc, keys.enckey, keys.enckeylen);
crypto/authencesn.c:89:	crypto_aead_set_flags(authenc_esn, crypto_skcipher_get_flags(enc) &
crypto/authencesn.c:193:	return crypto_skcipher_encrypt(skreq);
crypto/authencesn.c:203:	struct crypto_skcipher *enc = ctx->enc;
crypto/authencesn.c:227:	err = crypto_skcipher_encrypt(skreq);
crypto/authencesn.c:273:	return crypto_skcipher_decrypt(skreq);
crypto/authencesn.c:343:	struct crypto_skcipher *enc;
crypto/authencesn.c:376:		      crypto_skcipher_reqsize(enc)));
crypto/authencesn.c:478:	inst->alg.ivsize = crypto_skcipher_alg_ivsize(enc);
crypto/authencesn.c:479:	inst->alg.chunksize = crypto_skcipher_alg_chunksize(enc);
Binary file crypto/authencesn.ko matches
Binary file crypto/authencesn.o matches
Binary file crypto/authenc.ko matches
Binary file crypto/authenc.o matches
crypto/cbc.c:22:static inline void crypto_cbc_encrypt_one(struct crypto_skcipher *tfm,
crypto/cbc.c:33:static inline void crypto_cbc_decrypt_one(struct crypto_skcipher *tfm,
crypto/cbc.c:41:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
Binary file crypto/cbc.o matches
crypto/ccm.c:26:	struct crypto_skcipher_spawn ctr;
crypto/ccm.c:32:	struct crypto_skcipher *ctr;
crypto/ccm.c:97:	struct crypto_skcipher *ctr = ctx->ctr;
crypto/ccm.c:101:	crypto_skcipher_clear_flags(ctr, CRYPTO_TFM_REQ_MASK);
crypto/ccm.c:102:	crypto_skcipher_set_flags(ctr, crypto_aead_get_flags(aead) &
crypto/ccm.c:104:	err = crypto_skcipher_setkey(ctr, key, keylen);
crypto/ccm.c:105:	crypto_aead_set_flags(aead, crypto_skcipher_get_flags(ctr) &
crypto/ccm.c:326:	err = crypto_skcipher_encrypt(skreq);
crypto/ccm.c:391:	err = crypto_skcipher_decrypt(skreq);
crypto/ccm.c:412:	struct crypto_skcipher *ctr;
crypto/ccm.c:433:		max(crypto_ahash_reqsize(mac), crypto_skcipher_reqsize(ctr)));
crypto/ccm.c:515:	    crypto_skcipher_alg_ivsize(ctr) != 16 ||
crypto/ccm.c:540:	inst->alg.chunksize = crypto_skcipher_alg_chunksize(ctr);
Binary file crypto/ccm.ko matches
Binary file crypto/ccm.o matches
crypto/cfb.c:30:static unsigned int crypto_cfb_bsize(struct crypto_skcipher *tfm)
crypto/cfb.c:35:static void crypto_cfb_encrypt_one(struct crypto_skcipher *tfm,
crypto/cfb.c:43:			     struct crypto_skcipher *tfm)
crypto/cfb.c:45:	const unsigned long alignmask = crypto_skcipher_alignmask(tfm);
crypto/cfb.c:58:				      struct crypto_skcipher *tfm)
crypto/cfb.c:81:				      struct crypto_skcipher *tfm)
crypto/cfb.c:104:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
crypto/cfb.c:128:				      struct crypto_skcipher *tfm)
crypto/cfb.c:151:				      struct crypto_skcipher *tfm)
crypto/cfb.c:170:				     struct crypto_skcipher *tfm)
crypto/cfb.c:180:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
crypto/chacha20poly1305.c:26:	struct crypto_skcipher_spawn chacha;
crypto/chacha20poly1305.c:32:	struct crypto_skcipher *chacha;
crypto/chacha20poly1305.c:150:	err = crypto_skcipher_decrypt(&creq->req);
crypto/chacha20poly1305.c:400:	err = crypto_skcipher_decrypt(&creq->req);
crypto/chacha20poly1305.c:439:	err = crypto_skcipher_encrypt(&creq->req);
crypto/chacha20poly1305.c:501:	crypto_skcipher_clear_flags(ctx->chacha, CRYPTO_TFM_REQ_MASK);
crypto/chacha20poly1305.c:502:	crypto_skcipher_set_flags(ctx->chacha, crypto_aead_get_flags(aead) &
crypto/chacha20poly1305.c:505:	err = crypto_skcipher_setkey(ctx->chacha, key, keylen);
crypto/chacha20poly1305.c:506:	crypto_aead_set_flags(aead, crypto_skcipher_get_flags(ctx->chacha) &
crypto/chacha20poly1305.c:525:	struct crypto_skcipher *chacha;
crypto/chacha20poly1305.c:550:		    crypto_skcipher_reqsize(chacha),
crypto/chacha20poly1305.c:640:	if (crypto_skcipher_alg_ivsize(chacha) != CHACHA_IV_SIZE)
crypto/chacha20poly1305.c:666:	inst->alg.chunksize = crypto_skcipher_alg_chunksize(chacha);
Binary file crypto/chacha20poly1305.ko matches
Binary file crypto/chacha20poly1305.o matches
crypto/chacha_generic.c:84:static int chacha_setkey(struct crypto_skcipher *tfm, const u8 *key,
crypto/chacha_generic.c:87:	struct chacha_ctx *ctx = crypto_skcipher_ctx(tfm);
crypto/chacha_generic.c:100:int crypto_chacha20_setkey(struct crypto_skcipher *tfm, const u8 *key,
crypto/chacha_generic.c:107:int crypto_chacha12_setkey(struct crypto_skcipher *tfm, const u8 *key,
crypto/chacha_generic.c:116:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
crypto/chacha_generic.c:117:	struct chacha_ctx *ctx = crypto_skcipher_ctx(tfm);
crypto/chacha_generic.c:125:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
crypto/chacha_generic.c:126:	struct chacha_ctx *ctx = crypto_skcipher_ctx(tfm);
Binary file crypto/chacha_generic.ko matches
Binary file crypto/chacha_generic.o matches
crypto/cryptd.c:54:	struct crypto_skcipher_spawn spawn;
crypto/cryptd.c:253:static int cryptd_skcipher_setkey(struct crypto_skcipher *parent,
crypto/cryptd.c:256:	struct cryptd_skcipher_ctx *ctx = crypto_skcipher_ctx(parent);
crypto/cryptd.c:262:				       crypto_skcipher_get_flags(parent) &
crypto/cryptd.c:265:	crypto_skcipher_set_flags(parent,
crypto/cryptd.c:273:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
crypto/cryptd.c:274:	struct cryptd_skcipher_ctx *ctx = crypto_skcipher_ctx(tfm);
crypto/cryptd.c:291:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
crypto/cryptd.c:292:	struct cryptd_skcipher_ctx *ctx = crypto_skcipher_ctx(tfm);
crypto/cryptd.c:305:	err = crypto_skcipher_encrypt(subreq);
crypto/cryptd.c:319:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
crypto/cryptd.c:320:	struct cryptd_skcipher_ctx *ctx = crypto_skcipher_ctx(tfm);
crypto/cryptd.c:333:	err = crypto_skcipher_decrypt(subreq);
crypto/cryptd.c:346:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
crypto/cryptd.c:349:	queue = cryptd_get_queue(crypto_skcipher_tfm(tfm));
crypto/cryptd.c:366:static int cryptd_skcipher_init_tfm(struct crypto_skcipher *tfm)
crypto/cryptd.c:370:	struct crypto_skcipher_spawn *spawn = &ictx->spawn;
crypto/cryptd.c:371:	struct cryptd_skcipher_ctx *ctx = crypto_skcipher_ctx(tfm);
crypto/cryptd.c:372:	struct crypto_skcipher *cipher;
crypto/cryptd.c:379:	crypto_skcipher_set_reqsize(
crypto/cryptd.c:384:static void cryptd_skcipher_exit_tfm(struct crypto_skcipher *tfm)
crypto/cryptd.c:386:	struct cryptd_skcipher_ctx *ctx = crypto_skcipher_ctx(tfm);
crypto/cryptd.c:439:	inst->alg.ivsize = crypto_skcipher_alg_ivsize(alg);
crypto/cryptd.c:440:	inst->alg.chunksize = crypto_skcipher_alg_chunksize(alg);
crypto/cryptd.c:441:	inst->alg.min_keysize = crypto_skcipher_alg_min_keysize(alg);
crypto/cryptd.c:442:	inst->alg.max_keysize = crypto_skcipher_alg_max_keysize(alg);
crypto/cryptd.c:968:	struct crypto_skcipher *tfm;
crypto/cryptd.c:983:	ctx = crypto_skcipher_ctx(tfm);
crypto/cryptd.c:990:struct crypto_skcipher *cryptd_skcipher_child(struct cryptd_skcipher *tfm)
crypto/cryptd.c:992:	struct cryptd_skcipher_ctx *ctx = crypto_skcipher_ctx(&tfm->base);
crypto/cryptd.c:1000:	struct cryptd_skcipher_ctx *ctx = crypto_skcipher_ctx(&tfm->base);
crypto/cryptd.c:1008:	struct cryptd_skcipher_ctx *ctx = crypto_skcipher_ctx(&tfm->base);
Binary file crypto/cryptd.ko matches
Binary file crypto/cryptd.o matches
crypto/crypto_null.c:68:static int null_skcipher_setkey(struct crypto_skcipher *tfm, const u8 *key,
Binary file crypto/crypto_null.o matches
Binary file crypto/crypto_simd.ko matches
Binary file crypto/crypto_simd.o matches
crypto/ctr.c:23:	struct crypto_skcipher *child;
crypto/ctr.c:105:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
crypto/ctr.c:174:static int crypto_rfc3686_setkey(struct crypto_skcipher *parent,
crypto/ctr.c:177:	struct crypto_rfc3686_ctx *ctx = crypto_skcipher_ctx(parent);
crypto/ctr.c:178:	struct crypto_skcipher *child = ctx->child;
crypto/ctr.c:190:	crypto_skcipher_clear_flags(child, CRYPTO_TFM_REQ_MASK);
crypto/ctr.c:191:	crypto_skcipher_set_flags(child, crypto_skcipher_get_flags(parent) &
crypto/ctr.c:193:	err = crypto_skcipher_setkey(child, key, keylen);
crypto/ctr.c:194:	crypto_skcipher_set_flags(parent, crypto_skcipher_get_flags(child) &
crypto/ctr.c:202:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
crypto/ctr.c:203:	struct crypto_rfc3686_ctx *ctx = crypto_skcipher_ctx(tfm);
crypto/ctr.c:204:	struct crypto_skcipher *child = ctx->child;
crypto/ctr.c:205:	unsigned long align = crypto_skcipher_alignmask(tfm);
crypto/ctr.c:225:	return crypto_skcipher_encrypt(subreq);
crypto/ctr.c:228:static int crypto_rfc3686_init_tfm(struct crypto_skcipher *tfm)
crypto/ctr.c:231:	struct crypto_skcipher_spawn *spawn = skcipher_instance_ctx(inst);
crypto/ctr.c:232:	struct crypto_rfc3686_ctx *ctx = crypto_skcipher_ctx(tfm);
crypto/ctr.c:233:	struct crypto_skcipher *cipher;
crypto/ctr.c:243:	align = crypto_skcipher_alignmask(tfm);
crypto/ctr.c:246:		  crypto_skcipher_reqsize(cipher);
crypto/ctr.c:247:	crypto_skcipher_set_reqsize(tfm, reqsize);
crypto/ctr.c:252:static void crypto_rfc3686_exit_tfm(struct crypto_skcipher *tfm)
crypto/ctr.c:254:	struct crypto_rfc3686_ctx *ctx = crypto_skcipher_ctx(tfm);
crypto/ctr.c:261:	struct crypto_skcipher_spawn *spawn = skcipher_instance_ctx(inst);
crypto/ctr.c:273:	struct crypto_skcipher_spawn *spawn;
crypto/ctr.c:309:	if (crypto_skcipher_alg_ivsize(alg) != CTR_RFC3686_BLOCK_SIZE)
crypto/ctr.c:332:	inst->alg.chunksize = crypto_skcipher_alg_chunksize(alg);
crypto/ctr.c:333:	inst->alg.min_keysize = crypto_skcipher_alg_min_keysize(alg) +
crypto/ctr.c:335:	inst->alg.max_keysize = crypto_skcipher_alg_max_keysize(alg) +
Binary file crypto/ctr.o matches
crypto/cts.c:56:	struct crypto_skcipher *child;
crypto/cts.c:68:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
crypto/cts.c:69:	struct crypto_cts_ctx *ctx = crypto_skcipher_ctx(tfm);
crypto/cts.c:70:	struct crypto_skcipher *child = ctx->child;
crypto/cts.c:72:	return PTR_ALIGN((u8 *)(rctx + 1) + crypto_skcipher_reqsize(child),
crypto/cts.c:73:			 crypto_skcipher_alignmask(tfm) + 1);
crypto/cts.c:76:static int crypto_cts_setkey(struct crypto_skcipher *parent, const u8 *key,
crypto/cts.c:79:	struct crypto_cts_ctx *ctx = crypto_skcipher_ctx(parent);
crypto/cts.c:80:	struct crypto_skcipher *child = ctx->child;
crypto/cts.c:83:	crypto_skcipher_clear_flags(child, CRYPTO_TFM_REQ_MASK);
crypto/cts.c:84:	crypto_skcipher_set_flags(child, crypto_skcipher_get_flags(parent) &
crypto/cts.c:86:	err = crypto_skcipher_setkey(child, key, keylen);
crypto/cts.c:87:	crypto_skcipher_set_flags(parent, crypto_skcipher_get_flags(child) &
crypto/cts.c:105:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
crypto/cts.c:107:	int bsize = crypto_skcipher_blocksize(tfm);
crypto/cts.c:129:	return crypto_skcipher_encrypt(subreq);
crypto/cts.c:149:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
crypto/cts.c:151:	struct crypto_cts_ctx *ctx = crypto_skcipher_ctx(tfm);
crypto/cts.c:153:	int bsize = crypto_skcipher_blocksize(tfm);
crypto/cts.c:168:		return crypto_skcipher_encrypt(subreq);
crypto/cts.c:179:	return crypto_skcipher_encrypt(subreq) ?:
crypto/cts.c:186:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
crypto/cts.c:188:	int bsize = crypto_skcipher_blocksize(tfm);
crypto/cts.c:223:	return crypto_skcipher_decrypt(subreq);
crypto/cts.c:243:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
crypto/cts.c:245:	struct crypto_cts_ctx *ctx = crypto_skcipher_ctx(tfm);
crypto/cts.c:247:	int bsize = crypto_skcipher_blocksize(tfm);
crypto/cts.c:263:		return crypto_skcipher_decrypt(subreq);
crypto/cts.c:283:	return crypto_skcipher_decrypt(subreq) ?:
crypto/cts.c:287:static int crypto_cts_init_tfm(struct crypto_skcipher *tfm)
crypto/cts.c:290:	struct crypto_skcipher_spawn *spawn = skcipher_instance_ctx(inst);
crypto/cts.c:291:	struct crypto_cts_ctx *ctx = crypto_skcipher_ctx(tfm);
crypto/cts.c:292:	struct crypto_skcipher *cipher;
crypto/cts.c:303:	align = crypto_skcipher_alignmask(tfm);
crypto/cts.c:304:	bsize = crypto_skcipher_blocksize(cipher);
crypto/cts.c:306:			crypto_skcipher_reqsize(cipher),
crypto/cts.c:310:	crypto_skcipher_set_reqsize(tfm, reqsize);
crypto/cts.c:315:static void crypto_cts_exit_tfm(struct crypto_skcipher *tfm)
crypto/cts.c:317:	struct crypto_cts_ctx *ctx = crypto_skcipher_ctx(tfm);
crypto/cts.c:330:	struct crypto_skcipher_spawn *spawn;
crypto/cts.c:364:	if (crypto_skcipher_alg_ivsize(alg) != alg->base.cra_blocksize)
crypto/cts.c:381:	inst->alg.chunksize = crypto_skcipher_alg_chunksize(alg);
crypto/cts.c:382:	inst->alg.min_keysize = crypto_skcipher_alg_min_keysize(alg);
crypto/cts.c:383:	inst->alg.max_keysize = crypto_skcipher_alg_max_keysize(alg);
Binary file crypto/cts.o matches
crypto/drbg.c:501:		ret = crypto_skcipher_setkey(drbg->ctr_handle, drbg->C,
crypto/drbg.c:520:	ret = crypto_skcipher_setkey(drbg->ctr_handle, temp,
crypto/drbg.c:1653:	struct crypto_skcipher *sk_tfm;
crypto/drbg.c:1693:	alignmask = crypto_skcipher_alignmask(sk_tfm);
crypto/drbg.c:1754:		ret = crypto_wait_req(crypto_skcipher_encrypt(drbg->ctr_req),
Binary file crypto/drbg.o matches
crypto/ecb.c:50:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
crypto/ecb.c:59:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
Binary file crypto/ecb.o matches
crypto/echainiv.c:59:		err = crypto_skcipher_encrypt(nreq);
Binary file crypto/echainiv.ko matches
Binary file crypto/echainiv.o matches
crypto/gcm.c:27:	struct crypto_skcipher_spawn ctr;
crypto/gcm.c:32:	struct crypto_skcipher *ctr;
crypto/gcm.c:101:	struct crypto_skcipher *ctr = ctx->ctr;
crypto/gcm.c:113:	crypto_skcipher_clear_flags(ctr, CRYPTO_TFM_REQ_MASK);
crypto/gcm.c:114:	crypto_skcipher_set_flags(ctr, crypto_aead_get_flags(aead) &
crypto/gcm.c:116:	err = crypto_skcipher_setkey(ctr, key, keylen);
crypto/gcm.c:117:	crypto_aead_set_flags(aead, crypto_skcipher_get_flags(ctr) &
crypto/gcm.c:122:	data = kzalloc(sizeof(*data) + crypto_skcipher_reqsize(ctr),
crypto/gcm.c:137:	err = crypto_wait_req(crypto_skcipher_encrypt(&data->req),
crypto/gcm.c:483:	return crypto_skcipher_encrypt(skreq) ?:
crypto/gcm.c:520:	return crypto_skcipher_decrypt(skreq) ?: crypto_gcm_verify(req);
crypto/gcm.c:548:	struct crypto_skcipher *ctr;
crypto/gcm.c:570:		    crypto_skcipher_reqsize(ctr),
crypto/gcm.c:656:	    crypto_skcipher_alg_ivsize(ctr) != 16 ||
crypto/gcm.c:680:	inst->alg.chunksize = crypto_skcipher_alg_chunksize(ctr);
crypto/gcm.c:1046:	return crypto_skcipher_encrypt(nreq);
Binary file crypto/gcm.o matches
crypto/keywrap.c:54: *	unsigned int datalen = ptlen + crypto_skcipher_ivsize(tfm);
crypto/keywrap.c:57: *	u8 *pt = data + crypto_skcipher_ivsize(tfm);
crypto/keywrap.c:71: *	u8 *ct = data + crypto_skcipher_ivsize(tfm);
crypto/keywrap.c:72: *	unsigned int ctlen = datalen - crypto_skcipher_ivsize(tfm);
crypto/keywrap.c:125:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
crypto/keywrap.c:194:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
Binary file crypto/keywrap.ko matches
Binary file crypto/keywrap.o matches
crypto/lrw.c:35:	struct crypto_skcipher *child;
crypto/lrw.c:72:static int setkey(struct crypto_skcipher *parent, const u8 *key,
crypto/lrw.c:75:	struct priv *ctx = crypto_skcipher_ctx(parent);
crypto/lrw.c:76:	struct crypto_skcipher *child = ctx->child;
crypto/lrw.c:82:	crypto_skcipher_clear_flags(child, CRYPTO_TFM_REQ_MASK);
crypto/lrw.c:83:	crypto_skcipher_set_flags(child, crypto_skcipher_get_flags(parent) &
crypto/lrw.c:85:	err = crypto_skcipher_setkey(child, key, keylen - bsize);
crypto/lrw.c:86:	crypto_skcipher_set_flags(parent, crypto_skcipher_get_flags(child) &
crypto/lrw.c:149:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
crypto/lrw.c:150:	struct priv *ctx = crypto_skcipher_ctx(tfm);
crypto/lrw.c:229:	struct priv *ctx = crypto_skcipher_ctx(crypto_skcipher_reqtfm(req));
crypto/lrw.c:253:		crypto_skcipher_encrypt(subreq) ?:
crypto/lrw.c:264:		crypto_skcipher_decrypt(subreq) ?:
crypto/lrw.c:268:static int init_tfm(struct crypto_skcipher *tfm)
crypto/lrw.c:271:	struct crypto_skcipher_spawn *spawn = skcipher_instance_ctx(inst);
crypto/lrw.c:272:	struct priv *ctx = crypto_skcipher_ctx(tfm);
crypto/lrw.c:273:	struct crypto_skcipher *cipher;
crypto/lrw.c:281:	crypto_skcipher_set_reqsize(tfm, crypto_skcipher_reqsize(cipher) +
crypto/lrw.c:287:static void exit_tfm(struct crypto_skcipher *tfm)
crypto/lrw.c:289:	struct priv *ctx = crypto_skcipher_ctx(tfm);
crypto/lrw.c:304:	struct crypto_skcipher_spawn *spawn;
crypto/lrw.c:347:	alg = crypto_skcipher_spawn_alg(spawn);
crypto/lrw.c:353:	if (crypto_skcipher_alg_ivsize(alg))
crypto/lrw.c:394:	inst->alg.min_keysize = crypto_skcipher_alg_min_keysize(alg) +
crypto/lrw.c:396:	inst->alg.max_keysize = crypto_skcipher_alg_max_keysize(alg) +
Binary file crypto/lrw.ko matches
Binary file crypto/lrw.o matches
crypto/ofb.c:19:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
crypto/pcbc.c:70:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
crypto/pcbc.c:137:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
Binary file crypto/pcbc.ko matches
Binary file crypto/pcbc.o matches
crypto/salsa20_generic.c:111:static int salsa20_setkey(struct crypto_skcipher *tfm, const u8 *key,
crypto/salsa20_generic.c:116:	struct salsa20_ctx *ctx = crypto_skcipher_ctx(tfm);
crypto/salsa20_generic.c:155:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
crypto/salsa20_generic.c:156:	const struct salsa20_ctx *ctx = crypto_skcipher_ctx(tfm);
Binary file crypto/salsa20_generic.ko matches
Binary file crypto/salsa20_generic.o matches
crypto/seqiv.c:85:		err = crypto_skcipher_encrypt(nreq);
Binary file crypto/seqiv.o matches
crypto/simd.c:62:static int simd_skcipher_setkey(struct crypto_skcipher *tfm, const u8 *key,
crypto/simd.c:65:	struct simd_skcipher_ctx *ctx = crypto_skcipher_ctx(tfm);
crypto/simd.c:66:	struct crypto_skcipher *child = &ctx->cryptd_tfm->base;
crypto/simd.c:69:	crypto_skcipher_clear_flags(child, CRYPTO_TFM_REQ_MASK);
crypto/simd.c:70:	crypto_skcipher_set_flags(child, crypto_skcipher_get_flags(tfm) &
crypto/simd.c:72:	err = crypto_skcipher_setkey(child, key, key_len);
crypto/simd.c:73:	crypto_skcipher_set_flags(tfm, crypto_skcipher_get_flags(child) &
crypto/simd.c:80:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
crypto/simd.c:81:	struct simd_skcipher_ctx *ctx = crypto_skcipher_ctx(tfm);
crypto/simd.c:83:	struct crypto_skcipher *child;
crypto/simd.c:96:	return crypto_skcipher_encrypt(subreq);
crypto/simd.c:101:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
crypto/simd.c:102:	struct simd_skcipher_ctx *ctx = crypto_skcipher_ctx(tfm);
crypto/simd.c:104:	struct crypto_skcipher *child;
crypto/simd.c:117:	return crypto_skcipher_decrypt(subreq);
crypto/simd.c:120:static void simd_skcipher_exit(struct crypto_skcipher *tfm)
crypto/simd.c:122:	struct simd_skcipher_ctx *ctx = crypto_skcipher_ctx(tfm);
crypto/simd.c:127:static int simd_skcipher_init(struct crypto_skcipher *tfm)
crypto/simd.c:129:	struct simd_skcipher_ctx *ctx = crypto_skcipher_ctx(tfm);
crypto/simd.c:135:	alg = crypto_skcipher_alg(tfm);
crypto/simd.c:146:	reqsize = crypto_skcipher_reqsize(cryptd_skcipher_child(cryptd_tfm));
crypto/simd.c:147:	reqsize = max(reqsize, crypto_skcipher_reqsize(&cryptd_tfm->base));
crypto/simd.c:150:	crypto_skcipher_set_reqsize(tfm, reqsize);
crypto/simd.c:160:	struct crypto_skcipher *tfm;
crypto/simd.c:170:	ialg = crypto_skcipher_alg(tfm);
Binary file crypto/simd.o matches
crypto/skcipher.c:452:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
crypto/skcipher.c:469:	walk->blocksize = crypto_skcipher_blocksize(tfm);
crypto/skcipher.c:470:	walk->stride = crypto_skcipher_walksize(tfm);
crypto/skcipher.c:471:	walk->ivsize = crypto_skcipher_ivsize(tfm);
crypto/skcipher.c:472:	walk->alignmask = crypto_skcipher_alignmask(tfm);
crypto/skcipher.c:582:static unsigned int crypto_skcipher_extsize(struct crypto_alg *alg)
crypto/skcipher.c:593:static void skcipher_set_needkey(struct crypto_skcipher *tfm)
crypto/skcipher.c:596:		crypto_skcipher_set_flags(tfm, CRYPTO_TFM_NEED_KEY);
crypto/skcipher.c:599:static int skcipher_setkey_blkcipher(struct crypto_skcipher *tfm,
crypto/skcipher.c:602:	struct crypto_blkcipher **ctx = crypto_skcipher_ctx(tfm);
crypto/skcipher.c:607:	crypto_blkcipher_set_flags(blkcipher, crypto_skcipher_get_flags(tfm) &
crypto/skcipher.c:610:	crypto_skcipher_set_flags(tfm, crypto_blkcipher_get_flags(blkcipher) &
crypto/skcipher.c:617:	crypto_skcipher_clear_flags(tfm, CRYPTO_TFM_NEED_KEY);
crypto/skcipher.c:627:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
crypto/skcipher.c:628:	struct crypto_blkcipher **ctx = crypto_skcipher_ctx(tfm);
crypto/skcipher.c:641:	struct crypto_skcipher *skcipher = crypto_skcipher_reqtfm(req);
crypto/skcipher.c:642:	struct crypto_tfm *tfm = crypto_skcipher_tfm(skcipher);
crypto/skcipher.c:650:	struct crypto_skcipher *skcipher = crypto_skcipher_reqtfm(req);
crypto/skcipher.c:651:	struct crypto_tfm *tfm = crypto_skcipher_tfm(skcipher);
crypto/skcipher.c:667:	struct crypto_skcipher *skcipher = __crypto_skcipher_cast(tfm);
crypto/skcipher.c:698:static int skcipher_setkey_ablkcipher(struct crypto_skcipher *tfm,
crypto/skcipher.c:701:	struct crypto_ablkcipher **ctx = crypto_skcipher_ctx(tfm);
crypto/skcipher.c:707:				    crypto_skcipher_get_flags(tfm) &
crypto/skcipher.c:710:	crypto_skcipher_set_flags(tfm,
crypto/skcipher.c:718:	crypto_skcipher_clear_flags(tfm, CRYPTO_TFM_NEED_KEY);
crypto/skcipher.c:725:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
crypto/skcipher.c:726:	struct crypto_ablkcipher **ctx = crypto_skcipher_ctx(tfm);
crypto/skcipher.c:740:	struct crypto_skcipher *skcipher = crypto_skcipher_reqtfm(req);
crypto/skcipher.c:741:	struct crypto_tfm *tfm = crypto_skcipher_tfm(skcipher);
crypto/skcipher.c:749:	struct crypto_skcipher *skcipher = crypto_skcipher_reqtfm(req);
crypto/skcipher.c:750:	struct crypto_tfm *tfm = crypto_skcipher_tfm(skcipher);
crypto/skcipher.c:766:	struct crypto_skcipher *skcipher = __crypto_skcipher_cast(tfm);
crypto/skcipher.c:798:static int skcipher_setkey_unaligned(struct crypto_skcipher *tfm,
crypto/skcipher.c:801:	unsigned long alignmask = crypto_skcipher_alignmask(tfm);
crypto/skcipher.c:802:	struct skcipher_alg *cipher = crypto_skcipher_alg(tfm);
crypto/skcipher.c:819:static int skcipher_setkey(struct crypto_skcipher *tfm, const u8 *key,
crypto/skcipher.c:822:	struct skcipher_alg *cipher = crypto_skcipher_alg(tfm);
crypto/skcipher.c:823:	unsigned long alignmask = crypto_skcipher_alignmask(tfm);
crypto/skcipher.c:827:		crypto_skcipher_set_flags(tfm, CRYPTO_TFM_RES_BAD_KEY_LEN);
crypto/skcipher.c:841:	crypto_skcipher_clear_flags(tfm, CRYPTO_TFM_NEED_KEY);
crypto/skcipher.c:845:static void crypto_skcipher_exit_tfm(struct crypto_tfm *tfm)
crypto/skcipher.c:847:	struct crypto_skcipher *skcipher = __crypto_skcipher_cast(tfm);
crypto/skcipher.c:848:	struct skcipher_alg *alg = crypto_skcipher_alg(skcipher);
crypto/skcipher.c:853:static int crypto_skcipher_init_tfm(struct crypto_tfm *tfm)
crypto/skcipher.c:855:	struct crypto_skcipher *skcipher = __crypto_skcipher_cast(tfm);
crypto/skcipher.c:856:	struct skcipher_alg *alg = crypto_skcipher_alg(skcipher);
crypto/skcipher.c:873:		skcipher->base.exit = crypto_skcipher_exit_tfm;
crypto/skcipher.c:881:static void crypto_skcipher_free_instance(struct crypto_instance *inst)
crypto/skcipher.c:889:static void crypto_skcipher_show(struct seq_file *m, struct crypto_alg *alg)
crypto/skcipher.c:891:static void crypto_skcipher_show(struct seq_file *m, struct crypto_alg *alg)
crypto/skcipher.c:908:static int crypto_skcipher_report(struct sk_buff *skb, struct crypto_alg *alg)
crypto/skcipher.c:928:static int crypto_skcipher_report(struct sk_buff *skb, struct crypto_alg *alg)
crypto/skcipher.c:934:static const struct crypto_type crypto_skcipher_type2 = {
crypto/skcipher.c:935:	.extsize = crypto_skcipher_extsize,
crypto/skcipher.c:936:	.init_tfm = crypto_skcipher_init_tfm,
crypto/skcipher.c:937:	.free = crypto_skcipher_free_instance,
crypto/skcipher.c:939:	.show = crypto_skcipher_show,
crypto/skcipher.c:941:	.report = crypto_skcipher_report,
crypto/skcipher.c:945:	.tfmsize = offsetof(struct crypto_skcipher, base),
crypto/skcipher.c:948:int crypto_grab_skcipher(struct crypto_skcipher_spawn *spawn,
crypto/skcipher.c:951:	spawn->base.frontend = &crypto_skcipher_type2;
crypto/skcipher.c:956:struct crypto_skcipher *crypto_alloc_skcipher(const char *alg_name,
crypto/skcipher.c:959:	return crypto_alloc_tfm(alg_name, &crypto_skcipher_type2, type, mask);
crypto/skcipher.c:966:	struct crypto_skcipher *tfm;
crypto/skcipher.c:971:	tfm = crypto_alloc_tfm(alg_name, &crypto_skcipher_type2, type, mask);
crypto/skcipher.c:977:	if (!IS_ERR(tfm) && WARN_ON(crypto_skcipher_reqsize(tfm) >
crypto/skcipher.c:989:	return crypto_type_has_alg(alg_name, &crypto_skcipher_type2,
crypto/skcipher.c:1007:	base->cra_type = &crypto_skcipher_type2;
crypto/skcipher.c:1075:static int skcipher_setkey_simple(struct crypto_skcipher *tfm, const u8 *key,
crypto/skcipher.c:1082:	crypto_cipher_set_flags(cipher, crypto_skcipher_get_flags(tfm) &
crypto/skcipher.c:1085:	crypto_skcipher_set_flags(tfm, crypto_cipher_get_flags(cipher) &
crypto/skcipher.c:1090:static int skcipher_init_tfm_simple(struct crypto_skcipher *tfm)
crypto/skcipher.c:1094:	struct skcipher_ctx_simple *ctx = crypto_skcipher_ctx(tfm);
crypto/skcipher.c:1105:static void skcipher_exit_tfm_simple(struct crypto_skcipher *tfm)
crypto/skcipher.c:1107:	struct skcipher_ctx_simple *ctx = crypto_skcipher_ctx(tfm);
crypto/tcrypt.c:1167:			rc[i] = crypto_skcipher_encrypt(data[i].req);
crypto/tcrypt.c:1169:			rc[i] = crypto_skcipher_decrypt(data[i].req);
crypto/tcrypt.c:1258:	struct crypto_skcipher *tfm;
crypto/tcrypt.c:1317:		get_driver_name(crypto_skcipher, tfm), e);
crypto/tcrypt.c:1343:			crypto_skcipher_clear_flags(tfm, ~0);
crypto/tcrypt.c:1345:			ret = crypto_skcipher_setkey(tfm, key, *keysize);
crypto/tcrypt.c:1348:				       crypto_skcipher_get_flags(tfm));
crypto/tcrypt.c:1352:			iv_len = crypto_skcipher_ivsize(tfm);
crypto/tcrypt.c:1394:				       crypto_skcipher_get_flags(tfm));
crypto/tcrypt.c:1433:						crypto_skcipher_encrypt(req));
crypto/tcrypt.c:1436:						crypto_skcipher_decrypt(req));
crypto/tcrypt.c:1458:						crypto_skcipher_encrypt(req));
crypto/tcrypt.c:1461:						crypto_skcipher_decrypt(req));
crypto/tcrypt.c:1474:						crypto_skcipher_encrypt(req));
crypto/tcrypt.c:1477:						crypto_skcipher_decrypt(req));
crypto/tcrypt.c:1503:	struct crypto_skcipher *tfm;
crypto/tcrypt.c:1523:			get_driver_name(crypto_skcipher, tfm), e);
crypto/tcrypt.c:1563:			crypto_skcipher_clear_flags(tfm, ~0);
crypto/tcrypt.c:1565:			ret = crypto_skcipher_setkey(tfm, key, *keysize);
crypto/tcrypt.c:1568:					crypto_skcipher_get_flags(tfm));
crypto/tcrypt.c:1592:			iv_len = crypto_skcipher_ivsize(tfm);
crypto/tcrypt.c:1609:				       crypto_skcipher_get_flags(tfm));
Binary file crypto/tcrypt.ko matches
Binary file crypto/tcrypt.o matches
crypto/testmgr.c:2153:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
crypto/testmgr.c:2154:	const unsigned int alignmask = crypto_skcipher_alignmask(tfm);
crypto/testmgr.c:2155:	const unsigned int ivsize = crypto_skcipher_ivsize(tfm);
crypto/testmgr.c:2168:		crypto_skcipher_set_flags(tfm, CRYPTO_TFM_REQ_FORBID_WEAK_KEYS);
crypto/testmgr.c:2170:		crypto_skcipher_clear_flags(tfm,
crypto/testmgr.c:2172:	err = crypto_skcipher_setkey(tfm, vec->key, vec->klen);
crypto/testmgr.c:2178:		       crypto_skcipher_get_flags(tfm));
crypto/testmgr.c:2218:	testmgr_poison(req->__ctx, crypto_skcipher_reqsize(tfm));
crypto/testmgr.c:2224:	err = enc ? crypto_skcipher_encrypt(req) : crypto_skcipher_decrypt(req);
crypto/testmgr.c:2234:	    crypto_skcipher_reqtfm(req) != tfm ||
crypto/testmgr.c:2248:		if (crypto_skcipher_reqtfm(req) != tfm)
crypto/testmgr.c:2360:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
crypto/testmgr.c:2362:	const unsigned int ivsize = crypto_skcipher_ivsize(tfm);
crypto/testmgr.c:2372:	vec->setkey_error = crypto_skcipher_setkey(tfm, vec->key, vec->klen);
crypto/testmgr.c:2391:	vec->crypt_error = crypto_wait_req(crypto_skcipher_encrypt(req), &wait);
crypto/testmgr.c:2406:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
crypto/testmgr.c:2407:	const unsigned int ivsize = crypto_skcipher_ivsize(tfm);
crypto/testmgr.c:2408:	const unsigned int blocksize = crypto_skcipher_blocksize(tfm);
crypto/testmgr.c:2410:	const char *algname = crypto_skcipher_alg(tfm)->base.cra_name;
crypto/testmgr.c:2412:	struct crypto_skcipher *generic_tfm = NULL;
crypto/testmgr.c:2466:	if (ivsize != crypto_skcipher_ivsize(generic_tfm)) {
crypto/testmgr.c:2468:		       driver, ivsize, crypto_skcipher_ivsize(generic_tfm));
crypto/testmgr.c:2473:	if (blocksize != crypto_skcipher_blocksize(generic_tfm)) {
crypto/testmgr.c:2476:		       crypto_skcipher_blocksize(generic_tfm));
crypto/testmgr.c:2551:	struct crypto_skcipher *tfm;
crypto/xts.c:30:	struct crypto_skcipher *child;
crypto/xts.c:35:	struct crypto_skcipher_spawn spawn;
crypto/xts.c:44:static int setkey(struct crypto_skcipher *parent, const u8 *key,
crypto/xts.c:47:	struct priv *ctx = crypto_skcipher_ctx(parent);
crypto/xts.c:48:	struct crypto_skcipher *child;
crypto/xts.c:65:	crypto_cipher_set_flags(tweak, crypto_skcipher_get_flags(parent) &
crypto/xts.c:68:	crypto_skcipher_set_flags(parent, crypto_cipher_get_flags(tweak) &
crypto/xts.c:75:	crypto_skcipher_clear_flags(child, CRYPTO_TFM_REQ_MASK);
crypto/xts.c:76:	crypto_skcipher_set_flags(child, crypto_skcipher_get_flags(parent) &
crypto/xts.c:78:	err = crypto_skcipher_setkey(child, key, keylen);
crypto/xts.c:79:	crypto_skcipher_set_flags(parent, crypto_skcipher_get_flags(child) &
crypto/xts.c:94:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
crypto/xts.c:152:	struct priv *ctx = crypto_skcipher_ctx(crypto_skcipher_reqtfm(req));
crypto/xts.c:172:		crypto_skcipher_encrypt(subreq) ?:
crypto/xts.c:183:		crypto_skcipher_decrypt(subreq) ?:
crypto/xts.c:187:static int init_tfm(struct crypto_skcipher *tfm)
crypto/xts.c:191:	struct priv *ctx = crypto_skcipher_ctx(tfm);
crypto/xts.c:192:	struct crypto_skcipher *child;
crypto/xts.c:209:	crypto_skcipher_set_reqsize(tfm, crypto_skcipher_reqsize(child) +
crypto/xts.c:215:static void exit_tfm(struct crypto_skcipher *tfm)
crypto/xts.c:217:	struct priv *ctx = crypto_skcipher_ctx(tfm);
crypto/xts.c:275:	alg = crypto_skcipher_spawn_alg(&ctx->spawn);
crypto/xts.c:281:	if (crypto_skcipher_alg_ivsize(alg))
crypto/xts.c:322:	inst->alg.min_keysize = crypto_skcipher_alg_min_keysize(alg) * 2;
crypto/xts.c:323:	inst->alg.max_keysize = crypto_skcipher_alg_max_keysize(alg) * 2;
Binary file crypto/xts.o matches
root@armorer:/home/armorer/drm-misc# grep  -n 'crypto_skcipher*' crypto/* |less
root@armorer:/home/armorer/drm-misc# grep  -n 'crypto_skcipher*' crypto/* 
crypto/adiantum.c:65:	struct crypto_skcipher_spawn streamcipher_spawn;
crypto/adiantum.c:71:	struct crypto_skcipher *streamcipher;
crypto/adiantum.c:117:static int adiantum_setkey(struct crypto_skcipher *tfm, const u8 *key,
crypto/adiantum.c:120:	struct adiantum_tfm_ctx *tctx = crypto_skcipher_ctx(tfm);
crypto/adiantum.c:132:	crypto_skcipher_clear_flags(tctx->streamcipher, CRYPTO_TFM_REQ_MASK);
crypto/adiantum.c:133:	crypto_skcipher_set_flags(tctx->streamcipher,
crypto/adiantum.c:134:				  crypto_skcipher_get_flags(tfm) &
crypto/adiantum.c:136:	err = crypto_skcipher_setkey(tctx->streamcipher, key, keylen);
crypto/adiantum.c:137:	crypto_skcipher_set_flags(tfm,
crypto/adiantum.c:138:				crypto_skcipher_get_flags(tctx->streamcipher) &
crypto/adiantum.c:145:		       crypto_skcipher_reqsize(tctx->streamcipher), GFP_KERNEL);
crypto/adiantum.c:157:	err = crypto_wait_req(crypto_skcipher_encrypt(&data->req), &data->wait);
crypto/adiantum.c:165:				crypto_skcipher_get_flags(tfm) &
crypto/adiantum.c:169:	crypto_skcipher_set_flags(tfm,
crypto/adiantum.c:181:	crypto_shash_set_flags(tctx->hash, crypto_skcipher_get_flags(tfm) &
crypto/adiantum.c:184:	crypto_skcipher_set_flags(tfm, crypto_shash_get_flags(tctx->hash) &
crypto/adiantum.c:229:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
crypto/adiantum.c:230:	const struct adiantum_tfm_ctx *tctx = crypto_skcipher_ctx(tfm);
crypto/adiantum.c:258:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
crypto/adiantum.c:259:	const struct adiantum_tfm_ctx *tctx = crypto_skcipher_ctx(tfm);
crypto/adiantum.c:292:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
crypto/adiantum.c:293:	const struct adiantum_tfm_ctx *tctx = crypto_skcipher_ctx(tfm);
crypto/adiantum.c:332:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
crypto/adiantum.c:333:	const struct adiantum_tfm_ctx *tctx = crypto_skcipher_ctx(tfm);
crypto/adiantum.c:391:	return crypto_skcipher_encrypt(&rctx->u.streamcipher_req) ?:
crypto/adiantum.c:405:static int adiantum_init_tfm(struct crypto_skcipher *tfm)
crypto/adiantum.c:409:	struct adiantum_tfm_ctx *tctx = crypto_skcipher_ctx(tfm);
crypto/adiantum.c:410:	struct crypto_skcipher *streamcipher;
crypto/adiantum.c:443:			  crypto_skcipher_reqsize(streamcipher));
crypto/adiantum.c:445:	crypto_skcipher_set_reqsize(tfm,
crypto/adiantum.c:457:static void adiantum_exit_tfm(struct crypto_skcipher *tfm)
crypto/adiantum.c:459:	struct adiantum_tfm_ctx *tctx = crypto_skcipher_ctx(tfm);
crypto/adiantum.c:618:	inst->alg.min_keysize = crypto_skcipher_alg_min_keysize(streamcipher_alg);
crypto/adiantum.c:619:	inst->alg.max_keysize = crypto_skcipher_alg_max_keysize(streamcipher_alg);
crypto/algif_aead.c:89:	return crypto_skcipher_encrypt(skreq);
Binary file crypto/algif_aead.ko matches
Binary file crypto/algif_aead.o matches
crypto/algif_skcipher.c:48:	struct crypto_skcipher *tfm = pask->private;
crypto/algif_skcipher.c:49:	unsigned ivsize = crypto_skcipher_ivsize(tfm);
crypto/algif_skcipher.c:62:	struct crypto_skcipher *tfm = pask->private;
crypto/algif_skcipher.c:63:	unsigned int bs = crypto_skcipher_blocksize(tfm);
crypto/algif_skcipher.c:76:				     crypto_skcipher_reqsize(tfm));
crypto/algif_skcipher.c:130:			crypto_skcipher_encrypt(&areq->cra_u.skcipher_req) :
crypto/algif_skcipher.c:131:			crypto_skcipher_decrypt(&areq->cra_u.skcipher_req);
crypto/algif_skcipher.c:145:			crypto_skcipher_encrypt(&areq->cra_u.skcipher_req) :
crypto/algif_skcipher.c:146:			crypto_skcipher_decrypt(&areq->cra_u.skcipher_req),
crypto/algif_skcipher.c:217:	struct crypto_skcipher *tfm;
crypto/algif_skcipher.c:231:	if (crypto_skcipher_get_flags(tfm) & CRYPTO_TFM_NEED_KEY)
crypto/algif_skcipher.c:320:	return crypto_skcipher_setkey(private, key, keylen);
crypto/algif_skcipher.c:329:	struct crypto_skcipher *tfm = pask->private;
crypto/algif_skcipher.c:332:	sock_kzfree_s(sk, ctx->iv, crypto_skcipher_ivsize(tfm));
crypto/algif_skcipher.c:341:	struct crypto_skcipher *tfm = private;
crypto/algif_skcipher.c:348:	ctx->iv = sock_kmalloc(sk, crypto_skcipher_ivsize(tfm),
crypto/algif_skcipher.c:355:	memset(ctx->iv, 0, crypto_skcipher_ivsize(tfm));
crypto/algif_skcipher.c:375:	struct crypto_skcipher *tfm = private;
crypto/algif_skcipher.c:377:	if (crypto_skcipher_get_flags(tfm) & CRYPTO_TFM_NEED_KEY)
Binary file crypto/algif_skcipher.ko matches
Binary file crypto/algif_skcipher.o matches
crypto/arc4.c:50:static int arc4_set_key_skcipher(struct crypto_skcipher *tfm, const u8 *in_key,
crypto/arc4.c:100:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
crypto/arc4.c:101:	struct arc4_ctx *ctx = crypto_skcipher_ctx(tfm);
Binary file crypto/arc4.ko matches
Binary file crypto/arc4.o matches
grep: crypto/asymmetric_keys: Is a directory
grep: crypto/async_tx: Is a directory
crypto/authenc.c:29:	struct crypto_skcipher_spawn enc;
crypto/authenc.c:35:	struct crypto_skcipher *enc;
crypto/authenc.c:94:	struct crypto_skcipher *enc = ctx->enc;
crypto/authenc.c:111:	crypto_skcipher_clear_flags(enc, CRYPTO_TFM_REQ_MASK);
crypto/authenc.c:112:	crypto_skcipher_set_flags(enc, crypto_aead_get_flags(authenc) &
crypto/authenc.c:114:	err = crypto_skcipher_setkey(enc, keys.enckey, keys.enckeylen);
crypto/authenc.c:115:	crypto_aead_set_flags(authenc, crypto_skcipher_get_flags(enc) &
crypto/authenc.c:204:	return crypto_skcipher_encrypt(skreq);
crypto/authenc.c:214:	struct crypto_skcipher *enc = ctx->enc;
crypto/authenc.c:237:	err = crypto_skcipher_encrypt(skreq);
crypto/authenc.c:276:	return crypto_skcipher_decrypt(skreq);
crypto/authenc.c:328:	struct crypto_skcipher *enc;
crypto/authenc.c:358:		      crypto_skcipher_reqsize(enc)));
crypto/authenc.c:464:	inst->alg.ivsize = crypto_skcipher_alg_ivsize(enc);
crypto/authenc.c:465:	inst->alg.chunksize = crypto_skcipher_alg_chunksize(enc);
crypto/authencesn.c:32:	struct crypto_skcipher_spawn enc;
crypto/authencesn.c:38:	struct crypto_skcipher *enc;
crypto/authencesn.c:68:	struct crypto_skcipher *enc = ctx->enc;
crypto/authencesn.c:85:	crypto_skcipher_clear_flags(enc, CRYPTO_TFM_REQ_MASK);
crypto/authencesn.c:86:	crypto_skcipher_set_flags(enc, crypto_aead_get_flags(authenc_esn) &
crypto/authencesn.c:88:	err = crypto_skcipher_setkey(enc, keys.enckey, keys.enckeylen);
crypto/authencesn.c:89:	crypto_aead_set_flags(authenc_esn, crypto_skcipher_get_flags(enc) &
crypto/authencesn.c:193:	return crypto_skcipher_encrypt(skreq);
crypto/authencesn.c:203:	struct crypto_skcipher *enc = ctx->enc;
crypto/authencesn.c:227:	err = crypto_skcipher_encrypt(skreq);
crypto/authencesn.c:273:	return crypto_skcipher_decrypt(skreq);
crypto/authencesn.c:343:	struct crypto_skcipher *enc;
crypto/authencesn.c:376:		      crypto_skcipher_reqsize(enc)));
crypto/authencesn.c:478:	inst->alg.ivsize = crypto_skcipher_alg_ivsize(enc);
crypto/authencesn.c:479:	inst->alg.chunksize = crypto_skcipher_alg_chunksize(enc);
Binary file crypto/authencesn.ko matches
Binary file crypto/authencesn.o matches
Binary file crypto/authenc.ko matches
Binary file crypto/authenc.o matches
crypto/cbc.c:22:static inline void crypto_cbc_encrypt_one(struct crypto_skcipher *tfm,
crypto/cbc.c:33:static inline void crypto_cbc_decrypt_one(struct crypto_skcipher *tfm,
crypto/cbc.c:41:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
Binary file crypto/cbc.o matches
crypto/ccm.c:26:	struct crypto_skcipher_spawn ctr;
crypto/ccm.c:32:	struct crypto_skcipher *ctr;
crypto/ccm.c:97:	struct crypto_skcipher *ctr = ctx->ctr;
crypto/ccm.c:101:	crypto_skcipher_clear_flags(ctr, CRYPTO_TFM_REQ_MASK);
crypto/ccm.c:102:	crypto_skcipher_set_flags(ctr, crypto_aead_get_flags(aead) &
crypto/ccm.c:104:	err = crypto_skcipher_setkey(ctr, key, keylen);
crypto/ccm.c:105:	crypto_aead_set_flags(aead, crypto_skcipher_get_flags(ctr) &
crypto/ccm.c:326:	err = crypto_skcipher_encrypt(skreq);
crypto/ccm.c:391:	err = crypto_skcipher_decrypt(skreq);
crypto/ccm.c:412:	struct crypto_skcipher *ctr;
crypto/ccm.c:433:		max(crypto_ahash_reqsize(mac), crypto_skcipher_reqsize(ctr)));
crypto/ccm.c:515:	    crypto_skcipher_alg_ivsize(ctr) != 16 ||
crypto/ccm.c:540:	inst->alg.chunksize = crypto_skcipher_alg_chunksize(ctr);
Binary file crypto/ccm.ko matches
Binary file crypto/ccm.o matches
crypto/cfb.c:30:static unsigned int crypto_cfb_bsize(struct crypto_skcipher *tfm)
crypto/cfb.c:35:static void crypto_cfb_encrypt_one(struct crypto_skcipher *tfm,
crypto/cfb.c:43:			     struct crypto_skcipher *tfm)
crypto/cfb.c:45:	const unsigned long alignmask = crypto_skcipher_alignmask(tfm);
crypto/cfb.c:58:				      struct crypto_skcipher *tfm)
crypto/cfb.c:81:				      struct crypto_skcipher *tfm)
crypto/cfb.c:104:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
crypto/cfb.c:128:				      struct crypto_skcipher *tfm)
crypto/cfb.c:151:				      struct crypto_skcipher *tfm)
crypto/cfb.c:170:				     struct crypto_skcipher *tfm)
crypto/cfb.c:180:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
crypto/chacha20poly1305.c:26:	struct crypto_skcipher_spawn chacha;
crypto/chacha20poly1305.c:32:	struct crypto_skcipher *chacha;
crypto/chacha20poly1305.c:150:	err = crypto_skcipher_decrypt(&creq->req);
crypto/chacha20poly1305.c:400:	err = crypto_skcipher_decrypt(&creq->req);
crypto/chacha20poly1305.c:439:	err = crypto_skcipher_encrypt(&creq->req);
crypto/chacha20poly1305.c:501:	crypto_skcipher_clear_flags(ctx->chacha, CRYPTO_TFM_REQ_MASK);
crypto/chacha20poly1305.c:502:	crypto_skcipher_set_flags(ctx->chacha, crypto_aead_get_flags(aead) &
crypto/chacha20poly1305.c:505:	err = crypto_skcipher_setkey(ctx->chacha, key, keylen);
crypto/chacha20poly1305.c:506:	crypto_aead_set_flags(aead, crypto_skcipher_get_flags(ctx->chacha) &
crypto/chacha20poly1305.c:525:	struct crypto_skcipher *chacha;
crypto/chacha20poly1305.c:550:		    crypto_skcipher_reqsize(chacha),
crypto/chacha20poly1305.c:640:	if (crypto_skcipher_alg_ivsize(chacha) != CHACHA_IV_SIZE)
crypto/chacha20poly1305.c:666:	inst->alg.chunksize = crypto_skcipher_alg_chunksize(chacha);
Binary file crypto/chacha20poly1305.ko matches
Binary file crypto/chacha20poly1305.o matches
crypto/chacha_generic.c:84:static int chacha_setkey(struct crypto_skcipher *tfm, const u8 *key,
crypto/chacha_generic.c:87:	struct chacha_ctx *ctx = crypto_skcipher_ctx(tfm);
crypto/chacha_generic.c:100:int crypto_chacha20_setkey(struct crypto_skcipher *tfm, const u8 *key,
crypto/chacha_generic.c:107:int crypto_chacha12_setkey(struct crypto_skcipher *tfm, const u8 *key,
crypto/chacha_generic.c:116:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
crypto/chacha_generic.c:117:	struct chacha_ctx *ctx = crypto_skcipher_ctx(tfm);
crypto/chacha_generic.c:125:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
crypto/chacha_generic.c:126:	struct chacha_ctx *ctx = crypto_skcipher_ctx(tfm);
Binary file crypto/chacha_generic.ko matches
Binary file crypto/chacha_generic.o matches
crypto/cryptd.c:54:	struct crypto_skcipher_spawn spawn;
crypto/cryptd.c:253:static int cryptd_skcipher_setkey(struct crypto_skcipher *parent,
crypto/cryptd.c:256:	struct cryptd_skcipher_ctx *ctx = crypto_skcipher_ctx(parent);
crypto/cryptd.c:262:				       crypto_skcipher_get_flags(parent) &
crypto/cryptd.c:265:	crypto_skcipher_set_flags(parent,
crypto/cryptd.c:273:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
crypto/cryptd.c:274:	struct cryptd_skcipher_ctx *ctx = crypto_skcipher_ctx(tfm);
crypto/cryptd.c:291:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
crypto/cryptd.c:292:	struct cryptd_skcipher_ctx *ctx = crypto_skcipher_ctx(tfm);
crypto/cryptd.c:305:	err = crypto_skcipher_encrypt(subreq);
crypto/cryptd.c:319:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
crypto/cryptd.c:320:	struct cryptd_skcipher_ctx *ctx = crypto_skcipher_ctx(tfm);
crypto/cryptd.c:333:	err = crypto_skcipher_decrypt(subreq);
crypto/cryptd.c:346:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
crypto/cryptd.c:349:	queue = cryptd_get_queue(crypto_skcipher_tfm(tfm));
crypto/cryptd.c:366:static int cryptd_skcipher_init_tfm(struct crypto_skcipher *tfm)
crypto/cryptd.c:370:	struct crypto_skcipher_spawn *spawn = &ictx->spawn;
crypto/cryptd.c:371:	struct cryptd_skcipher_ctx *ctx = crypto_skcipher_ctx(tfm);
crypto/cryptd.c:372:	struct crypto_skcipher *cipher;
crypto/cryptd.c:379:	crypto_skcipher_set_reqsize(
crypto/cryptd.c:384:static void cryptd_skcipher_exit_tfm(struct crypto_skcipher *tfm)
crypto/cryptd.c:386:	struct cryptd_skcipher_ctx *ctx = crypto_skcipher_ctx(tfm);
crypto/cryptd.c:439:	inst->alg.ivsize = crypto_skcipher_alg_ivsize(alg);
crypto/cryptd.c:440:	inst->alg.chunksize = crypto_skcipher_alg_chunksize(alg);
crypto/cryptd.c:441:	inst->alg.min_keysize = crypto_skcipher_alg_min_keysize(alg);
crypto/cryptd.c:442:	inst->alg.max_keysize = crypto_skcipher_alg_max_keysize(alg);
crypto/cryptd.c:968:	struct crypto_skcipher *tfm;
crypto/cryptd.c:983:	ctx = crypto_skcipher_ctx(tfm);
crypto/cryptd.c:990:struct crypto_skcipher *cryptd_skcipher_child(struct cryptd_skcipher *tfm)
crypto/cryptd.c:992:	struct cryptd_skcipher_ctx *ctx = crypto_skcipher_ctx(&tfm->base);
crypto/cryptd.c:1000:	struct cryptd_skcipher_ctx *ctx = crypto_skcipher_ctx(&tfm->base);
crypto/cryptd.c:1008:	struct cryptd_skcipher_ctx *ctx = crypto_skcipher_ctx(&tfm->base);
Binary file crypto/cryptd.ko matches
Binary file crypto/cryptd.o matches
crypto/crypto_null.c:68:static int null_skcipher_setkey(struct crypto_skcipher *tfm, const u8 *key,
Binary file crypto/crypto_null.o matches
Binary file crypto/crypto_simd.ko matches
Binary file crypto/crypto_simd.o matches
crypto/ctr.c:23:	struct crypto_skcipher *child;
crypto/ctr.c:105:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
crypto/ctr.c:174:static int crypto_rfc3686_setkey(struct crypto_skcipher *parent,
crypto/ctr.c:177:	struct crypto_rfc3686_ctx *ctx = crypto_skcipher_ctx(parent);
crypto/ctr.c:178:	struct crypto_skcipher *child = ctx->child;
crypto/ctr.c:190:	crypto_skcipher_clear_flags(child, CRYPTO_TFM_REQ_MASK);
crypto/ctr.c:191:	crypto_skcipher_set_flags(child, crypto_skcipher_get_flags(parent) &
crypto/ctr.c:193:	err = crypto_skcipher_setkey(child, key, keylen);
crypto/ctr.c:194:	crypto_skcipher_set_flags(parent, crypto_skcipher_get_flags(child) &
crypto/ctr.c:202:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
crypto/ctr.c:203:	struct crypto_rfc3686_ctx *ctx = crypto_skcipher_ctx(tfm);
crypto/ctr.c:204:	struct crypto_skcipher *child = ctx->child;
crypto/ctr.c:205:	unsigned long align = crypto_skcipher_alignmask(tfm);
crypto/ctr.c:225:	return crypto_skcipher_encrypt(subreq);
crypto/ctr.c:228:static int crypto_rfc3686_init_tfm(struct crypto_skcipher *tfm)
crypto/ctr.c:231:	struct crypto_skcipher_spawn *spawn = skcipher_instance_ctx(inst);
crypto/ctr.c:232:	struct crypto_rfc3686_ctx *ctx = crypto_skcipher_ctx(tfm);
crypto/ctr.c:233:	struct crypto_skcipher *cipher;
crypto/ctr.c:243:	align = crypto_skcipher_alignmask(tfm);
crypto/ctr.c:246:		  crypto_skcipher_reqsize(cipher);
crypto/ctr.c:247:	crypto_skcipher_set_reqsize(tfm, reqsize);
crypto/ctr.c:252:static void crypto_rfc3686_exit_tfm(struct crypto_skcipher *tfm)
crypto/ctr.c:254:	struct crypto_rfc3686_ctx *ctx = crypto_skcipher_ctx(tfm);
crypto/ctr.c:261:	struct crypto_skcipher_spawn *spawn = skcipher_instance_ctx(inst);
crypto/ctr.c:273:	struct crypto_skcipher_spawn *spawn;
crypto/ctr.c:309:	if (crypto_skcipher_alg_ivsize(alg) != CTR_RFC3686_BLOCK_SIZE)
crypto/ctr.c:332:	inst->alg.chunksize = crypto_skcipher_alg_chunksize(alg);
crypto/ctr.c:333:	inst->alg.min_keysize = crypto_skcipher_alg_min_keysize(alg) +
crypto/ctr.c:335:	inst->alg.max_keysize = crypto_skcipher_alg_max_keysize(alg) +
Binary file crypto/ctr.o matches
crypto/cts.c:56:	struct crypto_skcipher *child;
crypto/cts.c:68:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
crypto/cts.c:69:	struct crypto_cts_ctx *ctx = crypto_skcipher_ctx(tfm);
crypto/cts.c:70:	struct crypto_skcipher *child = ctx->child;
crypto/cts.c:72:	return PTR_ALIGN((u8 *)(rctx + 1) + crypto_skcipher_reqsize(child),
crypto/cts.c:73:			 crypto_skcipher_alignmask(tfm) + 1);
crypto/cts.c:76:static int crypto_cts_setkey(struct crypto_skcipher *parent, const u8 *key,
crypto/cts.c:79:	struct crypto_cts_ctx *ctx = crypto_skcipher_ctx(parent);
crypto/cts.c:80:	struct crypto_skcipher *child = ctx->child;
crypto/cts.c:83:	crypto_skcipher_clear_flags(child, CRYPTO_TFM_REQ_MASK);
crypto/cts.c:84:	crypto_skcipher_set_flags(child, crypto_skcipher_get_flags(parent) &
crypto/cts.c:86:	err = crypto_skcipher_setkey(child, key, keylen);
crypto/cts.c:87:	crypto_skcipher_set_flags(parent, crypto_skcipher_get_flags(child) &
crypto/cts.c:105:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
crypto/cts.c:107:	int bsize = crypto_skcipher_blocksize(tfm);
crypto/cts.c:129:	return crypto_skcipher_encrypt(subreq);
crypto/cts.c:149:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
crypto/cts.c:151:	struct crypto_cts_ctx *ctx = crypto_skcipher_ctx(tfm);
crypto/cts.c:153:	int bsize = crypto_skcipher_blocksize(tfm);
crypto/cts.c:168:		return crypto_skcipher_encrypt(subreq);
crypto/cts.c:179:	return crypto_skcipher_encrypt(subreq) ?:
crypto/cts.c:186:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
crypto/cts.c:188:	int bsize = crypto_skcipher_blocksize(tfm);
crypto/cts.c:223:	return crypto_skcipher_decrypt(subreq);
crypto/cts.c:243:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
crypto/cts.c:245:	struct crypto_cts_ctx *ctx = crypto_skcipher_ctx(tfm);
crypto/cts.c:247:	int bsize = crypto_skcipher_blocksize(tfm);
crypto/cts.c:263:		return crypto_skcipher_decrypt(subreq);
crypto/cts.c:283:	return crypto_skcipher_decrypt(subreq) ?:
crypto/cts.c:287:static int crypto_cts_init_tfm(struct crypto_skcipher *tfm)
crypto/cts.c:290:	struct crypto_skcipher_spawn *spawn = skcipher_instance_ctx(inst);
crypto/cts.c:291:	struct crypto_cts_ctx *ctx = crypto_skcipher_ctx(tfm);
crypto/cts.c:292:	struct crypto_skcipher *cipher;
crypto/cts.c:303:	align = crypto_skcipher_alignmask(tfm);
crypto/cts.c:304:	bsize = crypto_skcipher_blocksize(cipher);
crypto/cts.c:306:			crypto_skcipher_reqsize(cipher),
crypto/cts.c:310:	crypto_skcipher_set_reqsize(tfm, reqsize);
crypto/cts.c:315:static void crypto_cts_exit_tfm(struct crypto_skcipher *tfm)
crypto/cts.c:317:	struct crypto_cts_ctx *ctx = crypto_skcipher_ctx(tfm);
crypto/cts.c:330:	struct crypto_skcipher_spawn *spawn;
crypto/cts.c:364:	if (crypto_skcipher_alg_ivsize(alg) != alg->base.cra_blocksize)
crypto/cts.c:381:	inst->alg.chunksize = crypto_skcipher_alg_chunksize(alg);
crypto/cts.c:382:	inst->alg.min_keysize = crypto_skcipher_alg_min_keysize(alg);
crypto/cts.c:383:	inst->alg.max_keysize = crypto_skcipher_alg_max_keysize(alg);
Binary file crypto/cts.o matches
crypto/drbg.c:501:		ret = crypto_skcipher_setkey(drbg->ctr_handle, drbg->C,
crypto/drbg.c:520:	ret = crypto_skcipher_setkey(drbg->ctr_handle, temp,
crypto/drbg.c:1653:	struct crypto_skcipher *sk_tfm;
crypto/drbg.c:1693:	alignmask = crypto_skcipher_alignmask(sk_tfm);
crypto/drbg.c:1754:		ret = crypto_wait_req(crypto_skcipher_encrypt(drbg->ctr_req),
Binary file crypto/drbg.o matches
crypto/ecb.c:50:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
crypto/ecb.c:59:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
Binary file crypto/ecb.o matches
crypto/echainiv.c:59:		err = crypto_skcipher_encrypt(nreq);
Binary file crypto/echainiv.ko matches
Binary file crypto/echainiv.o matches
crypto/gcm.c:27:	struct crypto_skcipher_spawn ctr;
crypto/gcm.c:32:	struct crypto_skcipher *ctr;
crypto/gcm.c:101:	struct crypto_skcipher *ctr = ctx->ctr;
crypto/gcm.c:113:	crypto_skcipher_clear_flags(ctr, CRYPTO_TFM_REQ_MASK);
crypto/gcm.c:114:	crypto_skcipher_set_flags(ctr, crypto_aead_get_flags(aead) &
crypto/gcm.c:116:	err = crypto_skcipher_setkey(ctr, key, keylen);
crypto/gcm.c:117:	crypto_aead_set_flags(aead, crypto_skcipher_get_flags(ctr) &
crypto/gcm.c:122:	data = kzalloc(sizeof(*data) + crypto_skcipher_reqsize(ctr),
crypto/gcm.c:137:	err = crypto_wait_req(crypto_skcipher_encrypt(&data->req),
crypto/gcm.c:483:	return crypto_skcipher_encrypt(skreq) ?:
crypto/gcm.c:520:	return crypto_skcipher_decrypt(skreq) ?: crypto_gcm_verify(req);
crypto/gcm.c:548:	struct crypto_skcipher *ctr;
crypto/gcm.c:570:		    crypto_skcipher_reqsize(ctr),
crypto/gcm.c:656:	    crypto_skcipher_alg_ivsize(ctr) != 16 ||
crypto/gcm.c:680:	inst->alg.chunksize = crypto_skcipher_alg_chunksize(ctr);
crypto/gcm.c:1046:	return crypto_skcipher_encrypt(nreq);
Binary file crypto/gcm.o matches
crypto/keywrap.c:54: *	unsigned int datalen = ptlen + crypto_skcipher_ivsize(tfm);
crypto/keywrap.c:57: *	u8 *pt = data + crypto_skcipher_ivsize(tfm);
crypto/keywrap.c:71: *	u8 *ct = data + crypto_skcipher_ivsize(tfm);
crypto/keywrap.c:72: *	unsigned int ctlen = datalen - crypto_skcipher_ivsize(tfm);
crypto/keywrap.c:125:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
crypto/keywrap.c:194:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
Binary file crypto/keywrap.ko matches
Binary file crypto/keywrap.o matches
crypto/lrw.c:35:	struct crypto_skcipher *child;
crypto/lrw.c:72:static int setkey(struct crypto_skcipher *parent, const u8 *key,
crypto/lrw.c:75:	struct priv *ctx = crypto_skcipher_ctx(parent);
crypto/lrw.c:76:	struct crypto_skcipher *child = ctx->child;
crypto/lrw.c:82:	crypto_skcipher_clear_flags(child, CRYPTO_TFM_REQ_MASK);
crypto/lrw.c:83:	crypto_skcipher_set_flags(child, crypto_skcipher_get_flags(parent) &
crypto/lrw.c:85:	err = crypto_skcipher_setkey(child, key, keylen - bsize);
crypto/lrw.c:86:	crypto_skcipher_set_flags(parent, crypto_skcipher_get_flags(child) &
crypto/lrw.c:149:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
crypto/lrw.c:150:	struct priv *ctx = crypto_skcipher_ctx(tfm);
crypto/lrw.c:229:	struct priv *ctx = crypto_skcipher_ctx(crypto_skcipher_reqtfm(req));
crypto/lrw.c:253:		crypto_skcipher_encrypt(subreq) ?:
crypto/lrw.c:264:		crypto_skcipher_decrypt(subreq) ?:
crypto/lrw.c:268:static int init_tfm(struct crypto_skcipher *tfm)
crypto/lrw.c:271:	struct crypto_skcipher_spawn *spawn = skcipher_instance_ctx(inst);
crypto/lrw.c:272:	struct priv *ctx = crypto_skcipher_ctx(tfm);
crypto/lrw.c:273:	struct crypto_skcipher *cipher;
crypto/lrw.c:281:	crypto_skcipher_set_reqsize(tfm, crypto_skcipher_reqsize(cipher) +
crypto/lrw.c:287:static void exit_tfm(struct crypto_skcipher *tfm)
crypto/lrw.c:289:	struct priv *ctx = crypto_skcipher_ctx(tfm);
crypto/lrw.c:304:	struct crypto_skcipher_spawn *spawn;
crypto/lrw.c:347:	alg = crypto_skcipher_spawn_alg(spawn);
crypto/lrw.c:353:	if (crypto_skcipher_alg_ivsize(alg))
crypto/lrw.c:394:	inst->alg.min_keysize = crypto_skcipher_alg_min_keysize(alg) +
crypto/lrw.c:396:	inst->alg.max_keysize = crypto_skcipher_alg_max_keysize(alg) +
Binary file crypto/lrw.ko matches
Binary file crypto/lrw.o matches
crypto/ofb.c:19:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
crypto/pcbc.c:70:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
crypto/pcbc.c:137:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
Binary file crypto/pcbc.ko matches
Binary file crypto/pcbc.o matches
crypto/salsa20_generic.c:111:static int salsa20_setkey(struct crypto_skcipher *tfm, const u8 *key,
crypto/salsa20_generic.c:116:	struct salsa20_ctx *ctx = crypto_skcipher_ctx(tfm);
crypto/salsa20_generic.c:155:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
crypto/salsa20_generic.c:156:	const struct salsa20_ctx *ctx = crypto_skcipher_ctx(tfm);
Binary file crypto/salsa20_generic.ko matches
Binary file crypto/salsa20_generic.o matches
crypto/seqiv.c:85:		err = crypto_skcipher_encrypt(nreq);
Binary file crypto/seqiv.o matches
crypto/simd.c:62:static int simd_skcipher_setkey(struct crypto_skcipher *tfm, const u8 *key,
crypto/simd.c:65:	struct simd_skcipher_ctx *ctx = crypto_skcipher_ctx(tfm);
crypto/simd.c:66:	struct crypto_skcipher *child = &ctx->cryptd_tfm->base;
crypto/simd.c:69:	crypto_skcipher_clear_flags(child, CRYPTO_TFM_REQ_MASK);
crypto/simd.c:70:	crypto_skcipher_set_flags(child, crypto_skcipher_get_flags(tfm) &
crypto/simd.c:72:	err = crypto_skcipher_setkey(child, key, key_len);
crypto/simd.c:73:	crypto_skcipher_set_flags(tfm, crypto_skcipher_get_flags(child) &
crypto/simd.c:80:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
crypto/simd.c:81:	struct simd_skcipher_ctx *ctx = crypto_skcipher_ctx(tfm);
crypto/simd.c:83:	struct crypto_skcipher *child;
crypto/simd.c:96:	return crypto_skcipher_encrypt(subreq);
crypto/simd.c:101:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
crypto/simd.c:102:	struct simd_skcipher_ctx *ctx = crypto_skcipher_ctx(tfm);
crypto/simd.c:104:	struct crypto_skcipher *child;
crypto/simd.c:117:	return crypto_skcipher_decrypt(subreq);
crypto/simd.c:120:static void simd_skcipher_exit(struct crypto_skcipher *tfm)
crypto/simd.c:122:	struct simd_skcipher_ctx *ctx = crypto_skcipher_ctx(tfm);
crypto/simd.c:127:static int simd_skcipher_init(struct crypto_skcipher *tfm)
crypto/simd.c:129:	struct simd_skcipher_ctx *ctx = crypto_skcipher_ctx(tfm);
crypto/simd.c:135:	alg = crypto_skcipher_alg(tfm);
crypto/simd.c:146:	reqsize = crypto_skcipher_reqsize(cryptd_skcipher_child(cryptd_tfm));
crypto/simd.c:147:	reqsize = max(reqsize, crypto_skcipher_reqsize(&cryptd_tfm->base));
crypto/simd.c:150:	crypto_skcipher_set_reqsize(tfm, reqsize);
crypto/simd.c:160:	struct crypto_skcipher *tfm;
crypto/simd.c:170:	ialg = crypto_skcipher_alg(tfm);
Binary file crypto/simd.o matches
crypto/skcipher.c:452:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
crypto/skcipher.c:469:	walk->blocksize = crypto_skcipher_blocksize(tfm);
crypto/skcipher.c:470:	walk->stride = crypto_skcipher_walksize(tfm);
crypto/skcipher.c:471:	walk->ivsize = crypto_skcipher_ivsize(tfm);
crypto/skcipher.c:472:	walk->alignmask = crypto_skcipher_alignmask(tfm);
crypto/skcipher.c:582:static unsigned int crypto_skcipher_extsize(struct crypto_alg *alg)
crypto/skcipher.c:593:static void skcipher_set_needkey(struct crypto_skcipher *tfm)
crypto/skcipher.c:596:		crypto_skcipher_set_flags(tfm, CRYPTO_TFM_NEED_KEY);
crypto/skcipher.c:599:static int skcipher_setkey_blkcipher(struct crypto_skcipher *tfm,
crypto/skcipher.c:602:	struct crypto_blkcipher **ctx = crypto_skcipher_ctx(tfm);
crypto/skcipher.c:607:	crypto_blkcipher_set_flags(blkcipher, crypto_skcipher_get_flags(tfm) &
crypto/skcipher.c:610:	crypto_skcipher_set_flags(tfm, crypto_blkcipher_get_flags(blkcipher) &
crypto/skcipher.c:617:	crypto_skcipher_clear_flags(tfm, CRYPTO_TFM_NEED_KEY);
crypto/skcipher.c:627:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
crypto/skcipher.c:628:	struct crypto_blkcipher **ctx = crypto_skcipher_ctx(tfm);
crypto/skcipher.c:641:	struct crypto_skcipher *skcipher = crypto_skcipher_reqtfm(req);
crypto/skcipher.c:642:	struct crypto_tfm *tfm = crypto_skcipher_tfm(skcipher);
crypto/skcipher.c:650:	struct crypto_skcipher *skcipher = crypto_skcipher_reqtfm(req);
crypto/skcipher.c:651:	struct crypto_tfm *tfm = crypto_skcipher_tfm(skcipher);
crypto/skcipher.c:667:	struct crypto_skcipher *skcipher = __crypto_skcipher_cast(tfm);
crypto/skcipher.c:698:static int skcipher_setkey_ablkcipher(struct crypto_skcipher *tfm,
crypto/skcipher.c:701:	struct crypto_ablkcipher **ctx = crypto_skcipher_ctx(tfm);
crypto/skcipher.c:707:				    crypto_skcipher_get_flags(tfm) &
crypto/skcipher.c:710:	crypto_skcipher_set_flags(tfm,
crypto/skcipher.c:718:	crypto_skcipher_clear_flags(tfm, CRYPTO_TFM_NEED_KEY);
crypto/skcipher.c:725:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
crypto/skcipher.c:726:	struct crypto_ablkcipher **ctx = crypto_skcipher_ctx(tfm);
crypto/skcipher.c:740:	struct crypto_skcipher *skcipher = crypto_skcipher_reqtfm(req);
crypto/skcipher.c:741:	struct crypto_tfm *tfm = crypto_skcipher_tfm(skcipher);
crypto/skcipher.c:749:	struct crypto_skcipher *skcipher = crypto_skcipher_reqtfm(req);
crypto/skcipher.c:750:	struct crypto_tfm *tfm = crypto_skcipher_tfm(skcipher);
crypto/skcipher.c:766:	struct crypto_skcipher *skcipher = __crypto_skcipher_cast(tfm);
crypto/skcipher.c:798:static int skcipher_setkey_unaligned(struct crypto_skcipher *tfm,
crypto/skcipher.c:801:	unsigned long alignmask = crypto_skcipher_alignmask(tfm);
crypto/skcipher.c:802:	struct skcipher_alg *cipher = crypto_skcipher_alg(tfm);
crypto/skcipher.c:819:static int skcipher_setkey(struct crypto_skcipher *tfm, const u8 *key,
crypto/skcipher.c:822:	struct skcipher_alg *cipher = crypto_skcipher_alg(tfm);
crypto/skcipher.c:823:	unsigned long alignmask = crypto_skcipher_alignmask(tfm);
crypto/skcipher.c:827:		crypto_skcipher_set_flags(tfm, CRYPTO_TFM_RES_BAD_KEY_LEN);
crypto/skcipher.c:841:	crypto_skcipher_clear_flags(tfm, CRYPTO_TFM_NEED_KEY);
crypto/skcipher.c:845:static void crypto_skcipher_exit_tfm(struct crypto_tfm *tfm)
crypto/skcipher.c:847:	struct crypto_skcipher *skcipher = __crypto_skcipher_cast(tfm);
crypto/skcipher.c:848:	struct skcipher_alg *alg = crypto_skcipher_alg(skcipher);
crypto/skcipher.c:853:static int crypto_skcipher_init_tfm(struct crypto_tfm *tfm)
crypto/skcipher.c:855:	struct crypto_skcipher *skcipher = __crypto_skcipher_cast(tfm);
crypto/skcipher.c:856:	struct skcipher_alg *alg = crypto_skcipher_alg(skcipher);
crypto/skcipher.c:873:		skcipher->base.exit = crypto_skcipher_exit_tfm;
crypto/skcipher.c:881:static void crypto_skcipher_free_instance(struct crypto_instance *inst)
crypto/skcipher.c:889:static void crypto_skcipher_show(struct seq_file *m, struct crypto_alg *alg)
crypto/skcipher.c:891:static void crypto_skcipher_show(struct seq_file *m, struct crypto_alg *alg)
crypto/skcipher.c:908:static int crypto_skcipher_report(struct sk_buff *skb, struct crypto_alg *alg)
crypto/skcipher.c:928:static int crypto_skcipher_report(struct sk_buff *skb, struct crypto_alg *alg)
crypto/skcipher.c:934:static const struct crypto_type crypto_skcipher_type2 = {
crypto/skcipher.c:935:	.extsize = crypto_skcipher_extsize,
crypto/skcipher.c:936:	.init_tfm = crypto_skcipher_init_tfm,
crypto/skcipher.c:937:	.free = crypto_skcipher_free_instance,
crypto/skcipher.c:939:	.show = crypto_skcipher_show,
crypto/skcipher.c:941:	.report = crypto_skcipher_report,
crypto/skcipher.c:945:	.tfmsize = offsetof(struct crypto_skcipher, base),
crypto/skcipher.c:948:int crypto_grab_skcipher(struct crypto_skcipher_spawn *spawn,
crypto/skcipher.c:951:	spawn->base.frontend = &crypto_skcipher_type2;
crypto/skcipher.c:956:struct crypto_skcipher *crypto_alloc_skcipher(const char *alg_name,
crypto/skcipher.c:959:	return crypto_alloc_tfm(alg_name, &crypto_skcipher_type2, type, mask);
crypto/skcipher.c:966:	struct crypto_skcipher *tfm;
crypto/skcipher.c:971:	tfm = crypto_alloc_tfm(alg_name, &crypto_skcipher_type2, type, mask);
crypto/skcipher.c:977:	if (!IS_ERR(tfm) && WARN_ON(crypto_skcipher_reqsize(tfm) >
crypto/skcipher.c:989:	return crypto_type_has_alg(alg_name, &crypto_skcipher_type2,
crypto/skcipher.c:1007:	base->cra_type = &crypto_skcipher_type2;
crypto/skcipher.c:1075:static int skcipher_setkey_simple(struct crypto_skcipher *tfm, const u8 *key,
crypto/skcipher.c:1082:	crypto_cipher_set_flags(cipher, crypto_skcipher_get_flags(tfm) &
crypto/skcipher.c:1085:	crypto_skcipher_set_flags(tfm, crypto_cipher_get_flags(cipher) &
crypto/skcipher.c:1090:static int skcipher_init_tfm_simple(struct crypto_skcipher *tfm)
crypto/skcipher.c:1094:	struct skcipher_ctx_simple *ctx = crypto_skcipher_ctx(tfm);
crypto/skcipher.c:1105:static void skcipher_exit_tfm_simple(struct crypto_skcipher *tfm)
crypto/skcipher.c:1107:	struct skcipher_ctx_simple *ctx = crypto_skcipher_ctx(tfm);
Binary file crypto/skcipher.o matches
crypto/tcrypt.c:1167:			rc[i] = crypto_skcipher_encrypt(data[i].req);
crypto/tcrypt.c:1169:			rc[i] = crypto_skcipher_decrypt(data[i].req);
crypto/tcrypt.c:1258:	struct crypto_skcipher *tfm;
crypto/tcrypt.c:1317:		get_driver_name(crypto_skcipher, tfm), e);
crypto/tcrypt.c:1343:			crypto_skcipher_clear_flags(tfm, ~0);
crypto/tcrypt.c:1345:			ret = crypto_skcipher_setkey(tfm, key, *keysize);
crypto/tcrypt.c:1348:				       crypto_skcipher_get_flags(tfm));
crypto/tcrypt.c:1352:			iv_len = crypto_skcipher_ivsize(tfm);
crypto/tcrypt.c:1394:				       crypto_skcipher_get_flags(tfm));
crypto/tcrypt.c:1433:						crypto_skcipher_encrypt(req));
crypto/tcrypt.c:1436:						crypto_skcipher_decrypt(req));
crypto/tcrypt.c:1458:						crypto_skcipher_encrypt(req));
crypto/tcrypt.c:1461:						crypto_skcipher_decrypt(req));
crypto/tcrypt.c:1474:						crypto_skcipher_encrypt(req));
crypto/tcrypt.c:1477:						crypto_skcipher_decrypt(req));
crypto/tcrypt.c:1503:	struct crypto_skcipher *tfm;
crypto/tcrypt.c:1523:			get_driver_name(crypto_skcipher, tfm), e);
crypto/tcrypt.c:1563:			crypto_skcipher_clear_flags(tfm, ~0);
crypto/tcrypt.c:1565:			ret = crypto_skcipher_setkey(tfm, key, *keysize);
crypto/tcrypt.c:1568:					crypto_skcipher_get_flags(tfm));
crypto/tcrypt.c:1592:			iv_len = crypto_skcipher_ivsize(tfm);
crypto/tcrypt.c:1609:				       crypto_skcipher_get_flags(tfm));
Binary file crypto/tcrypt.ko matches
Binary file crypto/tcrypt.o matches
crypto/testmgr.c:2153:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
crypto/testmgr.c:2154:	const unsigned int alignmask = crypto_skcipher_alignmask(tfm);
crypto/testmgr.c:2155:	const unsigned int ivsize = crypto_skcipher_ivsize(tfm);
crypto/testmgr.c:2168:		crypto_skcipher_set_flags(tfm, CRYPTO_TFM_REQ_FORBID_WEAK_KEYS);
crypto/testmgr.c:2170:		crypto_skcipher_clear_flags(tfm,
crypto/testmgr.c:2172:	err = crypto_skcipher_setkey(tfm, vec->key, vec->klen);
crypto/testmgr.c:2178:		       crypto_skcipher_get_flags(tfm));
crypto/testmgr.c:2218:	testmgr_poison(req->__ctx, crypto_skcipher_reqsize(tfm));
crypto/testmgr.c:2224:	err = enc ? crypto_skcipher_encrypt(req) : crypto_skcipher_decrypt(req);
crypto/testmgr.c:2234:	    crypto_skcipher_reqtfm(req) != tfm ||
crypto/testmgr.c:2248:		if (crypto_skcipher_reqtfm(req) != tfm)
crypto/testmgr.c:2360:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
crypto/testmgr.c:2362:	const unsigned int ivsize = crypto_skcipher_ivsize(tfm);
crypto/testmgr.c:2372:	vec->setkey_error = crypto_skcipher_setkey(tfm, vec->key, vec->klen);
crypto/testmgr.c:2391:	vec->crypt_error = crypto_wait_req(crypto_skcipher_encrypt(req), &wait);
crypto/testmgr.c:2406:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
crypto/testmgr.c:2407:	const unsigned int ivsize = crypto_skcipher_ivsize(tfm);
crypto/testmgr.c:2408:	const unsigned int blocksize = crypto_skcipher_blocksize(tfm);
crypto/testmgr.c:2410:	const char *algname = crypto_skcipher_alg(tfm)->base.cra_name;
crypto/testmgr.c:2412:	struct crypto_skcipher *generic_tfm = NULL;
crypto/testmgr.c:2466:	if (ivsize != crypto_skcipher_ivsize(generic_tfm)) {
crypto/testmgr.c:2468:		       driver, ivsize, crypto_skcipher_ivsize(generic_tfm));
crypto/testmgr.c:2473:	if (blocksize != crypto_skcipher_blocksize(generic_tfm)) {
crypto/testmgr.c:2476:		       crypto_skcipher_blocksize(generic_tfm));
crypto/testmgr.c:2551:	struct crypto_skcipher *tfm;
crypto/xts.c:30:	struct crypto_skcipher *child;
crypto/xts.c:35:	struct crypto_skcipher_spawn spawn;
crypto/xts.c:44:static int setkey(struct crypto_skcipher *parent, const u8 *key,
crypto/xts.c:47:	struct priv *ctx = crypto_skcipher_ctx(parent);
crypto/xts.c:48:	struct crypto_skcipher *child;
crypto/xts.c:65:	crypto_cipher_set_flags(tweak, crypto_skcipher_get_flags(parent) &
crypto/xts.c:68:	crypto_skcipher_set_flags(parent, crypto_cipher_get_flags(tweak) &
crypto/xts.c:75:	crypto_skcipher_clear_flags(child, CRYPTO_TFM_REQ_MASK);
crypto/xts.c:76:	crypto_skcipher_set_flags(child, crypto_skcipher_get_flags(parent) &
crypto/xts.c:78:	err = crypto_skcipher_setkey(child, key, keylen);
crypto/xts.c:79:	crypto_skcipher_set_flags(parent, crypto_skcipher_get_flags(child) &
crypto/xts.c:94:	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
crypto/xts.c:152:	struct priv *ctx = crypto_skcipher_ctx(crypto_skcipher_reqtfm(req));
crypto/xts.c:172:		crypto_skcipher_encrypt(subreq) ?:
crypto/xts.c:183:		crypto_skcipher_decrypt(subreq) ?:
crypto/xts.c:187:static int init_tfm(struct crypto_skcipher *tfm)
crypto/xts.c:191:	struct priv *ctx = crypto_skcipher_ctx(tfm);
crypto/xts.c:192:	struct crypto_skcipher *child;
crypto/xts.c:209:	crypto_skcipher_set_reqsize(tfm, crypto_skcipher_reqsize(child) +
crypto/xts.c:215:static void exit_tfm(struct crypto_skcipher *tfm)
crypto/xts.c:217:	struct priv *ctx = crypto_skcipher_ctx(tfm);
crypto/xts.c:275:	alg = crypto_skcipher_spawn_alg(&ctx->spawn);
crypto/xts.c:281:	if (crypto_skcipher_alg_ivsize(alg))
crypto/xts.c:322:	inst->alg.min_keysize = crypto_skcipher_alg_min_keysize(alg) * 2;
crypto/xts.c:323:	inst->alg.max_keysize = crypto_skcipher_alg_max_keysize(alg) * 2;
Binary file crypto/xts.o matches
 


crypto/adiantum.c:72:	struct crypto_cipher *blockcipher;
crypto/adiantum.c:163:	crypto_cipher_clear_flags(tctx->blockcipher, CRYPTO_TFM_REQ_MASK);
crypto/adiantum.c:164:	crypto_cipher_set_flags(tctx->blockcipher,
crypto/adiantum.c:167:	err = crypto_cipher_setkey(tctx->blockcipher, keyp,
crypto/adiantum.c:170:				  crypto_cipher_get_flags(tctx->blockcipher) &
crypto/adiantum.c:301:		crypto_cipher_decrypt_one(tctx->blockcipher, rctx->rbuf.bytes,
crypto/adiantum.c:361:		crypto_cipher_encrypt_one(tctx->blockcipher, rctx->rbuf.bytes,
crypto/adiantum.c:411:	struct crypto_cipher *blockcipher;
crypto/ansi_cprng.c:52:	struct crypto_cipher *tfm;
crypto/ansi_cprng.c:161:		crypto_cipher_encrypt_one(ctx->tfm, output, tmp);
crypto/ansi_cprng.c:311:	ret = crypto_cipher_setkey(ctx->tfm, prng_key, klen);
crypto/ansi_cprng.c:314:			crypto_cipher_get_flags(ctx->tfm));
Binary file crypto/ansi_cprng.ko matches
Binary file crypto/ansi_cprng.o matches
crypto/api.c:341:		len += crypto_cipher_ctxsize(alg);
Binary file crypto/api.o matches
grep: crypto/asymmetric_keys: Is a directory
grep: crypto/async_tx: Is a directory
crypto/cbc.c:25:	crypto_cipher_encrypt_one(skcipher_cipher_simple(tfm), dst, src);
crypto/cbc.c:36:	crypto_cipher_decrypt_one(skcipher_cipher_simple(tfm), dst, src);
Binary file crypto/cbc.o matches
crypto/ccm.c:60:	struct crypto_cipher *child;
crypto/ccm.c:842:	return crypto_cipher_setkey(ctx->child, inkey, keylen);
crypto/ccm.c:863:	struct crypto_cipher *tfm = tctx->child;
crypto/ccm.c:876:			crypto_cipher_encrypt_one(tfm, dg, dg);
crypto/ccm.c:889:	struct crypto_cipher *tfm = tctx->child;
crypto/ccm.c:894:		crypto_cipher_encrypt_one(tfm, dg, dg);
crypto/ccm.c:902:	struct crypto_cipher *cipher;
Binary file crypto/ccm.ko matches
Binary file crypto/ccm.o matches
crypto/cfb.c:32:	return crypto_cipher_blocksize(skcipher_cipher_simple(tfm));
crypto/cfb.c:38:	crypto_cipher_encrypt_one(skcipher_cipher_simple(tfm), dst, src);
crypto/cmac.c:34:	struct crypto_cipher *child;
crypto/cmac.c:66:	err = crypto_cipher_setkey(ctx->child, inkey, keylen);
crypto/cmac.c:72:	crypto_cipher_encrypt_one(ctx->child, (u8 *)consts, (u8 *)consts);
crypto/cmac.c:129:	struct crypto_cipher *tfm = tctx->child;
crypto/cmac.c:147:	crypto_cipher_encrypt_one(tfm, prev, prev);
crypto/cmac.c:155:		crypto_cipher_encrypt_one(tfm, prev, prev);
crypto/cmac.c:175:	struct crypto_cipher *tfm = tctx->child;
crypto/cmac.c:200:	crypto_cipher_encrypt_one(tfm, out, prev);
crypto/cmac.c:207:	struct crypto_cipher *cipher;
Binary file crypto/cmac.ko matches
Binary file crypto/cmac.o matches
crypto/ctr.c:33:				   struct crypto_cipher *tfm)
crypto/ctr.c:35:	unsigned int bsize = crypto_cipher_blocksize(tfm);
crypto/ctr.c:36:	unsigned long alignmask = crypto_cipher_alignmask(tfm);
crypto/ctr.c:44:	crypto_cipher_encrypt_one(tfm, keystream, ctrblk);
crypto/ctr.c:51:				    struct crypto_cipher *tfm)
crypto/ctr.c:54:		   crypto_cipher_alg(tfm)->cia_encrypt;
crypto/ctr.c:55:	unsigned int bsize = crypto_cipher_blocksize(tfm);
crypto/ctr.c:63:		fn(crypto_cipher_tfm(tfm), dst, ctrblk);
crypto/ctr.c:77:				    struct crypto_cipher *tfm)
crypto/ctr.c:80:		   crypto_cipher_alg(tfm)->cia_encrypt;
crypto/ctr.c:81:	unsigned int bsize = crypto_cipher_blocksize(tfm);
crypto/ctr.c:82:	unsigned long alignmask = crypto_cipher_alignmask(tfm);
crypto/ctr.c:91:		fn(crypto_cipher_tfm(tfm), keystream, ctrblk);
crypto/ctr.c:106:	struct crypto_cipher *cipher = skcipher_cipher_simple(tfm);
crypto/ctr.c:107:	const unsigned int bsize = crypto_cipher_blocksize(cipher);
Binary file crypto/ctr.o matches
crypto/drbg.c:1630:	struct crypto_cipher *tfm =
crypto/drbg.c:1631:		(struct crypto_cipher *)drbg->priv_data;
crypto/drbg.c:1652:	struct crypto_cipher *tfm;
crypto/drbg.c:1664:	BUG_ON(drbg_blocklen(drbg) != crypto_cipher_blocksize(tfm));
crypto/drbg.c:1712:	struct crypto_cipher *tfm =
crypto/drbg.c:1713:		(struct crypto_cipher *)drbg->priv_data;
crypto/drbg.c:1715:	crypto_cipher_setkey(tfm, key, (drbg_keylen(drbg)));
crypto/drbg.c:1721:	struct crypto_cipher *tfm =
crypto/drbg.c:1722:		(struct crypto_cipher *)drbg->priv_data;
crypto/drbg.c:1726:	crypto_cipher_encrypt_one(tfm, outval, in->buf);
Binary file crypto/drbg.o matches
crypto/ecb.c:21:			    struct crypto_cipher *cipher,
crypto/ecb.c:24:	const unsigned int bsize = crypto_cipher_blocksize(cipher);
crypto/ecb.c:36:			fn(crypto_cipher_tfm(cipher), dst, src);
crypto/ecb.c:51:	struct crypto_cipher *cipher = skcipher_cipher_simple(tfm);
crypto/ecb.c:54:				crypto_cipher_alg(cipher)->cia_encrypt);
crypto/ecb.c:60:	struct crypto_cipher *cipher = skcipher_cipher_simple(tfm);
crypto/ecb.c:63:				crypto_cipher_alg(cipher)->cia_decrypt);
Binary file crypto/ecb.o matches
crypto/internal.h:53:static inline unsigned int crypto_cipher_ctxsize(struct crypto_alg *alg)
crypto/keywrap.c:126:	struct crypto_cipher *cipher = skcipher_cipher_simple(tfm);
crypto/keywrap.c:166:			crypto_cipher_decrypt_one(cipher, (u8 *)&block,
crypto/keywrap.c:195:	struct crypto_cipher *cipher = skcipher_cipher_simple(tfm);
crypto/keywrap.c:237:			crypto_cipher_encrypt_one(cipher, (u8 *)&block,
Binary file crypto/keywrap.ko matches
Binary file crypto/keywrap.o matches
crypto/ofb.c:20:	struct crypto_cipher *cipher = skcipher_cipher_simple(tfm);
crypto/ofb.c:21:	const unsigned int bsize = crypto_cipher_blocksize(cipher);
crypto/ofb.c:34:			crypto_cipher_encrypt_one(cipher, iv, iv);
crypto/ofb.c:44:		crypto_cipher_encrypt_one(cipher, walk.iv, walk.iv);
crypto/pcbc.c:26:				       struct crypto_cipher *tfm)
crypto/pcbc.c:28:	int bsize = crypto_cipher_blocksize(tfm);
crypto/pcbc.c:36:		crypto_cipher_encrypt_one(tfm, dst, iv);
crypto/pcbc.c:48:				       struct crypto_cipher *tfm)
crypto/pcbc.c:50:	int bsize = crypto_cipher_blocksize(tfm);
crypto/pcbc.c:59:		crypto_cipher_encrypt_one(tfm, src, iv);
crypto/pcbc.c:71:	struct crypto_cipher *cipher = skcipher_cipher_simple(tfm);
crypto/pcbc.c:93:				       struct crypto_cipher *tfm)
crypto/pcbc.c:95:	int bsize = crypto_cipher_blocksize(tfm);
crypto/pcbc.c:102:		crypto_cipher_decrypt_one(tfm, dst, src);
crypto/pcbc.c:115:				       struct crypto_cipher *tfm)
crypto/pcbc.c:117:	int bsize = crypto_cipher_blocksize(tfm);
crypto/pcbc.c:125:		crypto_cipher_decrypt_one(tfm, src, src);
crypto/pcbc.c:138:	struct crypto_cipher *cipher = skcipher_cipher_simple(tfm);
Binary file crypto/pcbc.ko matches
Binary file crypto/pcbc.o matches
crypto/skcipher.c:1078:	struct crypto_cipher *cipher = skcipher_cipher_simple(tfm);
crypto/skcipher.c:1081:	crypto_cipher_clear_flags(cipher, CRYPTO_TFM_REQ_MASK);
crypto/skcipher.c:1082:	crypto_cipher_set_flags(cipher, crypto_skcipher_get_flags(tfm) &
crypto/skcipher.c:1084:	err = crypto_cipher_setkey(cipher, key, keylen);
crypto/skcipher.c:1085:	crypto_skcipher_set_flags(tfm, crypto_cipher_get_flags(cipher) &
crypto/skcipher.c:1095:	struct crypto_cipher *cipher;
Binary file crypto/skcipher.o matches
crypto/testmgr.c:2059:static int test_cipher(struct crypto_cipher *tfm, int enc,
crypto/testmgr.c:2063:	const char *algo = crypto_tfm_alg_driver_name(crypto_cipher_tfm(tfm));
crypto/testmgr.c:2097:		crypto_cipher_clear_flags(tfm, ~0);
crypto/testmgr.c:2099:			crypto_cipher_set_flags(tfm, CRYPTO_TFM_REQ_FORBID_WEAK_KEYS);
crypto/testmgr.c:2101:		ret = crypto_cipher_setkey(tfm, template[i].key,
crypto/testmgr.c:2108:			       crypto_cipher_get_flags(tfm));
crypto/testmgr.c:2119:		     k += crypto_cipher_blocksize(tfm)) {
crypto/testmgr.c:2121:				crypto_cipher_encrypt_one(tfm, data + k,
crypto/testmgr.c:2124:				crypto_cipher_decrypt_one(tfm, data + k,
crypto/testmgr.c:2942:	struct crypto_cipher *tfm;
crypto/vmac.c:52:	struct crypto_cipher *cipher;
crypto/vmac.c:443:	err = crypto_cipher_setkey(tctx->cipher, key, keylen);
crypto/vmac.c:450:		crypto_cipher_encrypt_one(tctx->cipher, (u8 *)out, in);
crypto/vmac.c:460:		crypto_cipher_encrypt_one(tctx->cipher, (u8 *)out, in);
crypto/vmac.c:471:			crypto_cipher_encrypt_one(tctx->cipher, (u8 *)out, in);
crypto/vmac.c:589:	crypto_cipher_encrypt_one(tctx->cipher, dctx->nonce.bytes,
crypto/vmac.c:603:	struct crypto_cipher *cipher;
Binary file crypto/vmac.ko matches
Binary file crypto/vmac.o matches
crypto/xcbc.c:40:	struct crypto_cipher *child;
crypto/xcbc.c:72:	if ((err = crypto_cipher_setkey(ctx->child, inkey, keylen)))
crypto/xcbc.c:75:	crypto_cipher_encrypt_one(ctx->child, consts, (u8 *)ks + bs);
crypto/xcbc.c:76:	crypto_cipher_encrypt_one(ctx->child, consts + bs, (u8 *)ks + bs * 2);
crypto/xcbc.c:77:	crypto_cipher_encrypt_one(ctx->child, key1, (u8 *)ks);
crypto/xcbc.c:79:	return crypto_cipher_setkey(ctx->child, key1, bs);
crypto/xcbc.c:103:	struct crypto_cipher *tfm = tctx->child;
crypto/xcbc.c:121:	crypto_cipher_encrypt_one(tfm, prev, prev);
crypto/xcbc.c:129:		crypto_cipher_encrypt_one(tfm, prev, prev);
crypto/xcbc.c:149:	struct crypto_cipher *tfm = tctx->child;
crypto/xcbc.c:173:	crypto_cipher_encrypt_one(tfm, out, prev);
crypto/xcbc.c:180:	struct crypto_cipher *cipher;
Binary file crypto/xcbc.ko matches
Binary file crypto/xcbc.o matches
crypto/xts.c:31:	struct crypto_cipher *tweak;
crypto/xts.c:49:	struct crypto_cipher *tweak;
crypto/xts.c:64:	crypto_cipher_clear_flags(tweak, CRYPTO_TFM_REQ_MASK);
crypto/xts.c:65:	crypto_cipher_set_flags(tweak, crypto_skcipher_get_flags(parent) &
crypto/xts.c:67:	err = crypto_cipher_setkey(tweak, key + keylen, keylen);
crypto/xts.c:68:	crypto_skcipher_set_flags(parent, crypto_cipher_get_flags(tweak) &
crypto/xts.c:162:	crypto_cipher_encrypt_one(ctx->tweak, (u8 *)&rctx->t, req->iv);
crypto/xts.c:193:	struct crypto_cipher *tweak;
Binary file crypto/xts.o matches
 

crypto/ablkcipher.c:300:static int setkey_unaligned(struct crypto_ablkcipher *tfm, const u8 *key,
crypto/ablkcipher.c:303:	struct ablkcipher_alg *cipher = crypto_ablkcipher_alg(tfm);
crypto/ablkcipher.c:304:	unsigned long alignmask = crypto_ablkcipher_alignmask(tfm);
crypto/ablkcipher.c:322:static int setkey(struct crypto_ablkcipher *tfm, const u8 *key,
crypto/ablkcipher.c:325:	struct ablkcipher_alg *cipher = crypto_ablkcipher_alg(tfm);
crypto/ablkcipher.c:326:	unsigned long alignmask = crypto_ablkcipher_alignmask(tfm);
crypto/ablkcipher.c:329:		crypto_ablkcipher_set_flags(tfm, CRYPTO_TFM_RES_BAD_KEY_LEN);
crypto/ablkcipher.c:339:static unsigned int crypto_ablkcipher_ctxsize(struct crypto_alg *alg, u32 type,
crypto/ablkcipher.c:357:	crt->base = __crypto_ablkcipher_cast(tfm);
crypto/ablkcipher.c:364:static int crypto_ablkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)
crypto/ablkcipher.c:382:static int crypto_ablkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)
crypto/ablkcipher.c:388:static void crypto_ablkcipher_show(struct seq_file *m, struct crypto_alg *alg)
crypto/ablkcipher.c:390:static void crypto_ablkcipher_show(struct seq_file *m, struct crypto_alg *alg)
crypto/ablkcipher.c:404:const struct crypto_type crypto_ablkcipher_type = {
crypto/ablkcipher.c:405:	.ctxsize = crypto_ablkcipher_ctxsize,
crypto/ablkcipher.c:408:	.show = crypto_ablkcipher_show,
crypto/ablkcipher.c:410:	.report = crypto_ablkcipher_report,
crypto/ablkcipher.c:412:EXPORT_SYMBOL_GPL(crypto_ablkcipher_type);

crypto/blkcipher.c:411:static int async_setkey(struct crypto_ablkcipher *tfm, const u8 *key,
crypto/blkcipher.c:414:	return setkey(crypto_ablkcipher_tfm(tfm), key, keylen);
crypto/blkcipher.c:467:	crt->base = __crypto_ablkcipher_cast(tfm);

crypto/skcipher.c:587:	if (alg->cra_type == &crypto_ablkcipher_type)
crypto/skcipher.c:588:		return sizeof(struct crypto_ablkcipher *);
crypto/skcipher.c:701:	struct crypto_ablkcipher **ctx = crypto_skcipher_ctx(tfm);
crypto/skcipher.c:702:	struct crypto_ablkcipher *ablkcipher = *ctx;
crypto/skcipher.c:705:	crypto_ablkcipher_clear_flags(ablkcipher, ~0);
crypto/skcipher.c:706:	crypto_ablkcipher_set_flags(ablkcipher,
crypto/skcipher.c:709:	err = crypto_ablkcipher_setkey(ablkcipher, key, keylen);
crypto/skcipher.c:711:				  
crypto_ablkcipher_get_flags(ablkcipher) &
crypto/skcipher.c:726:	struct crypto_ablkcipher **ctx = crypto_skcipher_ctx(tfm);
crypto/skcipher.c:758:	struct crypto_ablkcipher **ctx = crypto_tfm_ctx(tfm);
crypto/skcipher.c:767:	struct crypto_ablkcipher **ctx = crypto_tfm_ctx(tfm);
crypto/skcipher.c:768:	struct crypto_ablkcipher *ablkcipher;
crypto/skcipher.c:780:	ablkcipher = __crypto_ablkcipher_cast(abtfm);
crypto/skcipher.c:788:	skcipher->ivsize = crypto_ablkcipher_ivsize(ablkcipher);
crypto/skcipher.c:789:	skcipher->reqsize = crypto_ablkcipher_reqsize(ablkcipher) +
crypto/skcipher.c:861:	if (tfm->__crt_alg->cra_type == &crypto_ablkcipher_type)

 



Binary file crypto/842.ko matches
Binary file crypto/842.o matches
crypto/ablkcipher.c:300:static int setkey_unaligned(struct crypto_ablkcipher *tfm, const u8 *key,
crypto/ablkcipher.c:303:	struct ablkcipher_alg *cipher = crypto_ablkcipher_alg(tfm);
crypto/ablkcipher.c:304:	unsigned long alignmask = crypto_ablkcipher_alignmask(tfm);
crypto/ablkcipher.c:322:static int setkey(struct crypto_ablkcipher *tfm, const u8 *key,
crypto/ablkcipher.c:325:	struct ablkcipher_alg *cipher = crypto_ablkcipher_alg(tfm);
crypto/ablkcipher.c:326:	unsigned long alignmask = crypto_ablkcipher_alignmask(tfm);
crypto/ablkcipher.c:329:		crypto_ablkcipher_set_flags(tfm, CRYPTO_TFM_RES_BAD_KEY_LEN);
crypto/ablkcipher.c:339:static unsigned int crypto_ablkcipher_ctxsize(struct crypto_alg *alg, u32 type,
crypto/ablkcipher.c:357:	crt->base = __crypto_ablkcipher_cast(tfm);
crypto/ablkcipher.c:364:static int crypto_ablkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)
crypto/ablkcipher.c:382:static int crypto_ablkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)
crypto/ablkcipher.c:388:static void crypto_ablkcipher_show(struct seq_file *m, struct crypto_alg *alg)
crypto/ablkcipher.c:390:static void crypto_ablkcipher_show(struct seq_file *m, struct crypto_alg *alg)
crypto/ablkcipher.c:404:const struct crypto_type crypto_ablkcipher_type = {
crypto/ablkcipher.c:405:	.ctxsize = crypto_ablkcipher_ctxsize,
crypto/ablkcipher.c:408:	.show = crypto_ablkcipher_show,
crypto/ablkcipher.c:410:	.report = crypto_ablkcipher_report,
crypto/ablkcipher.c:412:EXPORT_SYMBOL_GPL(crypto_ablkcipher_type);

crypto/blkcipher.c:411:static int async_setkey(struct crypto_ablkcipher *tfm, const u8 *key,
crypto/blkcipher.c:414:	return setkey(crypto_ablkcipher_tfm(tfm), key, keylen);
crypto/blkcipher.c:467:	crt->base = __crypto_ablkcipher_cast(tfm);
crypto/skcipher.c:587:	if (alg->cra_type == &crypto_ablkcipher_type)
crypto/skcipher.c:588:		return sizeof(struct crypto_ablkcipher *);
crypto/skcipher.c:701:	struct crypto_ablkcipher **ctx = crypto_skcipher_ctx(tfm);
crypto/skcipher.c:702:	struct crypto_ablkcipher *ablkcipher = *ctx;
crypto/skcipher.c:705:	crypto_ablkcipher_clear_flags(ablkcipher, ~0);
crypto/skcipher.c:706:	crypto_ablkcipher_set_flags(ablkcipher,
crypto/skcipher.c:709:	err = crypto_ablkcipher_setkey(ablkcipher, key, keylen);
crypto/skcipher.c:711:				  crypto_ablkcipher_get_flags(ablkcipher) &
crypto/skcipher.c:726:	struct crypto_ablkcipher **ctx = crypto_skcipher_ctx(tfm);
crypto/skcipher.c:758:	struct crypto_ablkcipher **ctx = crypto_tfm_ctx(tfm);
crypto/skcipher.c:767:	struct crypto_ablkcipher **ctx = crypto_tfm_ctx(tfm);
crypto/skcipher.c:768:	struct crypto_ablkcipher *ablkcipher;
crypto/skcipher.c:780:	ablkcipher = __crypto_ablkcipher_cast(abtfm);
crypto/skcipher.c:788:	skcipher->ivsize = crypto_ablkcipher_ivsize(ablkcipher);
crypto/skcipher.c:789:	skcipher->reqsize = crypto_ablkcipher_reqsize(ablkcipher) +
crypto/skcipher.c:861:	if (tfm->__crt_alg->cra_type == &crypto_ablkcipher_type)

crypto/blkcipher.c:301:	walk->walk_blocksize = crypto_blkcipher_blocksize(desc->tfm);
crypto/blkcipher.c:303:	walk->ivsize = crypto_blkcipher_ivsize(desc->tfm);
crypto/blkcipher.c:304:	walk->alignmask = crypto_blkcipher_alignmask(desc->tfm);
crypto/blkcipher.c:313:	walk->walk_blocksize = crypto_blkcipher_blocksize(desc->tfm);
crypto/blkcipher.c:315:	walk->ivsize = crypto_blkcipher_ivsize(desc->tfm);
crypto/blkcipher.c:316:	walk->alignmask = crypto_blkcipher_alignmask(desc->tfm);
crypto/blkcipher.c:352:	walk->cipher_blocksize = crypto_blkcipher_blocksize(desc->tfm);
crypto/blkcipher.c:353:	walk->ivsize = crypto_blkcipher_ivsize(desc->tfm);
crypto/blkcipher.c:354:	walk->alignmask = crypto_blkcipher_alignmask(desc->tfm);
crypto/blkcipher.c:422:		.tfm = __crypto_blkcipher_cast(tfm),
crypto/blkcipher.c:436:		.tfm = __crypto_blkcipher_cast(tfm),
crypto/blkcipher.c:444:static unsigned int crypto_blkcipher_ctxsize(struct crypto_alg *alg, u32 type,
crypto/blkcipher.c:506:static int crypto_blkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)
crypto/blkcipher.c:524:static int crypto_blkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)
crypto/blkcipher.c:530:static void crypto_blkcipher_show(struct seq_file *m, struct crypto_alg *alg)
crypto/blkcipher.c:532:static void crypto_blkcipher_show(struct seq_file *m, struct crypto_alg *alg)
crypto/blkcipher.c:542:const struct crypto_type crypto_blkcipher_type = {
crypto/blkcipher.c:543:	.ctxsize = crypto_blkcipher_ctxsize,
crypto/blkcipher.c:546:	.show = crypto_blkcipher_show,
crypto/blkcipher.c:548:	.report = crypto_blkcipher_report,
crypto/blkcipher.c:550:EXPORT_SYMBOL_GPL(crypto_blkcipher_type);
s
crypto/Makefile:20:crypto_blkcipher-y := ablkcipher.o
crypto/Makefile:21:crypto_blkcipher-y += blkcipher.o
crypto/Makefile:22:crypto_blkcipher-y += skcipher.o
crypto/Makefile:23:obj-$(CONFIG_CRYPTO_BLKCIPHER2) += crypto_blkcipher.o
crypto/modules.builtin:5:kernel/crypto/crypto_blkcipher.ko

crypto/skcipher.c:584:	if (alg->cra_type == &crypto_blkcipher_type)
crypto/skcipher.c:585:		return sizeof(struct crypto_blkcipher *);
crypto/skcipher.c:602:	struct crypto_blkcipher **ctx = crypto_skcipher_ctx(tfm);
crypto/skcipher.c:603:	struct crypto_blkcipher *blkcipher = *ctx;
crypto/skcipher.c:606:	crypto_blkcipher_clear_flags(blkcipher, ~0);
crypto/skcipher.c:607:	crypto_blkcipher_set_flags(blkcipher, crypto_skcipher_get_flags(tfm) &
crypto/skcipher.c:609:	err = crypto_blkcipher_setkey(blkcipher, key, keylen);
crypto/skcipher.c:610:	crypto_skcipher_set_flags(tfm, crypto_blkcipher_get_flags(blkcipher) &
crypto/skcipher.c:628:	struct crypto_blkcipher **ctx = crypto_skcipher_ctx(tfm);
crypto/skcipher.c:659:	struct crypto_blkcipher **ctx = crypto_tfm_ctx(tfm);
crypto/skcipher.c:668:	struct crypto_blkcipher **ctx = crypto_tfm_ctx(tfm);
crypto/skcipher.c:669:	struct crypto_blkcipher *blkcipher;
crypto/skcipher.c:682:	blkcipher = __crypto_blkcipher_cast(btfm);
crypto/skcipher.c:690:	skcipher->ivsize = crypto_blkcipher_ivsize(blkcipher);
crypto/skcipher.c:858:	if (tfm->__crt_alg->cra_type == &crypto_blkcipher_type)
Binary file crypto/skcipher.o matches
Binary file crypto/sm3_generic.ko matches
Binary file crypto/sm3_generic.o matches
Binary file crypto/tcrypt.ko matches
Binary file crypto/tcrypt.o matches
Binary file crypto/tea.ko matches
Binary file crypto/tea.o matches
Binary file crypto/testmgr.o matches
Binary file crypto/tgr192.ko matches
Binary file crypto/tgr192.o matches
Binary file crypto/twofish_common.ko matches
Binary file crypto/twofish_common.o matches
Binary file crypto/twofish_generic.ko matches
Binary file crypto/twofish_generic.o matches
Binary file crypto/vmac.ko matches
Binary file crypto/vmac.o matches
Binary file crypto/wp512.ko matches
Binary file crypto/wp512.o matches
Binary file crypto/xcbc.ko matches
Binary file crypto/xcbc.o matches
Binary file crypto/xts.o matches
root@armorer:/home/armorer/drm-misc# grep  -n 'crypto_aead*' crypto/* 
crypto/aead.c:32:static int setkey_unaligned(struct crypto_aead *tfm, const u8 *key,
crypto/aead.c:35:	unsigned long alignmask = crypto_aead_alignmask(tfm);
crypto/aead.c:47:	ret = crypto_aead_alg(tfm)->setkey(tfm, alignbuffer, keylen);
crypto/aead.c:53:int crypto_aead_setkey(struct crypto_aead *tfm,
crypto/aead.c:56:	unsigned long alignmask = crypto_aead_alignmask(tfm);
crypto/aead.c:62:		err = crypto_aead_alg(tfm)->setkey(tfm, key, keylen);
crypto/aead.c:65:		crypto_aead_set_flags(tfm, CRYPTO_TFM_NEED_KEY);
crypto/aead.c:69:	crypto_aead_clear_flags(tfm, CRYPTO_TFM_NEED_KEY);
crypto/aead.c:72:EXPORT_SYMBOL_GPL(crypto_aead_setkey);
crypto/aead.c:74:int crypto_aead_setauthsize(struct crypto_aead *tfm, unsigned int authsize)
crypto/aead.c:78:	if (authsize > crypto_aead_maxauthsize(tfm))
crypto/aead.c:81:	if (crypto_aead_alg(tfm)->setauthsize) {
crypto/aead.c:82:		err = crypto_aead_alg(tfm)->setauthsize(tfm, authsize);
crypto/aead.c:90:EXPORT_SYMBOL_GPL(crypto_aead_setauthsize);
crypto/aead.c:92:static void crypto_aead_exit_tfm(struct crypto_tfm *tfm)
crypto/aead.c:94:	struct crypto_aead *aead = __crypto_aead_cast(tfm);
crypto/aead.c:95:	struct aead_alg *alg = crypto_aead_alg(aead);
crypto/aead.c:100:static int crypto_aead_init_tfm(struct crypto_tfm *tfm)
crypto/aead.c:102:	struct crypto_aead *aead = __crypto_aead_cast(tfm);
crypto/aead.c:103:	struct aead_alg *alg = crypto_aead_alg(aead);
crypto/aead.c:105:	crypto_aead_set_flags(aead, CRYPTO_TFM_NEED_KEY);
crypto/aead.c:110:		aead->base.exit = crypto_aead_exit_tfm;
crypto/aead.c:119:static int crypto_aead_report(struct sk_buff *skb, struct crypto_alg *alg)
crypto/aead.c:136:static int crypto_aead_report(struct sk_buff *skb, struct crypto_alg *alg)
crypto/aead.c:142:static void crypto_aead_show(struct seq_file *m, struct crypto_alg *alg)
crypto/aead.c:144:static void crypto_aead_show(struct seq_file *m, struct crypto_alg *alg)
crypto/aead.c:157:static void crypto_aead_free_instance(struct crypto_instance *inst)
crypto/aead.c:169:static const struct crypto_type crypto_aead_type = {
crypto/aead.c:171:	.init_tfm = crypto_aead_init_tfm,
crypto/aead.c:172:	.free = crypto_aead_free_instance,
crypto/aead.c:174:	.show = crypto_aead_show,
crypto/aead.c:176:	.report = crypto_aead_report,
crypto/aead.c:180:	.tfmsize = offsetof(struct crypto_aead, base),
crypto/aead.c:183:static int aead_geniv_setkey(struct crypto_aead *tfm,
crypto/aead.c:186:	struct aead_geniv_ctx *ctx = crypto_aead_ctx(tfm);
crypto/aead.c:188:	return crypto_aead_setkey(ctx->child, key, keylen);
crypto/aead.c:191:static int aead_geniv_setauthsize(struct crypto_aead *tfm,
crypto/aead.c:194:	struct aead_geniv_ctx *ctx = crypto_aead_ctx(tfm);
crypto/aead.c:196:	return crypto_aead_setauthsize(ctx->child, authsize);
crypto/aead.c:203:	struct crypto_aead_spawn *spawn;
crypto/aead.c:238:	ivsize = crypto_aead_alg_ivsize(alg);
crypto/aead.c:239:	maxauthsize = crypto_aead_alg_maxauthsize(alg);
crypto/aead.c:286:int aead_init_geniv(struct crypto_aead *aead)
crypto/aead.c:288:	struct aead_geniv_ctx *ctx = crypto_aead_ctx(aead);
crypto/aead.c:290:	struct crypto_aead *child;
crypto/aead.c:300:				   crypto_aead_ivsize(aead));
crypto/aead.c:316:	crypto_aead_set_reqsize(aead, crypto_aead_reqsize(child) +
crypto/aead.c:330:void aead_exit_geniv(struct crypto_aead *tfm)
crypto/aead.c:332:	struct aead_geniv_ctx *ctx = crypto_aead_ctx(tfm);
crypto/aead.c:339:int crypto_grab_aead(struct crypto_aead_spawn *spawn, const char *name,
crypto/aead.c:342:	spawn->base.frontend = &crypto_aead_type;
crypto/aead.c:347:struct crypto_aead *crypto_alloc_aead(const char *alg_name, u32 type, u32 mask)
crypto/aead.c:349:	return crypto_alloc_tfm(alg_name, &crypto_aead_type, type, mask);
crypto/aead.c:364:	base->cra_type = &crypto_aead_type;
Binary file crypto/aead.o matches
crypto/aegis128.c:327:static int crypto_aegis128_setkey(struct crypto_aead *aead, const u8 *key,
crypto/aegis128.c:330:	struct aegis_ctx *ctx = crypto_aead_ctx(aead);
crypto/aegis128.c:333:		crypto_aead_set_flags(aead, CRYPTO_TFM_RES_BAD_KEY_LEN);
crypto/aegis128.c:341:static int crypto_aegis128_setauthsize(struct crypto_aead *tfm,
crypto/aegis128.c:356:	struct crypto_aead *tfm = crypto_aead_reqtfm(req);
crypto/aegis128.c:357:	struct aegis_ctx *ctx = crypto_aead_ctx(tfm);
crypto/aegis128.c:373:	struct crypto_aead *tfm = crypto_aead_reqtfm(req);
crypto/aegis128.c:375:	unsigned int authsize = crypto_aead_authsize(tfm);
crypto/aegis128.c:393:	struct crypto_aead *tfm = crypto_aead_reqtfm(req);
crypto/aegis128.c:395:	unsigned int authsize = crypto_aead_authsize(tfm);
crypto/aegis128.c:406:static int crypto_aegis128_init_tfm(struct crypto_aead *tfm)
crypto/aegis128.c:411:static void crypto_aegis128_exit_tfm(struct crypto_aead *tfm)
crypto/aegis128l.c:391:static int crypto_aegis128l_setkey(struct crypto_aead *aead, const u8 *key,
crypto/aegis128l.c:394:	struct aegis_ctx *ctx = crypto_aead_ctx(aead);
crypto/aegis128l.c:397:		crypto_aead_set_flags(aead, CRYPTO_TFM_RES_BAD_KEY_LEN);
crypto/aegis128l.c:405:static int crypto_aegis128l_setauthsize(struct crypto_aead *tfm,
crypto/aegis128l.c:420:	struct crypto_aead *tfm = crypto_aead_reqtfm(req);
crypto/aegis128l.c:421:	struct aegis_ctx *ctx = crypto_aead_ctx(tfm);
crypto/aegis128l.c:437:	struct crypto_aead *tfm = crypto_aead_reqtfm(req);
crypto/aegis128l.c:439:	unsigned int authsize = crypto_aead_authsize(tfm);
crypto/aegis128l.c:457:	struct crypto_aead *tfm = crypto_aead_reqtfm(req);
crypto/aegis128l.c:459:	unsigned int authsize = crypto_aead_authsize(tfm);
crypto/aegis128l.c:470:static int crypto_aegis128l_init_tfm(struct crypto_aead *tfm)
crypto/aegis128l.c:475:static void crypto_aegis128l_exit_tfm(struct crypto_aead *tfm)
crypto/aegis256.c:340:static int crypto_aegis256_setkey(struct crypto_aead *aead, const u8 *key,
crypto/aegis256.c:343:	struct aegis_ctx *ctx = crypto_aead_ctx(aead);
crypto/aegis256.c:346:		crypto_aead_set_flags(aead, CRYPTO_TFM_RES_BAD_KEY_LEN);
crypto/aegis256.c:356:static int crypto_aegis256_setauthsize(struct crypto_aead *tfm,
crypto/aegis256.c:371:	struct crypto_aead *tfm = crypto_aead_reqtfm(req);
crypto/aegis256.c:372:	struct aegis_ctx *ctx = crypto_aead_ctx(tfm);
crypto/aegis256.c:388:	struct crypto_aead *tfm = crypto_aead_reqtfm(req);
crypto/aegis256.c:390:	unsigned int authsize = crypto_aead_authsize(tfm);
crypto/aegis256.c:408:	struct crypto_aead *tfm = crypto_aead_reqtfm(req);
crypto/aegis256.c:410:	unsigned int authsize = crypto_aead_authsize(tfm);
crypto/aegis256.c:421:static int crypto_aegis256_init_tfm(struct crypto_aead *tfm)
crypto/aegis256.c:426:static void crypto_aegis256_exit_tfm(struct crypto_aead *tfm)
crypto/algif_aead.c:44:	struct crypto_aead *aead;
crypto/algif_aead.c:55:	struct crypto_aead *tfm = aeadc->aead;
crypto/algif_aead.c:56:	unsigned int as = crypto_aead_authsize(tfm);
crypto/algif_aead.c:72:	struct crypto_aead *tfm = aeadc->aead;
crypto/algif_aead.c:73:	unsigned int ivsize = crypto_aead_ivsize(tfm);
crypto/algif_aead.c:78:static int crypto_aead_copy_sgl(struct crypto_sync_skcipher *null_tfm,
crypto/algif_aead.c:101:	struct crypto_aead *tfm = aeadc->aead;
crypto/algif_aead.c:103:	unsigned int i, as = crypto_aead_authsize(tfm);
crypto/algif_aead.c:158:				     crypto_aead_reqsize(tfm));
crypto/algif_aead.c:230:		err = crypto_aead_copy_sgl(null_tfm, tsgl_src,
crypto/algif_aead.c:248:		err = crypto_aead_copy_sgl(null_tfm, tsgl_src,
crypto/algif_aead.c:300:		err = ctx->enc ? crypto_aead_encrypt(&areq->cra_u.aead_req) :
crypto/algif_aead.c:301:				 crypto_aead_decrypt(&areq->cra_u.aead_req);
crypto/algif_aead.c:314:				crypto_aead_encrypt(&areq->cra_u.aead_req) :
crypto/algif_aead.c:315:				crypto_aead_decrypt(&areq->cra_u.aead_req),
crypto/algif_aead.c:400:	if (crypto_aead_get_flags(tfm->aead) & CRYPTO_TFM_NEED_KEY)
crypto/algif_aead.c:480:	struct crypto_aead *aead;
crypto/algif_aead.c:519:	return crypto_aead_setauthsize(tfm->aead, authsize);
crypto/algif_aead.c:526:	return crypto_aead_setkey(tfm->aead, key, keylen);
crypto/algif_aead.c:536:	struct crypto_aead *tfm = aeadc->aead;
crypto/algif_aead.c:537:	unsigned int ivlen = crypto_aead_ivsize(tfm);
crypto/algif_aead.c:550:	struct crypto_aead *aead = tfm->aead;
crypto/algif_aead.c:552:	unsigned int ivlen = crypto_aead_ivsize(aead);
crypto/algif_aead.c:587:	if (crypto_aead_get_flags(tfm->aead) & CRYPTO_TFM_NEED_KEY)
Binary file crypto/algif_aead.ko matches
Binary file crypto/algif_aead.o matches
grep: crypto/asymmetric_keys: Is a directory
grep: crypto/async_tx: Is a directory
crypto/authenc.c:89:static int crypto_authenc_setkey(struct crypto_aead *authenc, const u8 *key,
crypto/authenc.c:92:	struct crypto_authenc_ctx *ctx = crypto_aead_ctx(authenc);
crypto/authenc.c:102:	crypto_ahash_set_flags(auth, crypto_aead_get_flags(authenc) &
crypto/authenc.c:105:	crypto_aead_set_flags(authenc, crypto_ahash_get_flags(auth) &
crypto/authenc.c:112:	crypto_skcipher_set_flags(enc, crypto_aead_get_flags(authenc) &
crypto/authenc.c:115:	crypto_aead_set_flags(authenc, crypto_skcipher_get_flags(enc) &
crypto/authenc.c:123:	crypto_aead_set_flags(authenc, CRYPTO_TFM_RES_BAD_KEY_LEN);
crypto/authenc.c:130:	struct crypto_aead *authenc = crypto_aead_reqtfm(req);
crypto/authenc.c:141:				 crypto_aead_authsize(authenc), 1);
crypto/authenc.c:149:	struct crypto_aead *authenc = crypto_aead_reqtfm(req);
crypto/authenc.c:151:	struct crypto_authenc_ctx *ctx = crypto_aead_ctx(authenc);
crypto/authenc.c:173:				 crypto_aead_authsize(authenc), 1);
crypto/authenc.c:194:	struct crypto_aead *authenc = crypto_aead_reqtfm(req);
crypto/authenc.c:195:	struct crypto_authenc_ctx *ctx = crypto_aead_ctx(authenc);
crypto/authenc.c:209:	struct crypto_aead *authenc = crypto_aead_reqtfm(req);
crypto/authenc.c:211:	struct crypto_authenc_ctx *ctx = crypto_aead_ctx(authenc);
crypto/authenc.c:247:	struct crypto_aead *authenc = crypto_aead_reqtfm(req);
crypto/authenc.c:249:	struct crypto_authenc_ctx *ctx = crypto_aead_ctx(authenc);
crypto/authenc.c:255:	unsigned int authsize = crypto_aead_authsize(authenc);
crypto/authenc.c:295:	struct crypto_aead *authenc = crypto_aead_reqtfm(req);
crypto/authenc.c:296:	unsigned int authsize = crypto_aead_authsize(authenc);
crypto/authenc.c:298:	struct crypto_authenc_ctx *ctx = crypto_aead_ctx(authenc);
crypto/authenc.c:322:static int crypto_authenc_init_tfm(struct crypto_aead *tfm)
crypto/authenc.c:326:	struct crypto_authenc_ctx *ctx = crypto_aead_ctx(tfm);
crypto/authenc.c:350:	crypto_aead_set_reqsize(
crypto/authenc.c:369:static void crypto_authenc_exit_tfm(struct crypto_aead *tfm)
crypto/authenc.c:371:	struct crypto_authenc_ctx *ctx = crypto_aead_ctx(tfm);
crypto/authencesn.c:54:static int crypto_authenc_esn_setauthsize(struct crypto_aead *authenc_esn,
crypto/authencesn.c:63:static int crypto_authenc_esn_setkey(struct crypto_aead *authenc_esn, const u8 *key,
crypto/authencesn.c:66:	struct crypto_authenc_esn_ctx *ctx = crypto_aead_ctx(authenc_esn);
crypto/authencesn.c:76:	crypto_ahash_set_flags(auth, crypto_aead_get_flags(authenc_esn) &
crypto/authencesn.c:79:	crypto_aead_set_flags(authenc_esn, crypto_ahash_get_flags(auth) &
crypto/authencesn.c:86:	crypto_skcipher_set_flags(enc, crypto_aead_get_flags(authenc_esn) &
crypto/authencesn.c:89:	crypto_aead_set_flags(authenc_esn, crypto_skcipher_get_flags(enc) &
crypto/authencesn.c:97:	crypto_aead_set_flags(authenc_esn, CRYPTO_TFM_RES_BAD_KEY_LEN);
crypto/authencesn.c:104:	struct crypto_aead *authenc_esn = crypto_aead_reqtfm(req);
crypto/authencesn.c:105:	struct crypto_authenc_esn_ctx *ctx = crypto_aead_ctx(authenc_esn);
crypto/authencesn.c:110:	unsigned int authsize = crypto_aead_authsize(authenc_esn);
crypto/authencesn.c:137:	struct crypto_aead *authenc_esn = crypto_aead_reqtfm(req);
crypto/authencesn.c:139:	struct crypto_authenc_esn_ctx *ctx = crypto_aead_ctx(authenc_esn);
crypto/authencesn.c:144:	unsigned int authsize = crypto_aead_authsize(authenc_esn);
crypto/authencesn.c:184:	struct crypto_aead *authenc_esn = crypto_aead_reqtfm(req);
crypto/authencesn.c:185:	struct crypto_authenc_esn_ctx *ctx = crypto_aead_ctx(authenc_esn);
crypto/authencesn.c:198:	struct crypto_aead *authenc_esn = crypto_aead_reqtfm(req);
crypto/authencesn.c:200:	struct crypto_authenc_esn_ctx *ctx = crypto_aead_ctx(authenc_esn);
crypto/authencesn.c:237:	struct crypto_aead *authenc_esn = crypto_aead_reqtfm(req);
crypto/authencesn.c:238:	unsigned int authsize = crypto_aead_authsize(authenc_esn);
crypto/authencesn.c:240:	struct crypto_authenc_esn_ctx *ctx = crypto_aead_ctx(authenc_esn);
crypto/authencesn.c:287:	struct crypto_aead *authenc_esn = crypto_aead_reqtfm(req);
crypto/authencesn.c:289:	struct crypto_authenc_esn_ctx *ctx = crypto_aead_ctx(authenc_esn);
crypto/authencesn.c:291:	unsigned int authsize = crypto_aead_authsize(authenc_esn);
crypto/authencesn.c:337:static int crypto_authenc_esn_init_tfm(struct crypto_aead *tfm)
crypto/authencesn.c:341:	struct crypto_authenc_esn_ctx *ctx = crypto_aead_ctx(tfm);
crypto/authencesn.c:368:	crypto_aead_set_reqsize(
crypto/authencesn.c:387:static void crypto_authenc_esn_exit_tfm(struct crypto_aead *tfm)
crypto/authencesn.c:389:	struct crypto_authenc_esn_ctx *ctx = crypto_aead_ctx(tfm);
Binary file crypto/authencesn.ko matches
Binary file crypto/authencesn.o matches
Binary file crypto/authenc.ko matches
Binary file crypto/authenc.o matches
crypto/blkcipher.c:361:				   struct crypto_aead *tfm,
crypto/blkcipher.c:366:	walk->cipher_blocksize = crypto_aead_blocksize(tfm);
crypto/blkcipher.c:367:	walk->ivsize = crypto_aead_ivsize(tfm);
crypto/blkcipher.c:368:	walk->alignmask = crypto_aead_alignmask(tfm);
Binary file crypto/blkcipher.o matches
crypto/ccm.c:36:	struct crypto_aead *child;
crypto/ccm.c:70:	unsigned long align = crypto_aead_alignmask(crypto_aead_reqtfm(req));
crypto/ccm.c:93:static int crypto_ccm_setkey(struct crypto_aead *aead, const u8 *key,
crypto/ccm.c:96:	struct crypto_ccm_ctx *ctx = crypto_aead_ctx(aead);
crypto/ccm.c:102:	crypto_skcipher_set_flags(ctr, crypto_aead_get_flags(aead) &
crypto/ccm.c:105:	crypto_aead_set_flags(aead, crypto_skcipher_get_flags(ctr) &
crypto/ccm.c:111:	crypto_ahash_set_flags(mac, crypto_aead_get_flags(aead) &
crypto/ccm.c:114:	crypto_aead_set_flags(aead, crypto_ahash_get_flags(mac) &
crypto/ccm.c:121:static int crypto_ccm_setauthsize(struct crypto_aead *tfm,
crypto/ccm.c:143:	struct crypto_aead *aead = crypto_aead_reqtfm(req);
crypto/ccm.c:148:	m = crypto_aead_authsize(aead);
crypto/ccm.c:185:	struct crypto_aead *aead = crypto_aead_reqtfm(req);
crypto/ccm.c:186:	struct crypto_ccm_ctx *ctx = crypto_aead_ctx(aead);
crypto/ccm.c:243:	struct crypto_aead *aead = crypto_aead_reqtfm(req);
crypto/ccm.c:250:					 crypto_aead_authsize(aead), 1);
crypto/ccm.c:300:	struct crypto_aead *aead = crypto_aead_reqtfm(req);
crypto/ccm.c:301:	struct crypto_ccm_ctx *ctx = crypto_aead_ctx(aead);
crypto/ccm.c:332:				 crypto_aead_authsize(aead), 1);
crypto/ccm.c:341:	struct crypto_aead *aead = crypto_aead_reqtfm(req);
crypto/ccm.c:342:	unsigned int authsize = crypto_aead_authsize(aead);
crypto/ccm.c:360:	struct crypto_aead *aead = crypto_aead_reqtfm(req);
crypto/ccm.c:361:	struct crypto_ccm_ctx *ctx = crypto_aead_ctx(aead);
crypto/ccm.c:365:	unsigned int authsize = crypto_aead_authsize(aead);
crypto/ccm.c:406:static int crypto_ccm_init_tfm(struct crypto_aead *tfm)
crypto/ccm.c:410:	struct crypto_ccm_ctx *ctx = crypto_aead_ctx(tfm);
crypto/ccm.c:428:	align = crypto_aead_alignmask(tfm);
crypto/ccm.c:430:	crypto_aead_set_reqsize(
crypto/ccm.c:442:static void crypto_ccm_exit_tfm(struct crypto_aead *tfm)
crypto/ccm.c:444:	struct crypto_ccm_ctx *ctx = crypto_aead_ctx(tfm);
crypto/ccm.c:607:static int crypto_rfc4309_setkey(struct crypto_aead *parent, const u8 *key,
crypto/ccm.c:610:	struct crypto_rfc4309_ctx *ctx = crypto_aead_ctx(parent);
crypto/ccm.c:611:	struct crypto_aead *child = ctx->child;
crypto/ccm.c:620:	crypto_aead_clear_flags(child, CRYPTO_TFM_REQ_MASK);
crypto/ccm.c:621:	crypto_aead_set_flags(child, crypto_aead_get_flags(parent) &
crypto/ccm.c:623:	err = crypto_aead_setkey(child, key, keylen);
crypto/ccm.c:624:	crypto_aead_set_flags(parent, crypto_aead_get_flags(child) &
crypto/ccm.c:630:static int crypto_rfc4309_setauthsize(struct crypto_aead *parent,
crypto/ccm.c:633:	struct crypto_rfc4309_ctx *ctx = crypto_aead_ctx(parent);
crypto/ccm.c:644:	return crypto_aead_setauthsize(ctx->child, authsize);
crypto/ccm.c:651:	struct crypto_aead *aead = crypto_aead_reqtfm(req);
crypto/ccm.c:652:	struct crypto_rfc4309_ctx *ctx = crypto_aead_ctx(aead);
crypto/ccm.c:653:	struct crypto_aead *child = ctx->child;
crypto/ccm.c:655:	u8 *iv = PTR_ALIGN((u8 *)(subreq + 1) + crypto_aead_reqsize(child),
crypto/ccm.c:656:			   crypto_aead_alignmask(child) + 1);
crypto/ccm.c:698:	return crypto_aead_encrypt(req);
crypto/ccm.c:708:	return crypto_aead_decrypt(req);
crypto/ccm.c:711:static int crypto_rfc4309_init_tfm(struct crypto_aead *tfm)
crypto/ccm.c:714:	struct crypto_aead_spawn *spawn = aead_instance_ctx(inst);
crypto/ccm.c:715:	struct crypto_rfc4309_ctx *ctx = crypto_aead_ctx(tfm);
crypto/ccm.c:716:	struct crypto_aead *aead;
crypto/ccm.c:725:	align = crypto_aead_alignmask(aead);
crypto/ccm.c:727:	crypto_aead_set_reqsize(
crypto/ccm.c:730:		ALIGN(crypto_aead_reqsize(aead), crypto_tfm_ctx_alignment()) +
crypto/ccm.c:736:static void crypto_rfc4309_exit_tfm(struct crypto_aead *tfm)
crypto/ccm.c:738:	struct crypto_rfc4309_ctx *ctx = crypto_aead_ctx(tfm);
crypto/ccm.c:754:	struct crypto_aead_spawn *spawn;
crypto/ccm.c:786:	if (crypto_aead_alg_ivsize(alg) != 16)
crypto/ccm.c:808:	inst->alg.chunksize = crypto_aead_alg_chunksize(alg);
Binary file crypto/ccm.ko matches
Binary file crypto/ccm.o matches
crypto/chacha20poly1305.c:86:	struct chachapoly_ctx *ctx = crypto_aead_ctx(crypto_aead_reqtfm(req));
crypto/chacha20poly1305.c:125:	struct chachapoly_ctx *ctx = crypto_aead_ctx(crypto_aead_reqtfm(req));
crypto/chacha20poly1305.c:175:	struct crypto_aead *tfm = crypto_aead_reqtfm(req);
crypto/chacha20poly1305.c:176:	struct chachapoly_ctx *ctx = crypto_aead_ctx(tfm);
crypto/chacha20poly1305.c:209:	struct chachapoly_ctx *ctx = crypto_aead_ctx(crypto_aead_reqtfm(req));
crypto/chacha20poly1305.c:239:	struct chachapoly_ctx *ctx = crypto_aead_ctx(crypto_aead_reqtfm(req));
crypto/chacha20poly1305.c:270:	struct chachapoly_ctx *ctx = crypto_aead_ctx(crypto_aead_reqtfm(req));
crypto/chacha20poly1305.c:300:	struct chachapoly_ctx *ctx = crypto_aead_ctx(crypto_aead_reqtfm(req));
crypto/chacha20poly1305.c:324:	struct chachapoly_ctx *ctx = crypto_aead_ctx(crypto_aead_reqtfm(req));
crypto/chacha20poly1305.c:351:	struct chachapoly_ctx *ctx = crypto_aead_ctx(crypto_aead_reqtfm(req));
crypto/chacha20poly1305.c:374:	struct crypto_aead *tfm = crypto_aead_reqtfm(req);
crypto/chacha20poly1305.c:375:	struct chachapoly_ctx *ctx = crypto_aead_ctx(tfm);
crypto/chacha20poly1305.c:382:	if (crypto_aead_ivsize(tfm) == 8) {
crypto/chacha20poly1305.c:414:	struct chachapoly_ctx *ctx = crypto_aead_ctx(crypto_aead_reqtfm(req));
crypto/chacha20poly1305.c:489:static int chachapoly_setkey(struct crypto_aead *aead, const u8 *key,
crypto/chacha20poly1305.c:492:	struct chachapoly_ctx *ctx = crypto_aead_ctx(aead);
crypto/chacha20poly1305.c:502:	crypto_skcipher_set_flags(ctx->chacha, crypto_aead_get_flags(aead) &
crypto/chacha20poly1305.c:506:	crypto_aead_set_flags(aead, crypto_skcipher_get_flags(ctx->chacha) &
crypto/chacha20poly1305.c:511:static int chachapoly_setauthsize(struct crypto_aead *tfm,
crypto/chacha20poly1305.c:520:static int chachapoly_init(struct crypto_aead *tfm)
crypto/chacha20poly1305.c:524:	struct chachapoly_ctx *ctx = crypto_aead_ctx(tfm);
crypto/chacha20poly1305.c:543:	align = crypto_aead_alignmask(tfm);
crypto/chacha20poly1305.c:545:	crypto_aead_set_reqsize(
crypto/chacha20poly1305.c:558:static void chachapoly_exit(struct crypto_aead *tfm)
crypto/chacha20poly1305.c:560:	struct chachapoly_ctx *ctx = crypto_aead_ctx(tfm);
Binary file crypto/chacha20poly1305.ko matches
Binary file crypto/chacha20poly1305.o matches
crypto/cryptd.c:64:	struct crypto_aead_spawn aead_spawn;
crypto/cryptd.c:89:	struct crypto_aead *child;
crypto/cryptd.c:736:static int cryptd_aead_setkey(struct crypto_aead *parent,
crypto/cryptd.c:739:	struct cryptd_aead_ctx *ctx = crypto_aead_ctx(parent);
crypto/cryptd.c:740:	struct crypto_aead *child = ctx->child;
crypto/cryptd.c:742:	return crypto_aead_setkey(child, key, keylen);
crypto/cryptd.c:745:static int cryptd_aead_setauthsize(struct crypto_aead *parent,
crypto/cryptd.c:748:	struct cryptd_aead_ctx *ctx = crypto_aead_ctx(parent);
crypto/cryptd.c:749:	struct crypto_aead *child = ctx->child;
crypto/cryptd.c:751:	return crypto_aead_setauthsize(child, authsize);
crypto/cryptd.c:755:			struct crypto_aead *child,
crypto/cryptd.c:762:	struct crypto_aead *tfm;
crypto/cryptd.c:768:	tfm = crypto_aead_reqtfm(req);
crypto/cryptd.c:776:	ctx = crypto_aead_ctx(tfm);
crypto/cryptd.c:790:	struct crypto_aead *child = ctx->child;
crypto/cryptd.c:794:	cryptd_aead_crypt(req, child, err, crypto_aead_alg(child)->encrypt);
crypto/cryptd.c:800:	struct crypto_aead *child = ctx->child;
crypto/cryptd.c:804:	cryptd_aead_crypt(req, child, err, crypto_aead_alg(child)->decrypt);
crypto/cryptd.c:811:	struct crypto_aead *tfm = crypto_aead_reqtfm(req);
crypto/cryptd.c:812:	struct cryptd_queue *queue = cryptd_get_queue(crypto_aead_tfm(tfm));
crypto/cryptd.c:829:static int cryptd_aead_init_tfm(struct crypto_aead *tfm)
crypto/cryptd.c:833:	struct crypto_aead_spawn *spawn = &ictx->aead_spawn;
crypto/cryptd.c:834:	struct cryptd_aead_ctx *ctx = crypto_aead_ctx(tfm);
crypto/cryptd.c:835:	struct crypto_aead *cipher;
crypto/cryptd.c:842:	crypto_aead_set_reqsize(
crypto/cryptd.c:844:			 crypto_aead_reqsize(cipher)));
crypto/cryptd.c:848:static void cryptd_aead_exit_tfm(struct crypto_aead *tfm)
crypto/cryptd.c:850:	struct cryptd_aead_ctx *ctx = crypto_aead_ctx(tfm);
crypto/cryptd.c:893:	inst->alg.ivsize = crypto_aead_alg_ivsize(alg);
crypto/cryptd.c:894:	inst->alg.maxauthsize = crypto_aead_alg_maxauthsize(alg);
crypto/cryptd.c:1077:	struct crypto_aead *tfm;
crypto/cryptd.c:1090:	ctx = crypto_aead_ctx(tfm);
crypto/cryptd.c:1097:struct crypto_aead *cryptd_aead_child(struct cryptd_aead *tfm)
crypto/cryptd.c:1100:	ctx = crypto_aead_ctx(&tfm->base);
crypto/cryptd.c:1107:	struct cryptd_aead_ctx *ctx = crypto_aead_ctx(&tfm->base);
crypto/cryptd.c:1115:	struct cryptd_aead_ctx *ctx = crypto_aead_ctx(&tfm->base);
Binary file crypto/cryptd.ko matches
Binary file crypto/cryptd.o matches
Binary file crypto/crypto_simd.ko matches
Binary file crypto/crypto_simd.o matches
crypto/echainiv.c:33:	struct crypto_aead *geniv = crypto_aead_reqtfm(req);
crypto/echainiv.c:34:	struct aead_geniv_ctx *ctx = crypto_aead_ctx(geniv);
crypto/echainiv.c:39:	unsigned int ivsize = crypto_aead_ivsize(geniv);
crypto/echainiv.c:87:	return crypto_aead_encrypt(subreq);
crypto/echainiv.c:92:	struct crypto_aead *geniv = crypto_aead_reqtfm(req);
crypto/echainiv.c:93:	struct aead_geniv_ctx *ctx = crypto_aead_ctx(geniv);
crypto/echainiv.c:97:	unsigned int ivsize = crypto_aead_ivsize(geniv);
crypto/echainiv.c:114:	return crypto_aead_decrypt(subreq);
Binary file crypto/echainiv.ko matches
Binary file crypto/echainiv.o matches
crypto/gcm.c:37:	struct crypto_aead *child;
crypto/gcm.c:48:	struct crypto_aead_spawn aead;
crypto/gcm.c:52:	struct crypto_aead *child;
crypto/gcm.c:91:	unsigned long align = crypto_aead_alignmask(crypto_aead_reqtfm(req));
crypto/gcm.c:96:static int crypto_gcm_setkey(struct crypto_aead *aead, const u8 *key,
crypto/gcm.c:99:	struct crypto_gcm_ctx *ctx = crypto_aead_ctx(aead);
crypto/gcm.c:114:	crypto_skcipher_set_flags(ctr, crypto_aead_get_flags(aead) &
crypto/gcm.c:117:	crypto_aead_set_flags(aead, crypto_skcipher_get_flags(ctr) &
crypto/gcm.c:144:	crypto_ahash_set_flags(ghash, crypto_aead_get_flags(aead) &
crypto/gcm.c:147:	crypto_aead_set_flags(aead, crypto_ahash_get_flags(ghash) &
crypto/gcm.c:155:static int crypto_gcm_setauthsize(struct crypto_aead *tfm,
crypto/gcm.c:202:	struct crypto_aead *aead = crypto_aead_reqtfm(req);
crypto/gcm.c:203:	struct crypto_gcm_ctx *ctx = crypto_aead_ctx(aead);
crypto/gcm.c:424:	struct crypto_gcm_ctx *ctx = crypto_aead_ctx(crypto_aead_reqtfm(req));
crypto/gcm.c:436:	struct crypto_aead *aead = crypto_aead_reqtfm(req);
crypto/gcm.c:442:				 crypto_aead_authsize(aead), 1);
crypto/gcm.c:490:	struct crypto_aead *aead = crypto_aead_reqtfm(req);
crypto/gcm.c:493:	unsigned int authsize = crypto_aead_authsize(aead);
crypto/gcm.c:525:	struct crypto_aead *aead = crypto_aead_reqtfm(req);
crypto/gcm.c:528:	unsigned int authsize = crypto_aead_authsize(aead);
crypto/gcm.c:543:static int crypto_gcm_init_tfm(struct crypto_aead *tfm)
crypto/gcm.c:547:	struct crypto_gcm_ctx *ctx = crypto_aead_ctx(tfm);
crypto/gcm.c:565:	align = crypto_aead_alignmask(tfm);
crypto/gcm.c:567:	crypto_aead_set_reqsize(tfm,
crypto/gcm.c:581:static void crypto_gcm_exit_tfm(struct crypto_aead *tfm)
crypto/gcm.c:583:	struct crypto_gcm_ctx *ctx = crypto_aead_ctx(tfm);
crypto/gcm.c:741:static int crypto_rfc4106_setkey(struct crypto_aead *parent, const u8 *key,
crypto/gcm.c:744:	struct crypto_rfc4106_ctx *ctx = crypto_aead_ctx(parent);
crypto/gcm.c:745:	struct crypto_aead *child = ctx->child;
crypto/gcm.c:754:	crypto_aead_clear_flags(child, CRYPTO_TFM_REQ_MASK);
crypto/gcm.c:755:	crypto_aead_set_flags(child, crypto_aead_get_flags(parent) &
crypto/gcm.c:757:	err = crypto_aead_setkey(child, key, keylen);
crypto/gcm.c:758:	crypto_aead_set_flags(parent, crypto_aead_get_flags(child) &
crypto/gcm.c:764:static int crypto_rfc4106_setauthsize(struct crypto_aead *parent,
crypto/gcm.c:767:	struct crypto_rfc4106_ctx *ctx = crypto_aead_ctx(parent);
crypto/gcm.c:778:	return crypto_aead_setauthsize(ctx->child, authsize);
crypto/gcm.c:784:	struct crypto_aead *aead = crypto_aead_reqtfm(req);
crypto/gcm.c:785:	struct crypto_rfc4106_ctx *ctx = crypto_aead_ctx(aead);
crypto/gcm.c:787:	struct crypto_aead *child = ctx->child;
crypto/gcm.c:789:	u8 *iv = PTR_ALIGN((u8 *)(subreq + 1) + crypto_aead_reqsize(child),
crypto/gcm.c:790:			   crypto_aead_alignmask(child) + 1);
crypto/gcm.c:829:	return crypto_aead_encrypt(req);
crypto/gcm.c:839:	return crypto_aead_decrypt(req);
crypto/gcm.c:842:static int crypto_rfc4106_init_tfm(struct crypto_aead *tfm)
crypto/gcm.c:845:	struct crypto_aead_spawn *spawn = aead_instance_ctx(inst);
crypto/gcm.c:846:	struct crypto_rfc4106_ctx *ctx = crypto_aead_ctx(tfm);
crypto/gcm.c:847:	struct crypto_aead *aead;
crypto/gcm.c:856:	align = crypto_aead_alignmask(aead);
crypto/gcm.c:858:	crypto_aead_set_reqsize(
crypto/gcm.c:861:		ALIGN(crypto_aead_reqsize(aead), crypto_tfm_ctx_alignment()) +
crypto/gcm.c:867:static void crypto_rfc4106_exit_tfm(struct crypto_aead *tfm)
crypto/gcm.c:869:	struct crypto_rfc4106_ctx *ctx = crypto_aead_ctx(tfm);
crypto/gcm.c:885:	struct crypto_aead_spawn *spawn;
crypto/gcm.c:917:	if (crypto_aead_alg_ivsize(alg) != GCM_AES_IV_SIZE)
crypto/gcm.c:941:	inst->alg.chunksize = crypto_aead_alg_chunksize(alg);
crypto/gcm.c:942:	inst->alg.maxauthsize = crypto_aead_alg_maxauthsize(alg);
crypto/gcm.c:968:static int crypto_rfc4543_setkey(struct crypto_aead *parent, const u8 *key,
crypto/gcm.c:971:	struct crypto_rfc4543_ctx *ctx = crypto_aead_ctx(parent);
crypto/gcm.c:972:	struct crypto_aead *child = ctx->child;
crypto/gcm.c:981:	crypto_aead_clear_flags(child, CRYPTO_TFM_REQ_MASK);
crypto/gcm.c:982:	crypto_aead_set_flags(child, crypto_aead_get_flags(parent) &
crypto/gcm.c:984:	err = crypto_aead_setkey(child, key, keylen);
crypto/gcm.c:985:	crypto_aead_set_flags(parent, crypto_aead_get_flags(child) &
crypto/gcm.c:991:static int crypto_rfc4543_setauthsize(struct crypto_aead *parent,
crypto/gcm.c:994:	struct crypto_rfc4543_ctx *ctx = crypto_aead_ctx(parent);
crypto/gcm.c:999:	return crypto_aead_setauthsize(ctx->child, authsize);
crypto/gcm.c:1004:	struct crypto_aead *aead = crypto_aead_reqtfm(req);
crypto/gcm.c:1005:	struct crypto_rfc4543_ctx *ctx = crypto_aead_ctx(aead);
crypto/gcm.c:1008:	unsigned int authsize = crypto_aead_authsize(aead);
crypto/gcm.c:1009:	u8 *iv = PTR_ALIGN((u8 *)(rctx + 1) + crypto_aead_reqsize(ctx->child),
crypto/gcm.c:1010:			   crypto_aead_alignmask(ctx->child) + 1);
crypto/gcm.c:1030:	return enc ? crypto_aead_encrypt(subreq) : crypto_aead_decrypt(subreq);
crypto/gcm.c:1035:	struct crypto_aead *aead = crypto_aead_reqtfm(req);
crypto/gcm.c:1036:	struct crypto_rfc4543_ctx *ctx = crypto_aead_ctx(aead);
crypto/gcm.c:1037:	unsigned int authsize = crypto_aead_authsize(aead);
crypto/gcm.c:1059:static int crypto_rfc4543_init_tfm(struct crypto_aead *tfm)
crypto/gcm.c:1063:	struct crypto_aead_spawn *spawn = &ictx->aead;
crypto/gcm.c:1064:	struct crypto_rfc4543_ctx *ctx = crypto_aead_ctx(tfm);
crypto/gcm.c:1065:	struct crypto_aead *aead;
crypto/gcm.c:1082:	align = crypto_aead_alignmask(aead);
crypto/gcm.c:1084:	crypto_aead_set_reqsize(
crypto/gcm.c:1087:		ALIGN(crypto_aead_reqsize(aead), crypto_tfm_ctx_alignment()) +
crypto/gcm.c:1097:static void crypto_rfc4543_exit_tfm(struct crypto_aead *tfm)
crypto/gcm.c:1099:	struct crypto_rfc4543_ctx *ctx = crypto_aead_ctx(tfm);
crypto/gcm.c:1119:	struct crypto_aead_spawn *spawn;
crypto/gcm.c:1153:	if (crypto_aead_alg_ivsize(alg) != GCM_AES_IV_SIZE)
crypto/gcm.c:1177:	inst->alg.chunksize = crypto_aead_alg_chunksize(alg);
crypto/gcm.c:1178:	inst->alg.maxauthsize = crypto_aead_alg_maxauthsize(alg);
Binary file crypto/gcm.o matches
crypto/morus1280.c:402:static int crypto_morus1280_setkey(struct crypto_aead *aead, const u8 *key,
crypto/morus1280.c:405:	struct morus1280_ctx *ctx = crypto_aead_ctx(aead);
crypto/morus1280.c:416:		crypto_aead_set_flags(aead, CRYPTO_TFM_RES_BAD_KEY_LEN);
crypto/morus1280.c:423:static int crypto_morus1280_setauthsize(struct crypto_aead *tfm,
crypto/morus1280.c:434:	struct crypto_aead *tfm = crypto_aead_reqtfm(req);
crypto/morus1280.c:435:	struct morus1280_ctx *ctx = crypto_aead_ctx(tfm);
crypto/morus1280.c:451:	struct crypto_aead *tfm = crypto_aead_reqtfm(req);
crypto/morus1280.c:454:	unsigned int authsize = crypto_aead_authsize(tfm);
crypto/morus1280.c:473:	struct crypto_aead *tfm = crypto_aead_reqtfm(req);
crypto/morus1280.c:476:	unsigned int authsize = crypto_aead_authsize(tfm);
crypto/morus1280.c:489:static int crypto_morus1280_init_tfm(struct crypto_aead *tfm)
crypto/morus1280.c:494:static void crypto_morus1280_exit_tfm(struct crypto_aead *tfm)
crypto/morus640.c:401:static int crypto_morus640_setkey(struct crypto_aead *aead, const u8 *key,
crypto/morus640.c:404:	struct morus640_ctx *ctx = crypto_aead_ctx(aead);
crypto/morus640.c:407:		crypto_aead_set_flags(aead, CRYPTO_TFM_RES_BAD_KEY_LEN);
crypto/morus640.c:415:static int crypto_morus640_setauthsize(struct crypto_aead *tfm,
crypto/morus640.c:426:	struct crypto_aead *tfm = crypto_aead_reqtfm(req);
crypto/morus640.c:427:	struct morus640_ctx *ctx = crypto_aead_ctx(tfm);
crypto/morus640.c:443:	struct crypto_aead *tfm = crypto_aead_reqtfm(req);
crypto/morus640.c:446:	unsigned int authsize = crypto_aead_authsize(tfm);
crypto/morus640.c:465:	struct crypto_aead *tfm = crypto_aead_reqtfm(req);
crypto/morus640.c:468:	unsigned int authsize = crypto_aead_authsize(tfm);
crypto/morus640.c:481:static int crypto_morus640_init_tfm(struct crypto_aead *tfm)
crypto/morus640.c:486:static void crypto_morus640_exit_tfm(struct crypto_aead *tfm)
crypto/pcrypt.c:64:	struct crypto_aead_spawn spawn;
crypto/pcrypt.c:69:	struct crypto_aead *child;
crypto/pcrypt.c:102:static int pcrypt_aead_setkey(struct crypto_aead *parent,
crypto/pcrypt.c:105:	struct pcrypt_aead_ctx *ctx = crypto_aead_ctx(parent);
crypto/pcrypt.c:107:	return crypto_aead_setkey(ctx->child, key, keylen);
crypto/pcrypt.c:110:static int pcrypt_aead_setauthsize(struct crypto_aead *parent,
crypto/pcrypt.c:113:	struct pcrypt_aead_ctx *ctx = crypto_aead_ctx(parent);
crypto/pcrypt.c:115:	return crypto_aead_setauthsize(ctx->child, authsize);
crypto/pcrypt.c:143:	padata->info = crypto_aead_encrypt(req);
crypto/pcrypt.c:157:	struct crypto_aead *aead = crypto_aead_reqtfm(req);
crypto/pcrypt.c:158:	struct pcrypt_aead_ctx *ctx = crypto_aead_ctx(aead);
crypto/pcrypt.c:185:	padata->info = crypto_aead_decrypt(req);
crypto/pcrypt.c:199:	struct crypto_aead *aead = crypto_aead_reqtfm(req);
crypto/pcrypt.c:200:	struct pcrypt_aead_ctx *ctx = crypto_aead_ctx(aead);
crypto/pcrypt.c:222:static int pcrypt_aead_init_tfm(struct crypto_aead *tfm)
crypto/pcrypt.c:227:	struct pcrypt_aead_ctx *ctx = crypto_aead_ctx(tfm);
crypto/pcrypt.c:228:	struct crypto_aead *cipher;
crypto/pcrypt.c:243:	crypto_aead_set_reqsize(tfm, sizeof(struct pcrypt_request) +
crypto/pcrypt.c:245:				     crypto_aead_reqsize(cipher));
crypto/pcrypt.c:250:static void pcrypt_aead_exit_tfm(struct crypto_aead *tfm)
crypto/pcrypt.c:252:	struct pcrypt_aead_ctx *ctx = crypto_aead_ctx(tfm);
crypto/pcrypt.c:317:	inst->alg.ivsize = crypto_aead_alg_ivsize(alg);
crypto/pcrypt.c:318:	inst->alg.maxauthsize = crypto_aead_alg_maxauthsize(alg);
Binary file crypto/pcrypt.ko matches
Binary file crypto/pcrypt.o matches
crypto/seqiv.c:31:	struct crypto_aead *geniv;
crypto/seqiv.c:39:	geniv = crypto_aead_reqtfm(req);
crypto/seqiv.c:40:	memcpy(req->iv, subreq->iv, crypto_aead_ivsize(geniv));
crypto/seqiv.c:57:	struct crypto_aead *geniv = crypto_aead_reqtfm(req);
crypto/seqiv.c:58:	struct aead_geniv_ctx *ctx = crypto_aead_ctx(geniv);
crypto/seqiv.c:91:				 crypto_aead_alignmask(geniv) + 1))) {
crypto/seqiv.c:110:	err = crypto_aead_encrypt(subreq);
crypto/seqiv.c:118:	struct crypto_aead *geniv = crypto_aead_reqtfm(req);
crypto/seqiv.c:119:	struct aead_geniv_ctx *ctx = crypto_aead_ctx(geniv);
crypto/seqiv.c:125:	if (req->cryptlen < ivsize + crypto_aead_authsize(geniv))
crypto/seqiv.c:140:	return crypto_aead_decrypt(subreq);
Binary file crypto/seqiv.o matches
crypto/simd.c:305:static int simd_aead_setkey(struct crypto_aead *tfm, const u8 *key,
crypto/simd.c:308:	struct simd_aead_ctx *ctx = crypto_aead_ctx(tfm);
crypto/simd.c:309:	struct crypto_aead *child = &ctx->cryptd_tfm->base;
crypto/simd.c:312:	crypto_aead_clear_flags(child, CRYPTO_TFM_REQ_MASK);
crypto/simd.c:313:	crypto_aead_set_flags(child, crypto_aead_get_flags(tfm) &
crypto/simd.c:315:	err = crypto_aead_setkey(child, key, key_len);
crypto/simd.c:316:	crypto_aead_set_flags(tfm, crypto_aead_get_flags(child) &
crypto/simd.c:321:static int simd_aead_setauthsize(struct crypto_aead *tfm, unsigned int authsize)
crypto/simd.c:323:	struct simd_aead_ctx *ctx = crypto_aead_ctx(tfm);
crypto/simd.c:324:	struct crypto_aead *child = &ctx->cryptd_tfm->base;
crypto/simd.c:326:	return crypto_aead_setauthsize(child, authsize);
crypto/simd.c:331:	struct crypto_aead *tfm = crypto_aead_reqtfm(req);
crypto/simd.c:332:	struct simd_aead_ctx *ctx = crypto_aead_ctx(tfm);
crypto/simd.c:334:	struct crypto_aead *child;
crypto/simd.c:347:	return crypto_aead_encrypt(subreq);
crypto/simd.c:352:	struct crypto_aead *tfm = crypto_aead_reqtfm(req);
crypto/simd.c:353:	struct simd_aead_ctx *ctx = crypto_aead_ctx(tfm);
crypto/simd.c:355:	struct crypto_aead *child;
crypto/simd.c:368:	return crypto_aead_decrypt(subreq);
crypto/simd.c:371:static void simd_aead_exit(struct crypto_aead *tfm)
crypto/simd.c:373:	struct simd_aead_ctx *ctx = crypto_aead_ctx(tfm);
crypto/simd.c:378:static int simd_aead_init(struct crypto_aead *tfm)
crypto/simd.c:380:	struct simd_aead_ctx *ctx = crypto_aead_ctx(tfm);
crypto/simd.c:386:	alg = crypto_aead_alg(tfm);
crypto/simd.c:396:	reqsize = crypto_aead_reqsize(cryptd_aead_child(cryptd_tfm));
crypto/simd.c:397:	reqsize = max(reqsize, crypto_aead_reqsize(&cryptd_tfm->base));
crypto/simd.c:400:	crypto_aead_set_reqsize(tfm, reqsize);
crypto/simd.c:410:	struct crypto_aead *tfm;
crypto/simd.c:420:	ialg = crypto_aead_alg(tfm);
Binary file crypto/simd.o matches
crypto/skcipher.c:514:	struct crypto_aead *tfm = crypto_aead_reqtfm(req);
crypto/skcipher.c:540:	walk->blocksize = crypto_aead_blocksize(tfm);
crypto/skcipher.c:541:	walk->stride = crypto_aead_chunksize(tfm);
crypto/skcipher.c:542:	walk->ivsize = crypto_aead_ivsize(tfm);
crypto/skcipher.c:543:	walk->alignmask = crypto_aead_alignmask(tfm);
crypto/skcipher.c:574:	struct crypto_aead *tfm = crypto_aead_reqtfm(req);
crypto/skcipher.c:576:	walk->total = req->cryptlen - crypto_aead_authsize(tfm);
Binary file crypto/skcipher.o matches
crypto/tcrypt.c:169:			rc[i] = crypto_aead_encrypt(data[i].req);
crypto/tcrypt.c:171:			rc[i] = crypto_aead_decrypt(data[i].req);
crypto/tcrypt.c:261:	struct crypto_aead *tfm;
crypto/tcrypt.c:296:	ret = crypto_aead_setauthsize(tfm, authsize);
crypto/tcrypt.c:338:		get_driver_name(crypto_aead, tfm), e);
crypto/tcrypt.c:365:			crypto_aead_clear_flags(tfm, ~0);
crypto/tcrypt.c:367:			ret = crypto_aead_setkey(tfm, key, *keysize);
crypto/tcrypt.c:370:				       crypto_aead_get_flags(tfm));
crypto/tcrypt.c:374:			iv_len = crypto_aead_ivsize(tfm);
crypto/tcrypt.c:402:					ret = crypto_aead_encrypt(cur->req);
crypto/tcrypt.c:468:			ret = do_one_aead_op(req, crypto_aead_encrypt(req));
crypto/tcrypt.c:470:			ret = do_one_aead_op(req, crypto_aead_decrypt(req));
crypto/tcrypt.c:490:			ret = do_one_aead_op(req, crypto_aead_encrypt(req));
crypto/tcrypt.c:492:			ret = do_one_aead_op(req, crypto_aead_decrypt(req));
crypto/tcrypt.c:504:			ret = do_one_aead_op(req, crypto_aead_encrypt(req));
crypto/tcrypt.c:506:			ret = do_one_aead_op(req, crypto_aead_decrypt(req));
crypto/tcrypt.c:529:	struct crypto_aead *tfm;
crypto/tcrypt.c:581:			get_driver_name(crypto_aead, tfm), e);
crypto/tcrypt.c:614:			ret = crypto_aead_setkey(tfm, key, *keysize);
crypto/tcrypt.c:615:			ret = crypto_aead_setauthsize(tfm, authsize);
crypto/tcrypt.c:617:			iv_len = crypto_aead_ivsize(tfm);
crypto/tcrypt.c:621:			crypto_aead_clear_flags(tfm, ~0);
crypto/tcrypt.c:630:						crypto_aead_get_flags(tfm));
crypto/tcrypt.c:653:						     crypto_aead_encrypt(req));
Binary file crypto/tcrypt.ko matches
Binary file crypto/tcrypt.o matches
crypto/testmgr.c:1565:	struct crypto_aead *tfm = crypto_aead_reqtfm(req);
crypto/testmgr.c:1566:	const unsigned int alignmask = crypto_aead_alignmask(tfm);
crypto/testmgr.c:1567:	const unsigned int ivsize = crypto_aead_ivsize(tfm);
crypto/testmgr.c:1582:		crypto_aead_set_flags(tfm, CRYPTO_TFM_REQ_FORBID_WEAK_KEYS);
crypto/testmgr.c:1584:		crypto_aead_clear_flags(tfm, CRYPTO_TFM_REQ_FORBID_WEAK_KEYS);
crypto/testmgr.c:1585:	err = crypto_aead_setkey(tfm, vec->key, vec->klen);
crypto/testmgr.c:1589:		       crypto_aead_get_flags(tfm));
crypto/testmgr.c:1599:	err = crypto_aead_setauthsize(tfm, authsize);
crypto/testmgr.c:1640:	testmgr_poison(req->__ctx, crypto_aead_reqsize(tfm));
crypto/testmgr.c:1647:	err = enc ? crypto_aead_encrypt(req) : crypto_aead_decrypt(req);
crypto/testmgr.c:1658:	    crypto_aead_reqtfm(req) != tfm ||
crypto/testmgr.c:1674:		if (crypto_aead_reqtfm(req) != tfm)
crypto/testmgr.c:1780:	struct crypto_aead *tfm = crypto_aead_reqtfm(req);
crypto/testmgr.c:1781:	const unsigned int ivsize = crypto_aead_ivsize(tfm);
crypto/testmgr.c:1782:	unsigned int maxauthsize = crypto_aead_alg(tfm)->maxauthsize;
crypto/testmgr.c:1795:	vec->setkey_error = crypto_aead_setkey(tfm, vec->key, vec->klen);
crypto/testmgr.c:1807:	vec->setauthsize_error = crypto_aead_setauthsize(tfm, authsize);
crypto/testmgr.c:1840:	vec->crypt_error = crypto_wait_req(crypto_aead_encrypt(req), &wait);
crypto/testmgr.c:1858:	struct crypto_aead *tfm = crypto_aead_reqtfm(req);
crypto/testmgr.c:1859:	const unsigned int ivsize = crypto_aead_ivsize(tfm);
crypto/testmgr.c:1860:	const unsigned int maxauthsize = crypto_aead_alg(tfm)->maxauthsize;
crypto/testmgr.c:1861:	const unsigned int blocksize = crypto_aead_blocksize(tfm);
crypto/testmgr.c:1863:	const char *algname = crypto_aead_alg(tfm)->base.cra_name;
crypto/testmgr.c:1866:	struct crypto_aead *generic_tfm = NULL;
crypto/testmgr.c:1910:	if (maxauthsize != crypto_aead_alg(generic_tfm)->maxauthsize) {
crypto/testmgr.c:1913:		       crypto_aead_alg(generic_tfm)->maxauthsize);
crypto/testmgr.c:1918:	if (ivsize != crypto_aead_ivsize(generic_tfm)) {
crypto/testmgr.c:1920:		       driver, ivsize, crypto_aead_ivsize(generic_tfm));
crypto/testmgr.c:1925:	if (blocksize != crypto_aead_blocksize(generic_tfm)) {
crypto/testmgr.c:1927:		       driver, blocksize, crypto_aead_blocksize(generic_tfm));
crypto/testmgr.c:2010:	struct crypto_aead *tfm;
crypto/testmgr.h:19057: *   (see crypto_aead/aegis128/)
crypto/testmgr.h:19501: *   (see crypto_aead/aegis128l/)
crypto/testmgr.h:19945: *   (see crypto_aead/aegis256/)
crypto/testmgr.h:20485: *   (see crypto_aead/morus640128v2/)
crypto/testmgr.h:20945: *   (see crypto_aead/morus1280128v2/ and crypto_aead/morus1280256v2/ )
 

crypto/ablkcipher.c:300:static int setkey_unaligned(struct crypto_ablkcipher *tfm, const u8 *key,
crypto/ablkcipher.c:303:	struct ablkcipher_alg *cipher = crypto_ablkcipher_alg(tfm);
crypto/ablkcipher.c:304:	unsigned long alignmask = crypto_ablkcipher_alignmask(tfm);
crypto/ablkcipher.c:322:static int setkey(struct crypto_ablkcipher *tfm, const u8 *key,
crypto/ablkcipher.c:325:	struct ablkcipher_alg *cipher = crypto_ablkcipher_alg(tfm);
crypto/ablkcipher.c:326:	unsigned long alignmask = crypto_ablkcipher_alignmask(tfm);
crypto/ablkcipher.c:329:		crypto_ablkcipher_set_flags(tfm, CRYPTO_TFM_RES_BAD_KEY_LEN);
crypto/ablkcipher.c:339:static unsigned int crypto_ablkcipher_ctxsize(struct crypto_alg *alg, u32 type,
crypto/ablkcipher.c:357:	crt->base = __crypto_ablkcipher_cast(tfm);
crypto/ablkcipher.c:364:static int crypto_ablkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)
crypto/ablkcipher.c:382:static int crypto_ablkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)
crypto/ablkcipher.c:388:static void crypto_ablkcipher_show(struct seq_file *m, struct crypto_alg *alg)
crypto/ablkcipher.c:390:static void crypto_ablkcipher_show(struct seq_file *m, struct crypto_alg *alg)
crypto/ablkcipher.c:404:const struct crypto_type crypto_ablkcipher_type = {
crypto/ablkcipher.c:405:	.ctxsize = crypto_ablkcipher_ctxsize,
crypto/ablkcipher.c:408:	.show = crypto_ablkcipher_show,
crypto/ablkcipher.c:410:	.report = crypto_ablkcipher_report,
crypto/ablkcipher.c:412:EXPORT_SYMBOL_GPL(crypto_ablkcipher_type);
Binary file crypto/ablkcipher.o matches
Binary file crypto/acompress.o matches
Binary file crypto/aead.o matches
Binary file crypto/aes_generic.o matches
Binary file crypto/aes_ti.ko matches
Binary file crypto/aes_ti.o matches
Binary file crypto/af_alg.ko matches
Binary file crypto/af_alg.o matches
Binary file crypto/ahash.o matches
Binary file crypto/akcipher.o matches
Binary file crypto/algapi.o matches
Binary file crypto/algboss.o matches
Binary file crypto/algif_aead.ko matches
Binary file crypto/algif_aead.o matches
Binary file crypto/algif_hash.ko matches
Binary file crypto/algif_hash.o matches
Binary file crypto/algif_rng.ko matches
Binary file crypto/algif_rng.o matches
Binary file crypto/algif_skcipher.ko matches
Binary file crypto/algif_skcipher.o matches
Binary file crypto/ansi_cprng.ko matches
Binary file crypto/ansi_cprng.o matches
Binary file crypto/anubis.ko matches
Binary file crypto/anubis.o matches
Binary file crypto/api.o matches
Binary file crypto/arc4.ko matches
Binary file crypto/arc4.o matches
grep: crypto/asymmetric_keys: Is a directory
grep: crypto/async_tx: Is a directory
Binary file crypto/authencesn.ko matches
Binary file crypto/authencesn.o matches
Binary file crypto/authenc.ko matches
Binary file crypto/authenc.o matches
crypto/blkcipher.c:411:static int async_setkey(struct crypto_ablkcipher *tfm, const u8 *key,
crypto/blkcipher.c:414:	return setkey(crypto_ablkcipher_tfm(tfm), key, keylen);
crypto/blkcipher.c:467:	crt->base = __crypto_ablkcipher_cast(tfm);
Binary file crypto/blkcipher.o matches
Binary file crypto/blowfish_common.ko matches
Binary file crypto/blowfish_common.o matches
Binary file crypto/blowfish_generic.ko matches
Binary file crypto/blowfish_generic.o matches
Binary file crypto/camellia_generic.ko matches
Binary file crypto/camellia_generic.o matches
Binary file crypto/cast5_generic.ko matches
Binary file crypto/cast5_generic.o matches
Binary file crypto/cast6_generic.ko matches
Binary file crypto/cast6_generic.o matches
Binary file crypto/cbc.o matches
Binary file crypto/ccm.ko matches
Binary file crypto/ccm.o matches
Binary file crypto/chacha20poly1305.ko matches
Binary file crypto/chacha20poly1305.o matches
Binary file crypto/chacha_generic.ko matches
Binary file crypto/chacha_generic.o matches
Binary file crypto/cipher.o matches
Binary file crypto/cmac.ko matches
Binary file crypto/cmac.o matches
Binary file crypto/compress.o matches
Binary file crypto/crc32c_generic.o matches
Binary file crypto/crc32_generic.ko matches
Binary file crypto/crc32_generic.o matches
Binary file crypto/crct10dif_generic.o matches
Binary file crypto/cryptd.ko matches
Binary file crypto/cryptd.o matches
Binary file crypto/crypto_engine.ko matches
Binary file crypto/crypto_engine.o matches
Binary file crypto/crypto_null.o matches
Binary file crypto/crypto_simd.ko matches
Binary file crypto/crypto_simd.o matches
Binary file crypto/crypto_user_base.o matches
Binary file crypto/crypto_user.ko matches
Binary file crypto/crypto_user.o matches
Binary file crypto/crypto_wq.o matches
Binary file crypto/ctr.o matches
Binary file crypto/cts.o matches
Binary file crypto/deflate.o matches
Binary file crypto/des_generic.ko matches
Binary file crypto/des_generic.o matches
Binary file crypto/dh.o matches
Binary file crypto/drbg.o matches
Binary file crypto/ecb.o matches
Binary file crypto/ecc.ko matches
Binary file crypto/ecc.o matches
Binary file crypto/ecdh_generic.ko matches
Binary file crypto/ecdh_generic.o matches
Binary file crypto/ecdh.o matches
Binary file crypto/echainiv.ko matches
Binary file crypto/echainiv.o matches
Binary file crypto/fcrypt.ko matches
Binary file crypto/fcrypt.o matches
Binary file crypto/gcm.o matches
Binary file crypto/ghash-generic.o matches
Binary file crypto/hmac.o matches
Binary file crypto/jitterentropy-kcapi.o matches
Binary file crypto/keywrap.ko matches
Binary file crypto/keywrap.o matches
Binary file crypto/khazad.ko matches
Binary file crypto/khazad.o matches
Binary file crypto/kpp.o matches
Binary file crypto/lrw.ko matches
Binary file crypto/lrw.o matches
Binary file crypto/lz4hc.ko matches
Binary file crypto/lz4hc.o matches
Binary file crypto/lz4.ko matches
Binary file crypto/lz4.o matches
Binary file crypto/lzo.o matches
Binary file crypto/lzo-rle.o matches
Binary file crypto/md4.ko matches
Binary file crypto/md4.o matches
Binary file crypto/md5.o matches
Binary file crypto/memneq.o matches
Binary file crypto/michael_mic.ko matches
Binary file crypto/michael_mic.o matches
Binary file crypto/pcbc.ko matches
Binary file crypto/pcbc.o matches
Binary file crypto/pcrypt.ko matches
Binary file crypto/pcrypt.o matches
Binary file crypto/poly1305_generic.ko matches
Binary file crypto/poly1305_generic.o matches
Binary file crypto/proc.o matches
Binary file crypto/rmd128.ko matches
Binary file crypto/rmd128.o matches
Binary file crypto/rmd160.ko matches
Binary file crypto/rmd160.o matches
Binary file crypto/rmd256.ko matches
Binary file crypto/rmd256.o matches
Binary file crypto/rmd320.ko matches
Binary file crypto/rmd320.o matches
Binary file crypto/rng.o matches
Binary file crypto/rsa.o matches
Binary file crypto/rsa-pkcs1pad.o matches
Binary file crypto/salsa20_generic.ko matches
Binary file crypto/salsa20_generic.o matches
Binary file crypto/scatterwalk.o matches
Binary file crypto/scompress.o matches
Binary file crypto/seed.ko matches
Binary file crypto/seed.o matches
Binary file crypto/seqiv.o matches
Binary file crypto/serpent_generic.ko matches
Binary file crypto/serpent_generic.o matches
Binary file crypto/sha1_generic.o matches
Binary file crypto/sha256_generic.o matches
Binary file crypto/sha3_generic.ko matches
Binary file crypto/sha3_generic.o matches
Binary file crypto/sha512_generic.o matches
Binary file crypto/shash.o matches
Binary file crypto/simd.o matches
crypto/skcipher.c:587:	if (alg->cra_type == &crypto_ablkcipher_type)
crypto/skcipher.c:588:		return sizeof(struct crypto_ablkcipher *);
crypto/skcipher.c:701:	struct crypto_ablkcipher **ctx = crypto_skcipher_ctx(tfm);
crypto/skcipher.c:702:	struct crypto_ablkcipher *ablkcipher = *ctx;
crypto/skcipher.c:705:	crypto_ablkcipher_clear_flags(ablkcipher, ~0);
crypto/skcipher.c:706:	crypto_ablkcipher_set_flags(ablkcipher,
crypto/skcipher.c:709:	err = crypto_ablkcipher_setkey(ablkcipher, key, keylen);
crypto/skcipher.c:711:				  crypto_ablkcipher_get_flags(ablkcipher) &
crypto/skcipher.c:726:	struct crypto_ablkcipher **ctx = crypto_skcipher_ctx(tfm);
crypto/skcipher.c:758:	struct crypto_ablkcipher **ctx = crypto_tfm_ctx(tfm);
crypto/skcipher.c:767:	struct crypto_ablkcipher **ctx = crypto_tfm_ctx(tfm);
crypto/skcipher.c:768:	struct crypto_ablkcipher *ablkcipher;
crypto/skcipher.c:780:	ablkcipher = __crypto_ablkcipher_cast(abtfm);
crypto/skcipher.c:788:	skcipher->ivsize = crypto_ablkcipher_ivsize(ablkcipher);
crypto/skcipher.c:789:	skcipher->reqsize = crypto_ablkcipher_reqsize(ablkcipher) +
crypto/skcipher.c:861:	if (tfm->__crt_alg->cra_type == &crypto_ablkcipher_type)
Binary file crypto/skcipher.o matches
Binary file crypto/sm3_generic.ko matches
Binary file crypto/sm3_generic.o matches
Binary file crypto/tcrypt.ko matches
Binary file crypto/tcrypt.o matches
Binary file crypto/tea.ko matches
Binary file crypto/tea.o matches
Binary file crypto/testmgr.o matches
Binary file crypto/tgr192.ko matches
Binary file crypto/tgr192.o matches
Binary file crypto/twofish_common.ko matches
Binary file crypto/twofish_common.o matches
Binary file crypto/twofish_generic.ko matches
Binary file crypto/twofish_generic.o matches
Binary file crypto/vmac.ko matches
Binary file crypto/vmac.o matches
Binary file crypto/wp512.ko matches
Binary file crypto/wp512.o matches
Binary file crypto/xcbc.ko matches
Binary file crypto/xcbc.o matches
Binary file crypto/xts.o matches
root@armorer:/home/armorer/drm-misc# grep  -n 'crypto_blkcipher*' crypto/* 
Binary file crypto/842.ko matches
Binary file crypto/842.o matches
Binary file crypto/ablkcipher.o matches
Binary file crypto/acompress.o matches
Binary file crypto/aead.o matches
Binary file crypto/aes_generic.o matches
Binary file crypto/aes_ti.ko matches
Binary file crypto/aes_ti.o matches
Binary file crypto/af_alg.ko matches
Binary file crypto/af_alg.o matches
Binary file crypto/ahash.o matches
Binary file crypto/akcipher.o matches
Binary file crypto/algapi.o matches
Binary file crypto/algboss.o matches
Binary file crypto/algif_aead.ko matches
Binary file crypto/algif_aead.o matches
Binary file crypto/algif_hash.ko matches
Binary file crypto/algif_hash.o matches
Binary file crypto/algif_rng.ko matches
Binary file crypto/algif_rng.o matches
Binary file crypto/algif_skcipher.ko matches
Binary file crypto/algif_skcipher.o matches
Binary file crypto/ansi_cprng.ko matches
Binary file crypto/ansi_cprng.o matches
Binary file crypto/anubis.ko matches
Binary file crypto/anubis.o matches
Binary file crypto/api.o matches
Binary file crypto/arc4.ko matches
Binary file crypto/arc4.o matches
grep: crypto/asymmetric_keys: Is a directory
grep: crypto/async_tx: Is a directory
Binary file crypto/authencesn.ko matches
Binary file crypto/authencesn.o matches
Binary file crypto/authenc.ko matches
Binary file crypto/authenc.o matches
crypto/blkcipher.c:301:	walk->walk_blocksize = crypto_blkcipher_blocksize(desc->tfm);
crypto/blkcipher.c:303:	walk->ivsize = crypto_blkcipher_ivsize(desc->tfm);
crypto/blkcipher.c:304:	walk->alignmask = crypto_blkcipher_alignmask(desc->tfm);
crypto/blkcipher.c:313:	walk->walk_blocksize = crypto_blkcipher_blocksize(desc->tfm);
crypto/blkcipher.c:315:	walk->ivsize = crypto_blkcipher_ivsize(desc->tfm);
crypto/blkcipher.c:316:	walk->alignmask = crypto_blkcipher_alignmask(desc->tfm);
crypto/blkcipher.c:352:	walk->cipher_blocksize = crypto_blkcipher_blocksize(desc->tfm);
crypto/blkcipher.c:353:	walk->ivsize = crypto_blkcipher_ivsize(desc->tfm);
crypto/blkcipher.c:354:	walk->alignmask = crypto_blkcipher_alignmask(desc->tfm);
crypto/blkcipher.c:422:		.tfm = __crypto_blkcipher_cast(tfm),
crypto/blkcipher.c:436:		.tfm = __crypto_blkcipher_cast(tfm),
crypto/blkcipher.c:444:static unsigned int crypto_blkcipher_ctxsize(struct crypto_alg *alg, u32 type,
crypto/blkcipher.c:506:static int crypto_blkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)
crypto/blkcipher.c:524:static int crypto_blkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)
crypto/blkcipher.c:530:static void crypto_blkcipher_show(struct seq_file *m, struct crypto_alg *alg)
crypto/blkcipher.c:532:static void crypto_blkcipher_show(struct seq_file *m, struct crypto_alg *alg)
crypto/blkcipher.c:542:const struct crypto_type crypto_blkcipher_type = {
crypto/blkcipher.c:543:	.ctxsize = crypto_blkcipher_ctxsize,
crypto/blkcipher.c:546:	.show = crypto_blkcipher_show,
crypto/blkcipher.c:548:	.report = crypto_blkcipher_report,
crypto/blkcipher.c:550:EXPORT_SYMBOL_GPL(crypto_blkcipher_type);
Binary file crypto/blkcipher.o matches
Binary file crypto/blowfish_common.ko matches
Binary file crypto/blowfish_common.o matches
Binary file crypto/blowfish_generic.ko matches
Binary file crypto/blowfish_generic.o matches
Binary file crypto/camellia_generic.ko matches
Binary file crypto/camellia_generic.o matches
Binary file crypto/cast5_generic.ko matches
Binary file crypto/cast5_generic.o matches
Binary file crypto/cast6_generic.ko matches
Binary file crypto/cast6_generic.o matches
Binary file crypto/cbc.o matches
Binary file crypto/ccm.ko matches
Binary file crypto/ccm.o matches
Binary file crypto/chacha20poly1305.ko matches
Binary file crypto/chacha20poly1305.o matches
Binary file crypto/chacha_generic.ko matches
Binary file crypto/chacha_generic.o matches
Binary file crypto/cipher.o matches
Binary file crypto/cmac.ko matches
Binary file crypto/cmac.o matches
Binary file crypto/compress.o matches
Binary file crypto/crc32c_generic.o matches
Binary file crypto/crc32_generic.ko matches
Binary file crypto/crc32_generic.o matches
Binary file crypto/crct10dif_generic.o matches
Binary file crypto/cryptd.ko matches
Binary file crypto/cryptd.o matches
Binary file crypto/crypto_engine.ko matches
Binary file crypto/crypto_engine.o matches
Binary file crypto/crypto_null.o matches
Binary file crypto/crypto_simd.ko matches
Binary file crypto/crypto_simd.o matches
Binary file crypto/crypto_user_base.o matches
Binary file crypto/crypto_user.ko matches
Binary file crypto/crypto_user.o matches
Binary file crypto/crypto_wq.o matches
Binary file crypto/ctr.o matches
Binary file crypto/cts.o matches
Binary file crypto/deflate.o matches
Binary file crypto/des_generic.ko matches
Binary file crypto/des_generic.o matches
Binary file crypto/dh.o matches
Binary file crypto/drbg.o matches
Binary file crypto/ecb.o matches
Binary file crypto/ecc.ko matches
Binary file crypto/ecc.o matches
Binary file crypto/ecdh_generic.ko matches
Binary file crypto/ecdh_generic.o matches
Binary file crypto/ecdh.o matches
Binary file crypto/echainiv.ko matches
Binary file crypto/echainiv.o matches
Binary file crypto/fcrypt.ko matches
Binary file crypto/fcrypt.o matches
Binary file crypto/gcm.o matches
Binary file crypto/ghash-generic.o matches
Binary file crypto/hmac.o matches
Binary file crypto/jitterentropy-kcapi.o matches
Binary file crypto/keywrap.ko matches
Binary file crypto/keywrap.o matches
Binary file crypto/khazad.ko matches
Binary file crypto/khazad.o matches
Binary file crypto/kpp.o matches
Binary file crypto/lrw.ko matches
Binary file crypto/lrw.o matches
Binary file crypto/lz4hc.ko matches
Binary file crypto/lz4hc.o matches
Binary file crypto/lz4.ko matches
Binary file crypto/lz4.o matches
Binary file crypto/lzo.o matches
Binary file crypto/lzo-rle.o matches
crypto/Makefile:20:crypto_blkcipher-y := ablkcipher.o
crypto/Makefile:21:crypto_blkcipher-y += blkcipher.o
crypto/Makefile:22:crypto_blkcipher-y += skcipher.o
crypto/Makefile:23:obj-$(CONFIG_CRYPTO_BLKCIPHER2) += crypto_blkcipher.o
Binary file crypto/md4.ko matches
Binary file crypto/md4.o matches
Binary file crypto/md5.o matches
Binary file crypto/memneq.o matches
Binary file crypto/michael_mic.ko matches
Binary file crypto/michael_mic.o matches
crypto/modules.builtin:5:kernel/crypto/crypto_blkcipher.ko
Binary file crypto/pcbc.ko matches
Binary file crypto/pcbc.o matches
Binary file crypto/pcrypt.ko matches
Binary file crypto/pcrypt.o matches
Binary file crypto/poly1305_generic.ko matches
Binary file crypto/poly1305_generic.o matches
Binary file crypto/proc.o matches
Binary file crypto/rmd128.ko matches
Binary file crypto/rmd128.o matches
Binary file crypto/rmd160.ko matches
Binary file crypto/rmd160.o matches
Binary file crypto/rmd256.ko matches
Binary file crypto/rmd256.o matches
Binary file crypto/rmd320.ko matches
Binary file crypto/rmd320.o matches
Binary file crypto/rng.o matches
Binary file crypto/rsa.o matches
Binary file crypto/rsa-pkcs1pad.o matches
Binary file crypto/salsa20_generic.ko matches
Binary file crypto/salsa20_generic.o matches
Binary file crypto/scatterwalk.o matches
Binary file crypto/scompress.o matches
Binary file crypto/seed.ko matches
Binary file crypto/seed.o matches
Binary file crypto/seqiv.o matches
Binary file crypto/serpent_generic.ko matches
Binary file crypto/serpent_generic.o matches
Binary file crypto/sha1_generic.o matches
Binary file crypto/sha256_generic.o matches
Binary file crypto/sha3_generic.ko matches
Binary file crypto/sha3_generic.o matches
Binary file crypto/sha512_generic.o matches
Binary file crypto/shash.o matches
Binary file crypto/simd.o matches
crypto/skcipher.c:584:	if (alg->cra_type == &crypto_blkcipher_type)
crypto/skcipher.c:585:		return sizeof(struct crypto_blkcipher *);
crypto/skcipher.c:602:	struct crypto_blkcipher **ctx = crypto_skcipher_ctx(tfm);
crypto/skcipher.c:603:	struct crypto_blkcipher *blkcipher = *ctx;
crypto/skcipher.c:606:	crypto_blkcipher_clear_flags(blkcipher, ~0);
crypto/skcipher.c:607:	crypto_blkcipher_set_flags(blkcipher, crypto_skcipher_get_flags(tfm) &
crypto/skcipher.c:609:	err = crypto_blkcipher_setkey(blkcipher, key, keylen);
crypto/skcipher.c:610:	crypto_skcipher_set_flags(tfm, crypto_blkcipher_get_flags(blkcipher) &
crypto/skcipher.c:628:	struct crypto_blkcipher **ctx = crypto_skcipher_ctx(tfm);
crypto/skcipher.c:659:	struct crypto_blkcipher **ctx = crypto_tfm_ctx(tfm);
crypto/skcipher.c:668:	struct crypto_blkcipher **ctx = crypto_tfm_ctx(tfm);
crypto/skcipher.c:669:	struct crypto_blkcipher *blkcipher;
crypto/skcipher.c:682:	blkcipher = __crypto_blkcipher_cast(btfm);
crypto/skcipher.c:690:	skcipher->ivsize = crypto_blkcipher_ivsize(blkcipher);
crypto/skcipher.c:858:	if (tfm->__crt_alg->cra_type == &crypto_blkcipher_type)
Binary file crypto/skcipher.o matches
Binary file crypto/sm3_generic.ko matches
Binary file crypto/sm3_generic.o matches
Binary file crypto/tcrypt.ko matches
Binary file crypto/tcrypt.o matches
Binary file crypto/tea.ko matches
Binary file crypto/tea.o matches
Binary file crypto/testmgr.o matches
Binary file crypto/tgr192.ko matches
Binary file crypto/tgr192.o matches
Binary file crypto/twofish_common.ko matches
Binary file crypto/twofish_common.o matches
Binary file crypto/twofish_generic.ko matches
Binary file crypto/twofish_generic.o matches
Binary file crypto/vmac.ko matches
Binary file crypto/vmac.o matches
Binary file crypto/wp512.ko matches
Binary file crypto/wp512.o matches
Binary file crypto/xcbc.ko matches
Binary file crypto/xcbc.o matches
Binary file crypto/xts.o matches
root@armorer:/home/armorer/drm-misc# grep  -n 'crypto_aead*' crypto/* 
crypto/aead.c:32:static int setkey_unaligned(struct crypto_aead *tfm, const u8 *key,
crypto/aead.c:35:	unsigned long alignmask = crypto_aead_alignmask(tfm);
crypto/aead.c:47:	ret = crypto_aead_alg(tfm)->setkey(tfm, alignbuffer, keylen);
crypto/aead.c:53:int crypto_aead_setkey(struct crypto_aead *tfm,
crypto/aead.c:56:	unsigned long alignmask = crypto_aead_alignmask(tfm);
crypto/aead.c:62:		err = crypto_aead_alg(tfm)->setkey(tfm, key, keylen);
crypto/aead.c:65:		crypto_aead_set_flags(tfm, CRYPTO_TFM_NEED_KEY);
crypto/aead.c:69:	crypto_aead_clear_flags(tfm, CRYPTO_TFM_NEED_KEY);
crypto/aead.c:72:EXPORT_SYMBOL_GPL(crypto_aead_setkey);
crypto/aead.c:74:int crypto_aead_setauthsize(struct crypto_aead *tfm, unsigned int authsize)
crypto/aead.c:78:	if (authsize > crypto_aead_maxauthsize(tfm))
crypto/aead.c:81:	if (crypto_aead_alg(tfm)->setauthsize) {
crypto/aead.c:82:		err = crypto_aead_alg(tfm)->setauthsize(tfm, authsize);
crypto/aead.c:90:EXPORT_SYMBOL_GPL(crypto_aead_setauthsize);
crypto/aead.c:92:static void crypto_aead_exit_tfm(struct crypto_tfm *tfm)
crypto/aead.c:94:	struct crypto_aead *aead = __crypto_aead_cast(tfm);
crypto/aead.c:95:	struct aead_alg *alg = crypto_aead_alg(aead);
crypto/aead.c:100:static int crypto_aead_init_tfm(struct crypto_tfm *tfm)
crypto/aead.c:102:	struct crypto_aead *aead = __crypto_aead_cast(tfm);
crypto/aead.c:103:	struct aead_alg *alg = crypto_aead_alg(aead);
crypto/aead.c:105:	crypto_aead_set_flags(aead, CRYPTO_TFM_NEED_KEY);
crypto/aead.c:110:		aead->base.exit = crypto_aead_exit_tfm;
crypto/aead.c:119:static int crypto_aead_report(struct sk_buff *skb, struct crypto_alg *alg)
crypto/aead.c:136:static int crypto_aead_report(struct sk_buff *skb, struct crypto_alg *alg)
crypto/aead.c:142:static void crypto_aead_show(struct seq_file *m, struct crypto_alg *alg)
crypto/aead.c:144:static void crypto_aead_show(struct seq_file *m, struct crypto_alg *alg)
crypto/aead.c:157:static void crypto_aead_free_instance(struct crypto_instance *inst)
crypto/aead.c:169:static const struct crypto_type crypto_aead_type = {
crypto/aead.c:171:	.init_tfm = crypto_aead_init_tfm,
crypto/aead.c:172:	.free = crypto_aead_free_instance,
crypto/aead.c:174:	.show = crypto_aead_show,
crypto/aead.c:176:	.report = crypto_aead_report,
crypto/aead.c:180:	.tfmsize = offsetof(struct crypto_aead, base),
crypto/aead.c:183:static int aead_geniv_setkey(struct crypto_aead *tfm,
crypto/aead.c:186:	struct aead_geniv_ctx *ctx = crypto_aead_ctx(tfm);
crypto/aead.c:188:	return crypto_aead_setkey(ctx->child, key, keylen);
crypto/aead.c:191:static int aead_geniv_setauthsize(struct crypto_aead *tfm,
crypto/aead.c:194:	struct aead_geniv_ctx *ctx = crypto_aead_ctx(tfm);
crypto/aead.c:196:	return crypto_aead_setauthsize(ctx->child, authsize);
crypto/aead.c:203:	struct crypto_aead_spawn *spawn;
crypto/aead.c:238:	ivsize = crypto_aead_alg_ivsize(alg);
crypto/aead.c:239:	maxauthsize = crypto_aead_alg_maxauthsize(alg);
crypto/aead.c:286:int aead_init_geniv(struct crypto_aead *aead)
crypto/aead.c:288:	struct aead_geniv_ctx *ctx = crypto_aead_ctx(aead);
crypto/aead.c:290:	struct crypto_aead *child;
crypto/aead.c:300:				   crypto_aead_ivsize(aead));
crypto/aead.c:316:	crypto_aead_set_reqsize(aead, crypto_aead_reqsize(child) +
crypto/aead.c:330:void aead_exit_geniv(struct crypto_aead *tfm)
crypto/aead.c:332:	struct aead_geniv_ctx *ctx = crypto_aead_ctx(tfm);
crypto/aead.c:339:int crypto_grab_aead(struct crypto_aead_spawn *spawn, const char *name,
crypto/aead.c:342:	spawn->base.frontend = &crypto_aead_type;
crypto/aead.c:347:struct crypto_aead *crypto_alloc_aead(const char *alg_name, u32 type, u32 mask)
crypto/aead.c:349:	return crypto_alloc_tfm(alg_name, &crypto_aead_type, type, mask);
crypto/aead.c:364:	base->cra_type = &crypto_aead_type;
Binary file crypto/aead.o matches
crypto/aegis128.c:327:static int crypto_aegis128_setkey(struct crypto_aead *aead, const u8 *key,
crypto/aegis128.c:330:	struct aegis_ctx *ctx = crypto_aead_ctx(aead);
crypto/aegis128.c:333:		crypto_aead_set_flags(aead, CRYPTO_TFM_RES_BAD_KEY_LEN);
crypto/aegis128.c:341:static int crypto_aegis128_setauthsize(struct crypto_aead *tfm,
crypto/aegis128.c:356:	struct crypto_aead *tfm = crypto_aead_reqtfm(req);
crypto/aegis128.c:357:	struct aegis_ctx *ctx = crypto_aead_ctx(tfm);
crypto/aegis128.c:373:	struct crypto_aead *tfm = crypto_aead_reqtfm(req);
crypto/aegis128.c:375:	unsigned int authsize = crypto_aead_authsize(tfm);
crypto/aegis128.c:393:	struct crypto_aead *tfm = crypto_aead_reqtfm(req);
crypto/aegis128.c:395:	unsigned int authsize = crypto_aead_authsize(tfm);
crypto/aegis128.c:406:static int crypto_aegis128_init_tfm(struct crypto_aead *tfm)
crypto/aegis128.c:411:static void crypto_aegis128_exit_tfm(struct crypto_aead *tfm)
crypto/aegis128l.c:391:static int crypto_aegis128l_setkey(struct crypto_aead *aead, const u8 *key,
crypto/aegis128l.c:394:	struct aegis_ctx *ctx = crypto_aead_ctx(aead);
crypto/aegis128l.c:397:		crypto_aead_set_flags(aead, CRYPTO_TFM_RES_BAD_KEY_LEN);
crypto/aegis128l.c:405:static int crypto_aegis128l_setauthsize(struct crypto_aead *tfm,
crypto/aegis128l.c:420:	struct crypto_aead *tfm = crypto_aead_reqtfm(req);
crypto/aegis128l.c:421:	struct aegis_ctx *ctx = crypto_aead_ctx(tfm);
crypto/aegis128l.c:437:	struct crypto_aead *tfm = crypto_aead_reqtfm(req);
crypto/aegis128l.c:439:	unsigned int authsize = crypto_aead_authsize(tfm);
crypto/aegis128l.c:457:	struct crypto_aead *tfm = crypto_aead_reqtfm(req);
crypto/aegis128l.c:459:	unsigned int authsize = crypto_aead_authsize(tfm);
crypto/aegis128l.c:470:static int crypto_aegis128l_init_tfm(struct crypto_aead *tfm)
crypto/aegis128l.c:475:static void crypto_aegis128l_exit_tfm(struct crypto_aead *tfm)
crypto/aegis256.c:340:static int crypto_aegis256_setkey(struct crypto_aead *aead, const u8 *key,
crypto/aegis256.c:343:	struct aegis_ctx *ctx = crypto_aead_ctx(aead);
crypto/aegis256.c:346:		crypto_aead_set_flags(aead, CRYPTO_TFM_RES_BAD_KEY_LEN);
crypto/aegis256.c:356:static int crypto_aegis256_setauthsize(struct crypto_aead *tfm,
crypto/aegis256.c:371:	struct crypto_aead *tfm = crypto_aead_reqtfm(req);
crypto/aegis256.c:372:	struct aegis_ctx *ctx = crypto_aead_ctx(tfm);
crypto/aegis256.c:388:	struct crypto_aead *tfm = crypto_aead_reqtfm(req);
crypto/aegis256.c:390:	unsigned int authsize = crypto_aead_authsize(tfm);
crypto/aegis256.c:408:	struct crypto_aead *tfm = crypto_aead_reqtfm(req);
crypto/aegis256.c:410:	unsigned int authsize = crypto_aead_authsize(tfm);
crypto/aegis256.c:421:static int crypto_aegis256_init_tfm(struct crypto_aead *tfm)
crypto/aegis256.c:426:static void crypto_aegis256_exit_tfm(struct crypto_aead *tfm)
crypto/algif_aead.c:44:	struct crypto_aead *aead;
crypto/algif_aead.c:55:	struct crypto_aead *tfm = aeadc->aead;
crypto/algif_aead.c:56:	unsigned int as = crypto_aead_authsize(tfm);
crypto/algif_aead.c:72:	struct crypto_aead *tfm = aeadc->aead;
crypto/algif_aead.c:73:	unsigned int ivsize = crypto_aead_ivsize(tfm);
crypto/algif_aead.c:78:static int crypto_aead_copy_sgl(struct crypto_sync_skcipher *null_tfm,
crypto/algif_aead.c:101:	struct crypto_aead *tfm = aeadc->aead;
crypto/algif_aead.c:103:	unsigned int i, as = crypto_aead_authsize(tfm);
crypto/algif_aead.c:158:				     crypto_aead_reqsize(tfm));
crypto/algif_aead.c:230:		err = crypto_aead_copy_sgl(null_tfm, tsgl_src,
crypto/algif_aead.c:248:		err = crypto_aead_copy_sgl(null_tfm, tsgl_src,
crypto/algif_aead.c:300:		err = ctx->enc ? crypto_aead_encrypt(&areq->cra_u.aead_req) :
crypto/algif_aead.c:301:				 crypto_aead_decrypt(&areq->cra_u.aead_req);
crypto/algif_aead.c:314:				crypto_aead_encrypt(&areq->cra_u.aead_req) :
crypto/algif_aead.c:315:				crypto_aead_decrypt(&areq->cra_u.aead_req),
crypto/algif_aead.c:400:	if (crypto_aead_get_flags(tfm->aead) & CRYPTO_TFM_NEED_KEY)
crypto/algif_aead.c:480:	struct crypto_aead *aead;
crypto/algif_aead.c:519:	return crypto_aead_setauthsize(tfm->aead, authsize);
crypto/algif_aead.c:526:	return crypto_aead_setkey(tfm->aead, key, keylen);
crypto/algif_aead.c:536:	struct crypto_aead *tfm = aeadc->aead;
crypto/algif_aead.c:537:	unsigned int ivlen = crypto_aead_ivsize(tfm);
crypto/algif_aead.c:550:	struct crypto_aead *aead = tfm->aead;
crypto/algif_aead.c:552:	unsigned int ivlen = crypto_aead_ivsize(aead);
crypto/algif_aead.c:587:	if (crypto_aead_get_flags(tfm->aead) & CRYPTO_TFM_NEED_KEY)
Binary file crypto/algif_aead.ko matches
Binary file crypto/algif_aead.o matches
grep: crypto/asymmetric_keys: Is a directory
grep: crypto/async_tx: Is a directory
crypto/authenc.c:89:static int crypto_authenc_setkey(struct crypto_aead *authenc, const u8 *key,
crypto/authenc.c:92:	struct crypto_authenc_ctx *ctx = crypto_aead_ctx(authenc);
crypto/authenc.c:102:	crypto_ahash_set_flags(auth, crypto_aead_get_flags(authenc) &
crypto/authenc.c:105:	crypto_aead_set_flags(authenc, crypto_ahash_get_flags(auth) &
crypto/authenc.c:112:	crypto_skcipher_set_flags(enc, crypto_aead_get_flags(authenc) &
crypto/authenc.c:115:	crypto_aead_set_flags(authenc, crypto_skcipher_get_flags(enc) &
crypto/authenc.c:123:	crypto_aead_set_flags(authenc, CRYPTO_TFM_RES_BAD_KEY_LEN);
crypto/authenc.c:130:	struct crypto_aead *authenc = crypto_aead_reqtfm(req);
crypto/authenc.c:141:				 crypto_aead_authsize(authenc), 1);
crypto/authenc.c:149:	struct crypto_aead *authenc = crypto_aead_reqtfm(req);
crypto/authenc.c:151:	struct crypto_authenc_ctx *ctx = crypto_aead_ctx(authenc);
crypto/authenc.c:173:				 crypto_aead_authsize(authenc), 1);
crypto/authenc.c:194:	struct crypto_aead *authenc = crypto_aead_reqtfm(req);
crypto/authenc.c:195:	struct crypto_authenc_ctx *ctx = crypto_aead_ctx(authenc);
crypto/authenc.c:209:	struct crypto_aead *authenc = crypto_aead_reqtfm(req);
crypto/authenc.c:211:	struct crypto_authenc_ctx *ctx = crypto_aead_ctx(authenc);
crypto/authenc.c:247:	struct crypto_aead *authenc = crypto_aead_reqtfm(req);
crypto/authenc.c:249:	struct crypto_authenc_ctx *ctx = crypto_aead_ctx(authenc);
crypto/authenc.c:255:	unsigned int authsize = crypto_aead_authsize(authenc);
crypto/authenc.c:295:	struct crypto_aead *authenc = crypto_aead_reqtfm(req);
crypto/authenc.c:296:	unsigned int authsize = crypto_aead_authsize(authenc);
crypto/authenc.c:298:	struct crypto_authenc_ctx *ctx = crypto_aead_ctx(authenc);
crypto/authenc.c:322:static int crypto_authenc_init_tfm(struct crypto_aead *tfm)
crypto/authenc.c:326:	struct crypto_authenc_ctx *ctx = crypto_aead_ctx(tfm);
crypto/authenc.c:350:	crypto_aead_set_reqsize(
crypto/authenc.c:369:static void crypto_authenc_exit_tfm(struct crypto_aead *tfm)
crypto/authenc.c:371:	struct crypto_authenc_ctx *ctx = crypto_aead_ctx(tfm);
crypto/authencesn.c:54:static int crypto_authenc_esn_setauthsize(struct crypto_aead *authenc_esn,
crypto/authencesn.c:63:static int crypto_authenc_esn_setkey(struct crypto_aead *authenc_esn, const u8 *key,
crypto/authencesn.c:66:	struct crypto_authenc_esn_ctx *ctx = crypto_aead_ctx(authenc_esn);
crypto/authencesn.c:76:	crypto_ahash_set_flags(auth, crypto_aead_get_flags(authenc_esn) &
crypto/authencesn.c:79:	crypto_aead_set_flags(authenc_esn, crypto_ahash_get_flags(auth) &
crypto/authencesn.c:86:	crypto_skcipher_set_flags(enc, crypto_aead_get_flags(authenc_esn) &
crypto/authencesn.c:89:	crypto_aead_set_flags(authenc_esn, crypto_skcipher_get_flags(enc) &
crypto/authencesn.c:97:	crypto_aead_set_flags(authenc_esn, CRYPTO_TFM_RES_BAD_KEY_LEN);
crypto/authencesn.c:104:	struct crypto_aead *authenc_esn = crypto_aead_reqtfm(req);
crypto/authencesn.c:105:	struct crypto_authenc_esn_ctx *ctx = crypto_aead_ctx(authenc_esn);
crypto/authencesn.c:110:	unsigned int authsize = crypto_aead_authsize(authenc_esn);
crypto/authencesn.c:137:	struct crypto_aead *authenc_esn = crypto_aead_reqtfm(req);
crypto/authencesn.c:139:	struct crypto_authenc_esn_ctx *ctx = crypto_aead_ctx(authenc_esn);
crypto/authencesn.c:144:	unsigned int authsize = crypto_aead_authsize(authenc_esn);
crypto/authencesn.c:184:	struct crypto_aead *authenc_esn = crypto_aead_reqtfm(req);
crypto/authencesn.c:185:	struct crypto_authenc_esn_ctx *ctx = crypto_aead_ctx(authenc_esn);
crypto/authencesn.c:198:	struct crypto_aead *authenc_esn = crypto_aead_reqtfm(req);
crypto/authencesn.c:200:	struct crypto_authenc_esn_ctx *ctx = crypto_aead_ctx(authenc_esn);
crypto/authencesn.c:237:	struct crypto_aead *authenc_esn = crypto_aead_reqtfm(req);
crypto/authencesn.c:238:	unsigned int authsize = crypto_aead_authsize(authenc_esn);
crypto/authencesn.c:240:	struct crypto_authenc_esn_ctx *ctx = crypto_aead_ctx(authenc_esn);
crypto/authencesn.c:287:	struct crypto_aead *authenc_esn = crypto_aead_reqtfm(req);
crypto/authencesn.c:289:	struct crypto_authenc_esn_ctx *ctx = crypto_aead_ctx(authenc_esn);
crypto/authencesn.c:291:	unsigned int authsize = crypto_aead_authsize(authenc_esn);
crypto/authencesn.c:337:static int crypto_authenc_esn_init_tfm(struct crypto_aead *tfm)
crypto/authencesn.c:341:	struct crypto_authenc_esn_ctx *ctx = crypto_aead_ctx(tfm);
crypto/authencesn.c:368:	crypto_aead_set_reqsize(
crypto/authencesn.c:387:static void crypto_authenc_esn_exit_tfm(struct crypto_aead *tfm)
crypto/authencesn.c:389:	struct crypto_authenc_esn_ctx *ctx = crypto_aead_ctx(tfm);
Binary file crypto/authencesn.ko matches
Binary file crypto/authencesn.o matches
Binary file crypto/authenc.ko matches
Binary file crypto/authenc.o matches
crypto/blkcipher.c:361:				   struct crypto_aead *tfm,
crypto/blkcipher.c:366:	walk->cipher_blocksize = crypto_aead_blocksize(tfm);
crypto/blkcipher.c:367:	walk->ivsize = crypto_aead_ivsize(tfm);
crypto/blkcipher.c:368:	walk->alignmask = crypto_aead_alignmask(tfm);
Binary file crypto/blkcipher.o matches
crypto/ccm.c:36:	struct crypto_aead *child;
crypto/ccm.c:70:	unsigned long align = crypto_aead_alignmask(crypto_aead_reqtfm(req));
crypto/ccm.c:93:static int crypto_ccm_setkey(struct crypto_aead *aead, const u8 *key,
crypto/ccm.c:96:	struct crypto_ccm_ctx *ctx = crypto_aead_ctx(aead);
crypto/ccm.c:102:	crypto_skcipher_set_flags(ctr, crypto_aead_get_flags(aead) &
crypto/ccm.c:105:	crypto_aead_set_flags(aead, crypto_skcipher_get_flags(ctr) &
crypto/ccm.c:111:	crypto_ahash_set_flags(mac, crypto_aead_get_flags(aead) &
crypto/ccm.c:114:	crypto_aead_set_flags(aead, crypto_ahash_get_flags(mac) &
crypto/ccm.c:121:static int crypto_ccm_setauthsize(struct crypto_aead *tfm,
crypto/ccm.c:143:	struct crypto_aead *aead = crypto_aead_reqtfm(req);
crypto/ccm.c:148:	m = crypto_aead_authsize(aead);
crypto/ccm.c:185:	struct crypto_aead *aead = crypto_aead_reqtfm(req);
crypto/ccm.c:186:	struct crypto_ccm_ctx *ctx = crypto_aead_ctx(aead);
crypto/ccm.c:243:	struct crypto_aead *aead = crypto_aead_reqtfm(req);
crypto/ccm.c:250:					 crypto_aead_authsize(aead), 1);
crypto/ccm.c:300:	struct crypto_aead *aead = crypto_aead_reqtfm(req);
crypto/ccm.c:301:	struct crypto_ccm_ctx *ctx = crypto_aead_ctx(aead);
crypto/ccm.c:332:				 crypto_aead_authsize(aead), 1);
crypto/ccm.c:341:	struct crypto_aead *aead = crypto_aead_reqtfm(req);
crypto/ccm.c:342:	unsigned int authsize = crypto_aead_authsize(aead);
crypto/ccm.c:360:	struct crypto_aead *aead = crypto_aead_reqtfm(req);
crypto/ccm.c:361:	struct crypto_ccm_ctx *ctx = crypto_aead_ctx(aead);
crypto/ccm.c:365:	unsigned int authsize = crypto_aead_authsize(aead);
crypto/ccm.c:406:static int crypto_ccm_init_tfm(struct crypto_aead *tfm)
crypto/ccm.c:410:	struct crypto_ccm_ctx *ctx = crypto_aead_ctx(tfm);
crypto/ccm.c:428:	align = crypto_aead_alignmask(tfm);
crypto/ccm.c:430:	crypto_aead_set_reqsize(
crypto/ccm.c:442:static void crypto_ccm_exit_tfm(struct crypto_aead *tfm)
crypto/ccm.c:444:	struct crypto_ccm_ctx *ctx = crypto_aead_ctx(tfm);
crypto/ccm.c:607:static int crypto_rfc4309_setkey(struct crypto_aead *parent, const u8 *key,
crypto/ccm.c:610:	struct crypto_rfc4309_ctx *ctx = crypto_aead_ctx(parent);
crypto/ccm.c:611:	struct crypto_aead *child = ctx->child;
crypto/ccm.c:620:	crypto_aead_clear_flags(child, CRYPTO_TFM_REQ_MASK);
crypto/ccm.c:621:	crypto_aead_set_flags(child, crypto_aead_get_flags(parent) &
crypto/ccm.c:623:	err = crypto_aead_setkey(child, key, keylen);
crypto/ccm.c:624:	crypto_aead_set_flags(parent, crypto_aead_get_flags(child) &
crypto/ccm.c:630:static int crypto_rfc4309_setauthsize(struct crypto_aead *parent,
crypto/ccm.c:633:	struct crypto_rfc4309_ctx *ctx = crypto_aead_ctx(parent);
crypto/ccm.c:644:	return crypto_aead_setauthsize(ctx->child, authsize);
crypto/ccm.c:651:	struct crypto_aead *aead = crypto_aead_reqtfm(req);
crypto/ccm.c:652:	struct crypto_rfc4309_ctx *ctx = crypto_aead_ctx(aead);
crypto/ccm.c:653:	struct crypto_aead *child = ctx->child;
crypto/ccm.c:655:	u8 *iv = PTR_ALIGN((u8 *)(subreq + 1) + crypto_aead_reqsize(child),
crypto/ccm.c:656:			   crypto_aead_alignmask(child) + 1);
crypto/ccm.c:698:	return crypto_aead_encrypt(req);
crypto/ccm.c:708:	return crypto_aead_decrypt(req);
crypto/ccm.c:711:static int crypto_rfc4309_init_tfm(struct crypto_aead *tfm)
crypto/ccm.c:714:	struct crypto_aead_spawn *spawn = aead_instance_ctx(inst);
crypto/ccm.c:715:	struct crypto_rfc4309_ctx *ctx = crypto_aead_ctx(tfm);
crypto/ccm.c:716:	struct crypto_aead *aead;
crypto/ccm.c:725:	align = crypto_aead_alignmask(aead);
crypto/ccm.c:727:	crypto_aead_set_reqsize(
crypto/ccm.c:730:		ALIGN(crypto_aead_reqsize(aead), crypto_tfm_ctx_alignment()) +
crypto/ccm.c:736:static void crypto_rfc4309_exit_tfm(struct crypto_aead *tfm)
crypto/ccm.c:738:	struct crypto_rfc4309_ctx *ctx = crypto_aead_ctx(tfm);
crypto/ccm.c:754:	struct crypto_aead_spawn *spawn;
crypto/ccm.c:786:	if (crypto_aead_alg_ivsize(alg) != 16)
crypto/ccm.c:808:	inst->alg.chunksize = crypto_aead_alg_chunksize(alg);
Binary file crypto/ccm.ko matches
Binary file crypto/ccm.o matches
crypto/chacha20poly1305.c:86:	struct chachapoly_ctx *ctx = crypto_aead_ctx(crypto_aead_reqtfm(req));
crypto/chacha20poly1305.c:125:	struct chachapoly_ctx *ctx = crypto_aead_ctx(crypto_aead_reqtfm(req));
crypto/chacha20poly1305.c:175:	struct crypto_aead *tfm = crypto_aead_reqtfm(req);
crypto/chacha20poly1305.c:176:	struct chachapoly_ctx *ctx = crypto_aead_ctx(tfm);
crypto/chacha20poly1305.c:209:	struct chachapoly_ctx *ctx = crypto_aead_ctx(crypto_aead_reqtfm(req));
crypto/chacha20poly1305.c:239:	struct chachapoly_ctx *ctx = crypto_aead_ctx(crypto_aead_reqtfm(req));
crypto/chacha20poly1305.c:270:	struct chachapoly_ctx *ctx = crypto_aead_ctx(crypto_aead_reqtfm(req));
crypto/chacha20poly1305.c:300:	struct chachapoly_ctx *ctx = crypto_aead_ctx(crypto_aead_reqtfm(req));
crypto/chacha20poly1305.c:324:	struct chachapoly_ctx *ctx = crypto_aead_ctx(crypto_aead_reqtfm(req));
crypto/chacha20poly1305.c:351:	struct chachapoly_ctx *ctx = crypto_aead_ctx(crypto_aead_reqtfm(req));
crypto/chacha20poly1305.c:374:	struct crypto_aead *tfm = crypto_aead_reqtfm(req);
crypto/chacha20poly1305.c:375:	struct chachapoly_ctx *ctx = crypto_aead_ctx(tfm);
crypto/chacha20poly1305.c:382:	if (crypto_aead_ivsize(tfm) == 8) {
crypto/chacha20poly1305.c:414:	struct chachapoly_ctx *ctx = crypto_aead_ctx(crypto_aead_reqtfm(req));
crypto/chacha20poly1305.c:489:static int chachapoly_setkey(struct crypto_aead *aead, const u8 *key,
crypto/chacha20poly1305.c:492:	struct chachapoly_ctx *ctx = crypto_aead_ctx(aead);
crypto/chacha20poly1305.c:502:	crypto_skcipher_set_flags(ctx->chacha, crypto_aead_get_flags(aead) &
crypto/chacha20poly1305.c:506:	crypto_aead_set_flags(aead, crypto_skcipher_get_flags(ctx->chacha) &
crypto/chacha20poly1305.c:511:static int chachapoly_setauthsize(struct crypto_aead *tfm,
crypto/chacha20poly1305.c:520:static int chachapoly_init(struct crypto_aead *tfm)
crypto/chacha20poly1305.c:524:	struct chachapoly_ctx *ctx = crypto_aead_ctx(tfm);
crypto/chacha20poly1305.c:543:	align = crypto_aead_alignmask(tfm);
crypto/chacha20poly1305.c:545:	crypto_aead_set_reqsize(
crypto/chacha20poly1305.c:558:static void chachapoly_exit(struct crypto_aead *tfm)
crypto/chacha20poly1305.c:560:	struct chachapoly_ctx *ctx = crypto_aead_ctx(tfm);
Binary file crypto/chacha20poly1305.ko matches
Binary file crypto/chacha20poly1305.o matches
crypto/cryptd.c:64:	struct crypto_aead_spawn aead_spawn;
crypto/cryptd.c:89:	struct crypto_aead *child;
crypto/cryptd.c:736:static int cryptd_aead_setkey(struct crypto_aead *parent,
crypto/cryptd.c:739:	struct cryptd_aead_ctx *ctx = crypto_aead_ctx(parent);
crypto/cryptd.c:740:	struct crypto_aead *child = ctx->child;
crypto/cryptd.c:742:	return crypto_aead_setkey(child, key, keylen);
crypto/cryptd.c:745:static int cryptd_aead_setauthsize(struct crypto_aead *parent,
crypto/cryptd.c:748:	struct cryptd_aead_ctx *ctx = crypto_aead_ctx(parent);
crypto/cryptd.c:749:	struct crypto_aead *child = ctx->child;
crypto/cryptd.c:751:	return crypto_aead_setauthsize(child, authsize);
crypto/cryptd.c:755:			struct crypto_aead *child,
crypto/cryptd.c:762:	struct crypto_aead *tfm;
crypto/cryptd.c:768:	tfm = crypto_aead_reqtfm(req);
crypto/cryptd.c:776:	ctx = crypto_aead_ctx(tfm);
crypto/cryptd.c:790:	struct crypto_aead *child = ctx->child;
crypto/cryptd.c:794:	cryptd_aead_crypt(req, child, err, crypto_aead_alg(child)->encrypt);
crypto/cryptd.c:800:	struct crypto_aead *child = ctx->child;
crypto/cryptd.c:804:	cryptd_aead_crypt(req, child, err, crypto_aead_alg(child)->decrypt);
crypto/cryptd.c:811:	struct crypto_aead *tfm = crypto_aead_reqtfm(req);
crypto/cryptd.c:812:	struct cryptd_queue *queue = cryptd_get_queue(crypto_aead_tfm(tfm));
crypto/cryptd.c:829:static int cryptd_aead_init_tfm(struct crypto_aead *tfm)
crypto/cryptd.c:833:	struct crypto_aead_spawn *spawn = &ictx->aead_spawn;
crypto/cryptd.c:834:	struct cryptd_aead_ctx *ctx = crypto_aead_ctx(tfm);
crypto/cryptd.c:835:	struct crypto_aead *cipher;
crypto/cryptd.c:842:	crypto_aead_set_reqsize(
crypto/cryptd.c:844:			 crypto_aead_reqsize(cipher)));
crypto/cryptd.c:848:static void cryptd_aead_exit_tfm(struct crypto_aead *tfm)
crypto/cryptd.c:850:	struct cryptd_aead_ctx *ctx = crypto_aead_ctx(tfm);
crypto/cryptd.c:893:	inst->alg.ivsize = crypto_aead_alg_ivsize(alg);
crypto/cryptd.c:894:	inst->alg.maxauthsize = crypto_aead_alg_maxauthsize(alg);
crypto/cryptd.c:1077:	struct crypto_aead *tfm;
crypto/cryptd.c:1090:	ctx = crypto_aead_ctx(tfm);
crypto/cryptd.c:1097:struct crypto_aead *cryptd_aead_child(struct cryptd_aead *tfm)
crypto/cryptd.c:1100:	ctx = crypto_aead_ctx(&tfm->base);
crypto/cryptd.c:1107:	struct cryptd_aead_ctx *ctx = crypto_aead_ctx(&tfm->base);
crypto/cryptd.c:1115:	struct cryptd_aead_ctx *ctx = crypto_aead_ctx(&tfm->base);
Binary file crypto/cryptd.ko matches
Binary file crypto/cryptd.o matches
Binary file crypto/crypto_simd.ko matches
Binary file crypto/crypto_simd.o matches
crypto/echainiv.c:33:	struct crypto_aead *geniv = crypto_aead_reqtfm(req);
crypto/echainiv.c:34:	struct aead_geniv_ctx *ctx = crypto_aead_ctx(geniv);
crypto/echainiv.c:39:	unsigned int ivsize = crypto_aead_ivsize(geniv);
crypto/echainiv.c:87:	return crypto_aead_encrypt(subreq);
crypto/echainiv.c:92:	struct crypto_aead *geniv = crypto_aead_reqtfm(req);
crypto/echainiv.c:93:	struct aead_geniv_ctx *ctx = crypto_aead_ctx(geniv);
crypto/echainiv.c:97:	unsigned int ivsize = crypto_aead_ivsize(geniv);
crypto/echainiv.c:114:	return crypto_aead_decrypt(subreq);
Binary file crypto/echainiv.ko matches
Binary file crypto/echainiv.o matches
crypto/gcm.c:37:	struct crypto_aead *child;
crypto/gcm.c:48:	struct crypto_aead_spawn aead;
crypto/gcm.c:52:	struct crypto_aead *child;
crypto/gcm.c:91:	unsigned long align = crypto_aead_alignmask(crypto_aead_reqtfm(req));
crypto/gcm.c:96:static int crypto_gcm_setkey(struct crypto_aead *aead, const u8 *key,
crypto/gcm.c:99:	struct crypto_gcm_ctx *ctx = crypto_aead_ctx(aead);
crypto/gcm.c:114:	crypto_skcipher_set_flags(ctr, crypto_aead_get_flags(aead) &
crypto/gcm.c:117:	crypto_aead_set_flags(aead, crypto_skcipher_get_flags(ctr) &
crypto/gcm.c:144:	crypto_ahash_set_flags(ghash, crypto_aead_get_flags(aead) &
crypto/gcm.c:147:	crypto_aead_set_flags(aead, crypto_ahash_get_flags(ghash) &
crypto/gcm.c:155:static int crypto_gcm_setauthsize(struct crypto_aead *tfm,
crypto/gcm.c:202:	struct crypto_aead *aead = crypto_aead_reqtfm(req);
crypto/gcm.c:203:	struct crypto_gcm_ctx *ctx = crypto_aead_ctx(aead);
crypto/gcm.c:424:	struct crypto_gcm_ctx *ctx = crypto_aead_ctx(crypto_aead_reqtfm(req));
crypto/gcm.c:436:	struct crypto_aead *aead = crypto_aead_reqtfm(req);
crypto/gcm.c:442:				 crypto_aead_authsize(aead), 1);
crypto/gcm.c:490:	struct crypto_aead *aead = crypto_aead_reqtfm(req);
crypto/gcm.c:493:	unsigned int authsize = crypto_aead_authsize(aead);
crypto/gcm.c:525:	struct crypto_aead *aead = crypto_aead_reqtfm(req);
crypto/gcm.c:528:	unsigned int authsize = crypto_aead_authsize(aead);
crypto/gcm.c:543:static int crypto_gcm_init_tfm(struct crypto_aead *tfm)
crypto/gcm.c:547:	struct crypto_gcm_ctx *ctx = crypto_aead_ctx(tfm);
crypto/gcm.c:565:	align = crypto_aead_alignmask(tfm);
crypto/gcm.c:567:	crypto_aead_set_reqsize(tfm,
crypto/gcm.c:581:static void crypto_gcm_exit_tfm(struct crypto_aead *tfm)
crypto/gcm.c:583:	struct crypto_gcm_ctx *ctx = crypto_aead_ctx(tfm);
crypto/gcm.c:741:static int crypto_rfc4106_setkey(struct crypto_aead *parent, const u8 *key,
crypto/gcm.c:744:	struct crypto_rfc4106_ctx *ctx = crypto_aead_ctx(parent);
crypto/gcm.c:745:	struct crypto_aead *child = ctx->child;
crypto/gcm.c:754:	crypto_aead_clear_flags(child, CRYPTO_TFM_REQ_MASK);
crypto/gcm.c:755:	crypto_aead_set_flags(child, crypto_aead_get_flags(parent) &
crypto/gcm.c:757:	err = crypto_aead_setkey(child, key, keylen);
crypto/gcm.c:758:	crypto_aead_set_flags(parent, crypto_aead_get_flags(child) &
crypto/gcm.c:764:static int crypto_rfc4106_setauthsize(struct crypto_aead *parent,
crypto/gcm.c:767:	struct crypto_rfc4106_ctx *ctx = crypto_aead_ctx(parent);
crypto/gcm.c:778:	return crypto_aead_setauthsize(ctx->child, authsize);
crypto/gcm.c:784:	struct crypto_aead *aead = crypto_aead_reqtfm(req);
crypto/gcm.c:785:	struct crypto_rfc4106_ctx *ctx = crypto_aead_ctx(aead);
crypto/gcm.c:787:	struct crypto_aead *child = ctx->child;
crypto/gcm.c:789:	u8 *iv = PTR_ALIGN((u8 *)(subreq + 1) + crypto_aead_reqsize(child),
crypto/gcm.c:790:			   crypto_aead_alignmask(child) + 1);
crypto/gcm.c:829:	return crypto_aead_encrypt(req);
crypto/gcm.c:839:	return crypto_aead_decrypt(req);
crypto/gcm.c:842:static int crypto_rfc4106_init_tfm(struct crypto_aead *tfm)
crypto/gcm.c:845:	struct crypto_aead_spawn *spawn = aead_instance_ctx(inst);
crypto/gcm.c:846:	struct crypto_rfc4106_ctx *ctx = crypto_aead_ctx(tfm);
crypto/gcm.c:847:	struct crypto_aead *aead;
crypto/gcm.c:856:	align = crypto_aead_alignmask(aead);
crypto/gcm.c:858:	crypto_aead_set_reqsize(
crypto/gcm.c:861:		ALIGN(crypto_aead_reqsize(aead), crypto_tfm_ctx_alignment()) +
crypto/gcm.c:867:static void crypto_rfc4106_exit_tfm(struct crypto_aead *tfm)
crypto/gcm.c:869:	struct crypto_rfc4106_ctx *ctx = crypto_aead_ctx(tfm);
crypto/gcm.c:885:	struct crypto_aead_spawn *spawn;
crypto/gcm.c:917:	if (crypto_aead_alg_ivsize(alg) != GCM_AES_IV_SIZE)
crypto/gcm.c:941:	inst->alg.chunksize = crypto_aead_alg_chunksize(alg);
crypto/gcm.c:942:	inst->alg.maxauthsize = crypto_aead_alg_maxauthsize(alg);
crypto/gcm.c:968:static int crypto_rfc4543_setkey(struct crypto_aead *parent, const u8 *key,
crypto/gcm.c:971:	struct crypto_rfc4543_ctx *ctx = crypto_aead_ctx(parent);
crypto/gcm.c:972:	struct crypto_aead *child = ctx->child;
crypto/gcm.c:981:	crypto_aead_clear_flags(child, CRYPTO_TFM_REQ_MASK);
crypto/gcm.c:982:	crypto_aead_set_flags(child, crypto_aead_get_flags(parent) &
crypto/gcm.c:984:	err = crypto_aead_setkey(child, key, keylen);
crypto/gcm.c:985:	crypto_aead_set_flags(parent, crypto_aead_get_flags(child) &
crypto/gcm.c:991:static int crypto_rfc4543_setauthsize(struct crypto_aead *parent,
crypto/gcm.c:994:	struct crypto_rfc4543_ctx *ctx = crypto_aead_ctx(parent);
crypto/gcm.c:999:	return crypto_aead_setauthsize(ctx->child, authsize);
crypto/gcm.c:1004:	struct crypto_aead *aead = crypto_aead_reqtfm(req);
crypto/gcm.c:1005:	struct crypto_rfc4543_ctx *ctx = crypto_aead_ctx(aead);
crypto/gcm.c:1008:	unsigned int authsize = crypto_aead_authsize(aead);
crypto/gcm.c:1009:	u8 *iv = PTR_ALIGN((u8 *)(rctx + 1) + crypto_aead_reqsize(ctx->child),
crypto/gcm.c:1010:			   crypto_aead_alignmask(ctx->child) + 1);
crypto/gcm.c:1030:	return enc ? crypto_aead_encrypt(subreq) : crypto_aead_decrypt(subreq);
crypto/gcm.c:1035:	struct crypto_aead *aead = crypto_aead_reqtfm(req);
crypto/gcm.c:1036:	struct crypto_rfc4543_ctx *ctx = crypto_aead_ctx(aead);
crypto/gcm.c:1037:	unsigned int authsize = crypto_aead_authsize(aead);
crypto/gcm.c:1059:static int crypto_rfc4543_init_tfm(struct crypto_aead *tfm)
crypto/gcm.c:1063:	struct crypto_aead_spawn *spawn = &ictx->aead;
crypto/gcm.c:1064:	struct crypto_rfc4543_ctx *ctx = crypto_aead_ctx(tfm);
crypto/gcm.c:1065:	struct crypto_aead *aead;
crypto/gcm.c:1082:	align = crypto_aead_alignmask(aead);
crypto/gcm.c:1084:	crypto_aead_set_reqsize(
crypto/gcm.c:1087:		ALIGN(crypto_aead_reqsize(aead), crypto_tfm_ctx_alignment()) +
crypto/gcm.c:1097:static void crypto_rfc4543_exit_tfm(struct crypto_aead *tfm)
crypto/gcm.c:1099:	struct crypto_rfc4543_ctx *ctx = crypto_aead_ctx(tfm);
crypto/gcm.c:1119:	struct crypto_aead_spawn *spawn;
crypto/gcm.c:1153:	if (crypto_aead_alg_ivsize(alg) != GCM_AES_IV_SIZE)
crypto/gcm.c:1177:	inst->alg.chunksize = crypto_aead_alg_chunksize(alg);
crypto/gcm.c:1178:	inst->alg.maxauthsize = crypto_aead_alg_maxauthsize(alg);
Binary file crypto/gcm.o matches
crypto/morus1280.c:402:static int crypto_morus1280_setkey(struct crypto_aead *aead, const u8 *key,
crypto/morus1280.c:405:	struct morus1280_ctx *ctx = crypto_aead_ctx(aead);
crypto/morus1280.c:416:		crypto_aead_set_flags(aead, CRYPTO_TFM_RES_BAD_KEY_LEN);
crypto/morus1280.c:423:static int crypto_morus1280_setauthsize(struct crypto_aead *tfm,
crypto/morus1280.c:434:	struct crypto_aead *tfm = crypto_aead_reqtfm(req);
crypto/morus1280.c:435:	struct morus1280_ctx *ctx = crypto_aead_ctx(tfm);
crypto/morus1280.c:451:	struct crypto_aead *tfm = crypto_aead_reqtfm(req);
crypto/morus1280.c:454:	unsigned int authsize = crypto_aead_authsize(tfm);
crypto/morus1280.c:473:	struct crypto_aead *tfm = crypto_aead_reqtfm(req);
crypto/morus1280.c:476:	unsigned int authsize = crypto_aead_authsize(tfm);
crypto/morus1280.c:489:static int crypto_morus1280_init_tfm(struct crypto_aead *tfm)
crypto/morus1280.c:494:static void crypto_morus1280_exit_tfm(struct crypto_aead *tfm)
crypto/morus640.c:401:static int crypto_morus640_setkey(struct crypto_aead *aead, const u8 *key,
crypto/morus640.c:404:	struct morus640_ctx *ctx = crypto_aead_ctx(aead);
crypto/morus640.c:407:		crypto_aead_set_flags(aead, CRYPTO_TFM_RES_BAD_KEY_LEN);
crypto/morus640.c:415:static int crypto_morus640_setauthsize(struct crypto_aead *tfm,
crypto/morus640.c:426:	struct crypto_aead *tfm = crypto_aead_reqtfm(req);
crypto/morus640.c:427:	struct morus640_ctx *ctx = crypto_aead_ctx(tfm);
crypto/morus640.c:443:	struct crypto_aead *tfm = crypto_aead_reqtfm(req);
crypto/morus640.c:446:	unsigned int authsize = crypto_aead_authsize(tfm);
crypto/morus640.c:465:	struct crypto_aead *tfm = crypto_aead_reqtfm(req);
crypto/morus640.c:468:	unsigned int authsize = crypto_aead_authsize(tfm);
crypto/morus640.c:481:static int crypto_morus640_init_tfm(struct crypto_aead *tfm)
crypto/morus640.c:486:static void crypto_morus640_exit_tfm(struct crypto_aead *tfm)
crypto/pcrypt.c:64:	struct crypto_aead_spawn spawn;
crypto/pcrypt.c:69:	struct crypto_aead *child;
crypto/pcrypt.c:102:static int pcrypt_aead_setkey(struct crypto_aead *parent,
crypto/pcrypt.c:105:	struct pcrypt_aead_ctx *ctx = crypto_aead_ctx(parent);
crypto/pcrypt.c:107:	return crypto_aead_setkey(ctx->child, key, keylen);
crypto/pcrypt.c:110:static int pcrypt_aead_setauthsize(struct crypto_aead *parent,
crypto/pcrypt.c:113:	struct pcrypt_aead_ctx *ctx = crypto_aead_ctx(parent);
crypto/pcrypt.c:115:	return crypto_aead_setauthsize(ctx->child, authsize);
crypto/pcrypt.c:143:	padata->info = crypto_aead_encrypt(req);
crypto/pcrypt.c:157:	struct crypto_aead *aead = crypto_aead_reqtfm(req);
crypto/pcrypt.c:158:	struct pcrypt_aead_ctx *ctx = crypto_aead_ctx(aead);
crypto/pcrypt.c:185:	padata->info = crypto_aead_decrypt(req);
crypto/pcrypt.c:199:	struct crypto_aead *aead = crypto_aead_reqtfm(req);
crypto/pcrypt.c:200:	struct pcrypt_aead_ctx *ctx = crypto_aead_ctx(aead);
crypto/pcrypt.c:222:static int pcrypt_aead_init_tfm(struct crypto_aead *tfm)
crypto/pcrypt.c:227:	struct pcrypt_aead_ctx *ctx = crypto_aead_ctx(tfm);
crypto/pcrypt.c:228:	struct crypto_aead *cipher;
crypto/pcrypt.c:243:	crypto_aead_set_reqsize(tfm, sizeof(struct pcrypt_request) +
crypto/pcrypt.c:245:				     crypto_aead_reqsize(cipher));
crypto/pcrypt.c:250:static void pcrypt_aead_exit_tfm(struct crypto_aead *tfm)
crypto/pcrypt.c:252:	struct pcrypt_aead_ctx *ctx = crypto_aead_ctx(tfm);
crypto/pcrypt.c:317:	inst->alg.ivsize = crypto_aead_alg_ivsize(alg);
crypto/pcrypt.c:318:	inst->alg.maxauthsize = crypto_aead_alg_maxauthsize(alg);
Binary file crypto/pcrypt.ko matches
Binary file crypto/pcrypt.o matches
crypto/seqiv.c:31:	struct crypto_aead *geniv;
crypto/seqiv.c:39:	geniv = crypto_aead_reqtfm(req);
crypto/seqiv.c:40:	memcpy(req->iv, subreq->iv, crypto_aead_ivsize(geniv));
crypto/seqiv.c:57:	struct crypto_aead *geniv = crypto_aead_reqtfm(req);
crypto/seqiv.c:58:	struct aead_geniv_ctx *ctx = crypto_aead_ctx(geniv);
crypto/seqiv.c:91:				 crypto_aead_alignmask(geniv) + 1))) {
crypto/seqiv.c:110:	err = crypto_aead_encrypt(subreq);
crypto/seqiv.c:118:	struct crypto_aead *geniv = crypto_aead_reqtfm(req);
crypto/seqiv.c:119:	struct aead_geniv_ctx *ctx = crypto_aead_ctx(geniv);
crypto/seqiv.c:125:	if (req->cryptlen < ivsize + crypto_aead_authsize(geniv))
crypto/seqiv.c:140:	return crypto_aead_decrypt(subreq);
Binary file crypto/seqiv.o matches
crypto/simd.c:305:static int simd_aead_setkey(struct crypto_aead *tfm, const u8 *key,
crypto/simd.c:308:	struct simd_aead_ctx *ctx = crypto_aead_ctx(tfm);
crypto/simd.c:309:	struct crypto_aead *child = &ctx->cryptd_tfm->base;
crypto/simd.c:312:	crypto_aead_clear_flags(child, CRYPTO_TFM_REQ_MASK);
crypto/simd.c:313:	crypto_aead_set_flags(child, crypto_aead_get_flags(tfm) &
crypto/simd.c:315:	err = crypto_aead_setkey(child, key, key_len);
crypto/simd.c:316:	crypto_aead_set_flags(tfm, crypto_aead_get_flags(child) &
crypto/simd.c:321:static int simd_aead_setauthsize(struct crypto_aead *tfm, unsigned int authsize)
crypto/simd.c:323:	struct simd_aead_ctx *ctx = crypto_aead_ctx(tfm);
crypto/simd.c:324:	struct crypto_aead *child = &ctx->cryptd_tfm->base;
crypto/simd.c:326:	return crypto_aead_setauthsize(child, authsize);
crypto/simd.c:331:	struct crypto_aead *tfm = crypto_aead_reqtfm(req);
crypto/simd.c:332:	struct simd_aead_ctx *ctx = crypto_aead_ctx(tfm);
crypto/simd.c:334:	struct crypto_aead *child;
crypto/simd.c:347:	return crypto_aead_encrypt(subreq);
crypto/simd.c:352:	struct crypto_aead *tfm = crypto_aead_reqtfm(req);
crypto/simd.c:353:	struct simd_aead_ctx *ctx = crypto_aead_ctx(tfm);
crypto/simd.c:355:	struct crypto_aead *child;
crypto/simd.c:368:	return crypto_aead_decrypt(subreq);
crypto/simd.c:371:static void simd_aead_exit(struct crypto_aead *tfm)
crypto/simd.c:373:	struct simd_aead_ctx *ctx = crypto_aead_ctx(tfm);
crypto/simd.c:378:static int simd_aead_init(struct crypto_aead *tfm)
crypto/simd.c:380:	struct simd_aead_ctx *ctx = crypto_aead_ctx(tfm);
crypto/simd.c:386:	alg = crypto_aead_alg(tfm);
crypto/simd.c:396:	reqsize = crypto_aead_reqsize(cryptd_aead_child(cryptd_tfm));
crypto/simd.c:397:	reqsize = max(reqsize, crypto_aead_reqsize(&cryptd_tfm->base));
crypto/simd.c:400:	crypto_aead_set_reqsize(tfm, reqsize);
crypto/simd.c:410:	struct crypto_aead *tfm;
crypto/simd.c:420:	ialg = crypto_aead_alg(tfm);
Binary file crypto/simd.o matches
crypto/skcipher.c:514:	struct crypto_aead *tfm = crypto_aead_reqtfm(req);
crypto/skcipher.c:540:	walk->blocksize = crypto_aead_blocksize(tfm);
crypto/skcipher.c:541:	walk->stride = crypto_aead_chunksize(tfm);
crypto/skcipher.c:542:	walk->ivsize = crypto_aead_ivsize(tfm);
crypto/skcipher.c:543:	walk->alignmask = crypto_aead_alignmask(tfm);
crypto/skcipher.c:574:	struct crypto_aead *tfm = crypto_aead_reqtfm(req);
crypto/skcipher.c:576:	walk->total = req->cryptlen - crypto_aead_authsize(tfm);
Binary file crypto/skcipher.o matches
crypto/tcrypt.c:169:			rc[i] = crypto_aead_encrypt(data[i].req);
crypto/tcrypt.c:171:			rc[i] = crypto_aead_decrypt(data[i].req);
crypto/tcrypt.c:261:	struct crypto_aead *tfm;
crypto/tcrypt.c:296:	ret = crypto_aead_setauthsize(tfm, authsize);
crypto/tcrypt.c:338:		get_driver_name(crypto_aead, tfm), e);
crypto/tcrypt.c:365:			crypto_aead_clear_flags(tfm, ~0);
crypto/tcrypt.c:367:			ret = crypto_aead_setkey(tfm, key, *keysize);
crypto/tcrypt.c:370:				       crypto_aead_get_flags(tfm));
crypto/tcrypt.c:374:			iv_len = crypto_aead_ivsize(tfm);
crypto/tcrypt.c:402:					ret = crypto_aead_encrypt(cur->req);
crypto/tcrypt.c:468:			ret = do_one_aead_op(req, crypto_aead_encrypt(req));
crypto/tcrypt.c:470:			ret = do_one_aead_op(req, crypto_aead_decrypt(req));
crypto/tcrypt.c:490:			ret = do_one_aead_op(req, crypto_aead_encrypt(req));
crypto/tcrypt.c:492:			ret = do_one_aead_op(req, crypto_aead_decrypt(req));
crypto/tcrypt.c:504:			ret = do_one_aead_op(req, crypto_aead_encrypt(req));
crypto/tcrypt.c:506:			ret = do_one_aead_op(req, crypto_aead_decrypt(req));
crypto/tcrypt.c:529:	struct crypto_aead *tfm;
crypto/tcrypt.c:581:			get_driver_name(crypto_aead, tfm), e);
crypto/tcrypt.c:614:			ret = crypto_aead_setkey(tfm, key, *keysize);
crypto/tcrypt.c:615:			ret = crypto_aead_setauthsize(tfm, authsize);
crypto/tcrypt.c:617:			iv_len = crypto_aead_ivsize(tfm);
crypto/tcrypt.c:621:			crypto_aead_clear_flags(tfm, ~0);
crypto/tcrypt.c:630:						crypto_aead_get_flags(tfm));
crypto/tcrypt.c:653:						     crypto_aead_encrypt(req));
Binary file crypto/tcrypt.ko matches
Binary file crypto/tcrypt.o matches
crypto/testmgr.c:1565:	struct crypto_aead *tfm = crypto_aead_reqtfm(req);
crypto/testmgr.c:1566:	const unsigned int alignmask = crypto_aead_alignmask(tfm);
crypto/testmgr.c:1567:	const unsigned int ivsize = crypto_aead_ivsize(tfm);
crypto/testmgr.c:1582:		crypto_aead_set_flags(tfm, CRYPTO_TFM_REQ_FORBID_WEAK_KEYS);
crypto/testmgr.c:1584:		crypto_aead_clear_flags(tfm, CRYPTO_TFM_REQ_FORBID_WEAK_KEYS);
crypto/testmgr.c:1585:	err = crypto_aead_setkey(tfm, vec->key, vec->klen);
crypto/testmgr.c:1589:		       crypto_aead_get_flags(tfm));
crypto/testmgr.c:1599:	err = crypto_aead_setauthsize(tfm, authsize);
crypto/testmgr.c:1640:	testmgr_poison(req->__ctx, crypto_aead_reqsize(tfm));
crypto/testmgr.c:1647:	err = enc ? crypto_aead_encrypt(req) : crypto_aead_decrypt(req);
crypto/testmgr.c:1658:	    crypto_aead_reqtfm(req) != tfm ||
crypto/testmgr.c:1674:		if (crypto_aead_reqtfm(req) != tfm)
crypto/testmgr.c:1780:	struct crypto_aead *tfm = crypto_aead_reqtfm(req);
crypto/testmgr.c:1781:	const unsigned int ivsize = crypto_aead_ivsize(tfm);
crypto/testmgr.c:1782:	unsigned int maxauthsize = crypto_aead_alg(tfm)->maxauthsize;
crypto/testmgr.c:1795:	vec->setkey_error = crypto_aead_setkey(tfm, vec->key, vec->klen);
crypto/testmgr.c:1807:	vec->setauthsize_error = crypto_aead_setauthsize(tfm, authsize);
crypto/testmgr.c:1840:	vec->crypt_error = crypto_wait_req(crypto_aead_encrypt(req), &wait);
crypto/testmgr.c:1858:	struct crypto_aead *tfm = crypto_aead_reqtfm(req);
crypto/testmgr.c:1859:	const unsigned int ivsize = crypto_aead_ivsize(tfm);
crypto/testmgr.c:1860:	const unsigned int maxauthsize = crypto_aead_alg(tfm)->maxauthsize;
crypto/testmgr.c:1861:	const unsigned int blocksize = crypto_aead_blocksize(tfm);
crypto/testmgr.c:1863:	const char *algname = crypto_aead_alg(tfm)->base.cra_name;
crypto/testmgr.c:1866:	struct crypto_aead *generic_tfm = NULL;
crypto/testmgr.c:1910:	if (maxauthsize != crypto_aead_alg(generic_tfm)->maxauthsize) {
crypto/testmgr.c:1913:		       crypto_aead_alg(generic_tfm)->maxauthsize);
crypto/testmgr.c:1918:	if (ivsize != crypto_aead_ivsize(generic_tfm)) {
crypto/testmgr.c:1920:		       driver, ivsize, crypto_aead_ivsize(generic_tfm));
crypto/testmgr.c:1925:	if (blocksize != crypto_aead_blocksize(generic_tfm)) {
crypto/testmgr.c:1927:		       driver, blocksize, crypto_aead_blocksize(generic_tfm));
crypto/testmgr.c:2010:	struct crypto_aead *tfm;
crypto/testmgr.h:19057: *   (see crypto_aead/aegis128/)
crypto/testmgr.h:19501: *   (see crypto_aead/aegis128l/)
crypto/testmgr.h:19945: *   (see crypto_aead/aegis256/)
crypto/testmgr.h:20485: *   (see crypto_aead/morus640128v2/)
crypto/testmgr.h:20945: *   (see crypto_aead/morus1280128v2/ and crypto_aead/morus1280256v2/ ) 
crypto/ahash.c:39:static inline struct ahash_alg *crypto_ahash_alg(struct crypto_ahash *hash)
crypto/ahash.c:144:	walk->alignmask = crypto_ahash_alignmask(crypto_ahash_reqtfm(req));
crypto/ahash.c:152:int crypto_ahash_walk_first(struct ahash_request *req,
crypto/ahash.c:162:	walk->alignmask = crypto_ahash_alignmask(crypto_ahash_reqtfm(req));
crypto/ahash.c:171:EXPORT_SYMBOL_GPL(crypto_ahash_walk_first);
crypto/ahash.c:173:static int ahash_setkey_unaligned(struct crypto_ahash *tfm, const u8 *key,
crypto/ahash.c:176:	unsigned long alignmask = crypto_ahash_alignmask(tfm);
crypto/ahash.c:193:static int ahash_nosetkey(struct crypto_ahash *tfm, const u8 *key,
crypto/ahash.c:199:static void ahash_set_needkey(struct crypto_ahash *tfm)
crypto/ahash.c:205:		crypto_ahash_set_flags(tfm, CRYPTO_TFM_NEED_KEY);
crypto/ahash.c:208:int crypto_ahash_setkey(struct crypto_ahash *tfm, const u8 *key,
crypto/ahash.c:211:	unsigned long alignmask = crypto_ahash_alignmask(tfm);
crypto/ahash.c:224:	crypto_ahash_clear_flags(tfm, CRYPTO_TFM_NEED_KEY);
crypto/ahash.c:227:EXPORT_SYMBOL_GPL(crypto_ahash_setkey);
crypto/ahash.c:237:	struct crypto_ahash *tfm = crypto_ahash_reqtfm(req);
crypto/ahash.c:238:	unsigned long alignmask = crypto_ahash_alignmask(tfm);
crypto/ahash.c:239:	unsigned int ds = crypto_ahash_digestsize(tfm);
crypto/ahash.c:298:		       crypto_ahash_digestsize(crypto_ahash_reqtfm(req)));
crypto/ahash.c:364:static int crypto_ahash_op(struct ahash_request *req,
crypto/ahash.c:367:	struct crypto_ahash *tfm = crypto_ahash_reqtfm(req);
crypto/ahash.c:368:	unsigned long alignmask = crypto_ahash_alignmask(tfm);
crypto/ahash.c:376:int crypto_ahash_final(struct ahash_request *req)
crypto/ahash.c:378:	struct crypto_ahash *tfm = crypto_ahash_reqtfm(req);
crypto/ahash.c:384:	ret = crypto_ahash_op(req, crypto_ahash_reqtfm(req)->final);
crypto/ahash.c:388:EXPORT_SYMBOL_GPL(crypto_ahash_final);
crypto/ahash.c:390:int crypto_ahash_finup(struct ahash_request *req)
crypto/ahash.c:392:	struct crypto_ahash *tfm = crypto_ahash_reqtfm(req);
crypto/ahash.c:398:	ret = crypto_ahash_op(req, crypto_ahash_reqtfm(req)->finup);
crypto/ahash.c:402:EXPORT_SYMBOL_GPL(crypto_ahash_finup);
crypto/ahash.c:404:int crypto_ahash_digest(struct ahash_request *req)
crypto/ahash.c:406:	struct crypto_ahash *tfm = crypto_ahash_reqtfm(req);
crypto/ahash.c:412:	if (crypto_ahash_get_flags(tfm) & CRYPTO_TFM_NEED_KEY)
crypto/ahash.c:415:		ret = crypto_ahash_op(req, tfm->digest);
crypto/ahash.c:419:EXPORT_SYMBOL_GPL(crypto_ahash_digest);
crypto/ahash.c:440:	err = crypto_ahash_reqtfm(req)->final(req);
crypto/ahash.c:469:	struct crypto_ahash *tfm = crypto_ahash_reqtfm(req);
crypto/ahash.c:483:static int crypto_ahash_init_tfm(struct crypto_tfm *tfm)
crypto/ahash.c:485:	struct crypto_ahash *hash = __crypto_ahash_cast(tfm);
crypto/ahash.c:486:	struct ahash_alg *alg = crypto_ahash_alg(hash);
crypto/ahash.c:490:	if (tfm->__crt_alg->cra_type != &crypto_ahash_type)
crypto/ahash.c:509:static unsigned int crypto_ahash_extsize(struct crypto_alg *alg)
crypto/ahash.c:511:	if (alg->cra_type != &crypto_ahash_type)
crypto/ahash.c:518:static int crypto_ahash_report(struct sk_buff *skb, struct crypto_alg *alg)
crypto/ahash.c:532:static int crypto_ahash_report(struct sk_buff *skb, struct crypto_alg *alg)
crypto/ahash.c:538:static void crypto_ahash_show(struct seq_file *m, struct crypto_alg *alg)
crypto/ahash.c:540:static void crypto_ahash_show(struct seq_file *m, struct crypto_alg *alg)
crypto/ahash.c:550:const struct crypto_type crypto_ahash_type = {
crypto/ahash.c:551:	.extsize = crypto_ahash_extsize,
crypto/ahash.c:552:	.init_tfm = crypto_ahash_init_tfm,
crypto/ahash.c:554:	.show = crypto_ahash_show,
crypto/ahash.c:556:	.report = crypto_ahash_report,
crypto/ahash.c:560:	.tfmsize = offsetof(struct crypto_ahash, base),
crypto/ahash.c:562:EXPORT_SYMBOL_GPL(crypto_ahash_type);
crypto/ahash.c:564:struct crypto_ahash *crypto_alloc_ahash(const char *alg_name, u32 type,
crypto/ahash.c:567:	return crypto_alloc_tfm(alg_name, &crypto_ahash_type, type, mask);
crypto/ahash.c:573:	return crypto_type_has_alg(alg_name, &crypto_ahash_type, type, mask);
crypto/ahash.c:586:	base->cra_type = &crypto_ahash_type;
crypto/ahash.c:661:int crypto_init_ahash_spawn(struct crypto_ahash_spawn *spawn,
crypto/ahash.c:666:				  &crypto_ahash_type);
crypto/ahash.c:674:	alg = crypto_attr_alg2(rta, &crypto_ahash_type, type, mask);
crypto/ahash.c:683:	if (alg->cra_type != &crypto_ahash_type)
crypto/ahash.c:686:	return __crypto_ahash_alg(alg)->setkey != NULL;
Binary file crypto/ahash.o matches
crypto/algif_hash.c:44:	ds = crypto_ahash_digestsize(crypto_ahash_reqtfm(&ctx->req));
crypto/algif_hash.c:62:	ds = crypto_ahash_digestsize(crypto_ahash_reqtfm(&ctx->req));
crypto/algif_hash.c:86:		err = crypto_wait_req(crypto_ahash_init(&ctx->req), &ctx->wait);
crypto/algif_hash.c:107:		err = crypto_wait_req(crypto_ahash_update(&ctx->req),
crypto/algif_hash.c:126:		err = crypto_wait_req(crypto_ahash_final(&ctx->req),
crypto/algif_hash.c:162:			err = crypto_ahash_finup(&ctx->req);
crypto/algif_hash.c:164:			err = crypto_ahash_digest(&ctx->req);
crypto/algif_hash.c:167:			err = crypto_ahash_init(&ctx->req);
crypto/algif_hash.c:173:		err = crypto_ahash_update(&ctx->req);
crypto/algif_hash.c:194:	unsigned ds = crypto_ahash_digestsize(crypto_ahash_reqtfm(&ctx->req));
crypto/algif_hash.c:212:		err = crypto_wait_req(crypto_ahash_init(&ctx->req),
crypto/algif_hash.c:220:		err = crypto_wait_req(crypto_ahash_final(&ctx->req),
crypto/algif_hash.c:251:	err = more ? crypto_ahash_export(req, state) : 0;
crypto/algif_hash.c:269:	err = crypto_ahash_import(&ctx2->req, state);
crypto/algif_hash.c:304:	struct crypto_ahash *tfm;
crypto/algif_hash.c:318:	if (crypto_ahash_get_flags(tfm) & CRYPTO_TFM_NEED_KEY)
crypto/algif_hash.c:418:	return crypto_ahash_setkey(private, key, keylen);
crypto/algif_hash.c:433:	struct crypto_ahash *tfm = private;
crypto/algif_hash.c:436:	unsigned int len = sizeof(*ctx) + crypto_ahash_reqsize(tfm);
crypto/algif_hash.c:460:	struct crypto_ahash *tfm = private;
crypto/algif_hash.c:462:	if (crypto_ahash_get_flags(tfm) & CRYPTO_TFM_NEED_KEY)
crypto/authenc.c:28:	struct crypto_ahash_spawn auth;
crypto/authenc.c:34:	struct crypto_ahash *auth;
crypto/authenc.c:93:	struct crypto_ahash *auth = ctx->auth;
crypto/authenc.c:101:	crypto_ahash_clear_flags(auth, CRYPTO_TFM_REQ_MASK);
crypto/authenc.c:102:	crypto_ahash_set_flags(auth, crypto_aead_get_flags(authenc) &
crypto/authenc.c:104:	err = crypto_ahash_setkey(auth, keys.authkey, keys.authkeylen);
crypto/authenc.c:105:	crypto_aead_set_flags(authenc, crypto_ahash_get_flags(auth) &
crypto/authenc.c:153:	struct crypto_ahash *auth = ctx->auth;
crypto/authenc.c:159:	hash = (u8 *)ALIGN((unsigned long)hash + crypto_ahash_alignmask(auth),
crypto/authenc.c:160:			   crypto_ahash_alignmask(auth) + 1);
crypto/authenc.c:168:	err = crypto_ahash_digest(ahreq);
crypto/authenc.c:300:	struct crypto_ahash *auth = ctx->auth;
crypto/authenc.c:306:	hash = (u8 *)ALIGN((unsigned long)hash + crypto_ahash_alignmask(auth),
crypto/authenc.c:307:			   crypto_ahash_alignmask(auth) + 1);
crypto/authenc.c:315:	err = crypto_ahash_digest(ahreq);
crypto/authenc.c:327:	struct crypto_ahash *auth;
crypto/authenc.c:355:		      crypto_ahash_reqsize(auth) +
crypto/authencesn.c:31:	struct crypto_ahash_spawn auth;
crypto/authencesn.c:37:	struct crypto_ahash *auth;
crypto/authencesn.c:67:	struct crypto_ahash *auth = ctx->auth;
crypto/authencesn.c:75:	crypto_ahash_clear_flags(auth, CRYPTO_TFM_REQ_MASK);
crypto/authencesn.c:76:	crypto_ahash_set_flags(auth, crypto_aead_get_flags(authenc_esn) &
crypto/authencesn.c:78:	err = crypto_ahash_setkey(auth, keys.authkey, keys.authkeylen);
crypto/authencesn.c:79:	crypto_aead_set_flags(authenc_esn, crypto_ahash_get_flags(auth) &
crypto/authencesn.c:107:	struct crypto_ahash *auth = ctx->auth;
crypto/authencesn.c:109:			     crypto_ahash_alignmask(auth) + 1);
crypto/authencesn.c:140:	struct crypto_ahash *auth = ctx->auth;
crypto/authencesn.c:142:			     crypto_ahash_alignmask(auth) + 1);
crypto/authencesn.c:166:	return crypto_ahash_digest(ahreq) ?:
crypto/authencesn.c:243:	struct crypto_ahash *auth = ctx->auth;
crypto/authencesn.c:245:			      crypto_ahash_alignmask(auth) + 1);
crypto/authencesn.c:249:	u8 *ihash = ohash + crypto_ahash_digestsize(auth);
crypto/authencesn.c:292:	struct crypto_ahash *auth = ctx->auth;
crypto/authencesn.c:294:			      crypto_ahash_alignmask(auth) + 1);
crypto/authencesn.c:297:	u8 *ihash = ohash + crypto_ahash_digestsize(auth);
crypto/authencesn.c:329:	err = crypto_ahash_digest(ahreq);
crypto/authencesn.c:342:	struct crypto_ahash *auth;
crypto/authencesn.c:365:	ctx->reqoff = ALIGN(2 * crypto_ahash_digestsize(auth),
crypto/authencesn.c:366:			    crypto_ahash_alignmask(auth) + 1);
crypto/authencesn.c:373:		      crypto_ahash_reqsize(auth) +
crypto/ccm.c:27:	struct crypto_ahash_spawn mac;
crypto/ccm.c:31:	struct crypto_ahash *mac;
crypto/ccm.c:98:	struct crypto_ahash *mac = ctx->mac;
crypto/ccm.c:110:	crypto_ahash_clear_flags(mac, CRYPTO_TFM_REQ_MASK);
crypto/ccm.c:111:	crypto_ahash_set_flags(mac, crypto_aead_get_flags(aead) &
crypto/ccm.c:113:	err = crypto_ahash_setkey(mac, key, keylen);
crypto/ccm.c:114:	crypto_aead_set_flags(aead, crypto_ahash_get_flags(mac) &
crypto/ccm.c:215:	err = crypto_ahash_init(ahreq);
crypto/ccm.c:218:	err = crypto_ahash_update(ahreq);
crypto/ccm.c:235:	err = crypto_ahash_finup(ahreq);
crypto/ccm.c:411:	struct crypto_ahash *mac;
crypto/ccm.c:433:		max(crypto_ahash_reqsize(mac), crypto_skcipher_reqsize(ctr)));
crypto/ccm.c:479:	mac_alg = crypto_find_alg(mac_name, &crypto_ahash_type,
Binary file crypto/ccm.ko matches
Binary file crypto/ccm.o matches
crypto/chacha20poly1305.c:27:	struct crypto_ahash_spawn poly;
crypto/chacha20poly1305.c:33:	struct crypto_ahash *poly;
crypto/chacha20poly1305.c:195:	err = crypto_ahash_finup(&preq->req);
crypto/chacha20poly1305.c:225:	err = crypto_ahash_update(&preq->req);
crypto/chacha20poly1305.c:256:	err = crypto_ahash_update(&preq->req);
crypto/chacha20poly1305.c:286:	err = crypto_ahash_update(&preq->req);
crypto/chacha20poly1305.c:310:	err = crypto_ahash_update(&preq->req);
crypto/chacha20poly1305.c:337:	err = crypto_ahash_update(&preq->req);
crypto/chacha20poly1305.c:360:	err = crypto_ahash_init(&preq->req);
crypto/chacha20poly1305.c:526:	struct crypto_ahash *poly;
crypto/chacha20poly1305.c:553:		    crypto_ahash_reqsize(poly)));
crypto/chacha20poly1305.c:604:	poly = crypto_find_alg(poly_name, &crypto_ahash_type,
Binary file crypto/chacha20poly1305.ko matches
Binary file crypto/chacha20poly1305.o matches
Binary file crypto/cmac.ko matches
Binary file crypto/cmac.o matches
Binary file crypto/crc32c_generic.o matches
Binary file crypto/crc32_generic.ko matches
Binary file crypto/crc32_generic.o matches
Binary file crypto/crct10dif_generic.o matches
crypto/cryptd.c:478:	crypto_ahash_set_reqsize(__crypto_ahash_cast(tfm),
crypto/cryptd.c:491:static int cryptd_hash_setkey(struct crypto_ahash *parent,
crypto/cryptd.c:494:	struct cryptd_hash_ctx *ctx   = crypto_ahash_ctx(parent);
crypto/cryptd.c:499:	crypto_shash_set_flags(child, crypto_ahash_get_flags(parent) &
crypto/cryptd.c:502:	crypto_ahash_set_flags(parent, crypto_shash_get_flags(child) &
crypto/cryptd.c:511:	struct crypto_ahash *tfm = crypto_ahash_reqtfm(req);
crypto/cryptd.c:513:		cryptd_get_queue(crypto_ahash_tfm(tfm));
crypto/cryptd.c:523:	struct crypto_ahash *tfm = crypto_ahash_reqtfm(req);
crypto/cryptd.c:524:	struct cryptd_hash_ctx *ctx = crypto_ahash_ctx(tfm);
crypto/cryptd.c:662:	struct crypto_ahash *tfm = crypto_ahash_reqtfm(req);
crypto/cryptd.c:663:	struct cryptd_hash_ctx *ctx = crypto_ahash_ctx(tfm);
crypto/cryptd.c:1020:	struct crypto_ahash *tfm;
crypto/cryptd.c:1033:	ctx = crypto_ahash_ctx(tfm);
crypto/cryptd.c:1042:	struct cryptd_hash_ctx *ctx = crypto_ahash_ctx(&tfm->base);
crypto/cryptd.c:1057:	struct cryptd_hash_ctx *ctx = crypto_ahash_ctx(&tfm->base);
crypto/cryptd.c:1065:	struct cryptd_hash_ctx *ctx = crypto_ahash_ctx(&tfm->base);
Binary file crypto/cryptd.ko matches
Binary file crypto/cryptd.o matches
Binary file crypto/crypto_null.o matches
crypto/gcm.c:28:	struct crypto_ahash_spawn ghash;
crypto/gcm.c:33:	struct crypto_ahash *ghash;
crypto/gcm.c:100:	struct crypto_ahash *ghash = ctx->ghash;
crypto/gcm.c:143:	crypto_ahash_clear_flags(ghash, CRYPTO_TFM_REQ_MASK);
crypto/gcm.c:144:	crypto_ahash_set_flags(ghash, crypto_aead_get_flags(aead) &
crypto/gcm.c:146:	err = crypto_ahash_setkey(ghash, (u8 *)&data->hash, sizeof(be128));
crypto/gcm.c:147:	crypto_aead_set_flags(aead, crypto_ahash_get_flags(ghash) &
crypto/gcm.c:235:	return crypto_ahash_update(ahreq);
crypto/gcm.c:260:	return crypto_ahash_finup(ahreq);
crypto/gcm.c:429:	return crypto_ahash_init(ahreq) ?:
crypto/gcm.c:549:	struct crypto_ahash *ghash;
crypto/gcm.c:572:		    crypto_ahash_reqsize(ghash)));
crypto/gcm.c:618:	ghash_alg = crypto_find_alg(ghash_name, &crypto_ahash_type,
Binary file crypto/gcm.o matches
Binary file crypto/ghash-generic.o matches
Binary file crypto/hmac.o matches
Binary file crypto/md4.ko matches
Binary file crypto/md4.o matches
Binary file crypto/md5.o matches
Binary file crypto/michael_mic.ko matches
Binary file crypto/michael_mic.o matches
Binary file crypto/poly1305_generic.ko matches
Binary file crypto/poly1305_generic.o matches
Binary file crypto/rmd128.ko matches
Binary file crypto/rmd128.o matches
Binary file crypto/rmd160.ko matches
Binary file crypto/rmd160.o matches
Binary file crypto/rmd256.ko matches
Binary file crypto/rmd256.o matches
Binary file crypto/rmd320.ko matches
Binary file crypto/rmd320.o matches
Binary file crypto/sha1_generic.o matches
Binary file crypto/sha256_generic.o matches
Binary file crypto/sha3_generic.ko matches
Binary file crypto/sha3_generic.o matches
Binary file crypto/sha512_generic.o matches
crypto/shash.c:227:static int shash_async_setkey(struct crypto_ahash *tfm, const u8 *key,
crypto/shash.c:230:	struct crypto_shash **ctx = crypto_ahash_ctx(tfm);
crypto/shash.c:237:	struct crypto_shash **ctx = crypto_ahash_ctx(crypto_ahash_reqtfm(req));
crypto/shash.c:291:	struct crypto_shash **ctx = crypto_ahash_ctx(crypto_ahash_reqtfm(req));
crypto/shash.c:325:	struct crypto_shash **ctx = crypto_ahash_ctx(crypto_ahash_reqtfm(req));
crypto/shash.c:340:	struct crypto_shash **ctx = crypto_ahash_ctx(crypto_ahash_reqtfm(req));
crypto/shash.c:359:	struct crypto_ahash *crt = __crypto_ahash_cast(tfm);
crypto/shash.c:383:	crypto_ahash_set_flags(crt, crypto_shash_get_flags(shash) &
Binary file crypto/shash.o matches
Binary file crypto/sm3_generic.ko matches
Binary file crypto/sm3_generic.o matches
crypto/tcrypt.c:733:		rc[i] = crypto_ahash_digest(data[i].req);
crypto/tcrypt.c:820:	struct crypto_ahash *tfm;
crypto/tcrypt.c:859:		get_driver_name(crypto_ahash, tfm));
crypto/tcrypt.c:873:			crypto_ahash_setkey(tfm, tvmem[0], speed[i].klen);
crypto/tcrypt.c:921:		ret = do_one_ahash_op(req, crypto_ahash_digest(req));
crypto/tcrypt.c:944:		ret = do_one_ahash_op(req, crypto_ahash_init(req));
crypto/tcrypt.c:948:			ret = do_one_ahash_op(req, crypto_ahash_update(req));
crypto/tcrypt.c:953:		ret = do_one_ahash_op(req, crypto_ahash_final(req));
crypto/tcrypt.c:972:		ret = do_one_ahash_op(req, crypto_ahash_digest(req));
crypto/tcrypt.c:983:		ret = do_one_ahash_op(req, crypto_ahash_digest(req));
crypto/tcrypt.c:1013:		ret = do_one_ahash_op(req, crypto_ahash_init(req));
crypto/tcrypt.c:1017:			ret = do_one_ahash_op(req, crypto_ahash_update(req));
crypto/tcrypt.c:1021:		ret = do_one_ahash_op(req, crypto_ahash_final(req));
crypto/tcrypt.c:1032:		ret = do_one_ahash_op(req, crypto_ahash_init(req));
crypto/tcrypt.c:1036:			ret = do_one_ahash_op(req, crypto_ahash_update(req));
crypto/tcrypt.c:1040:		ret = do_one_ahash_op(req, crypto_ahash_final(req));
crypto/tcrypt.c:1065:	struct crypto_ahash *tfm;
crypto/tcrypt.c:1077:			get_driver_name(crypto_ahash, tfm));
crypto/tcrypt.c:1079:	if (crypto_ahash_digestsize(tfm) > MAX_DIGEST_SIZE) {
crypto/tcrypt.c:1080:		pr_err("digestsize(%u) > %d\n", crypto_ahash_digestsize(tfm),
crypto/tcrypt.c:1108:			crypto_ahash_setkey(tfm, tvmem[0], speed[i].klen);
Binary file crypto/tcrypt.ko matches
Binary file crypto/tcrypt.o matches
crypto/testmgr.c:1083:	struct crypto_ahash *tfm = crypto_ahash_reqtfm(req);
crypto/testmgr.c:1084:	const unsigned int alignmask = crypto_ahash_alignmask(tfm);
crypto/testmgr.c:1085:	const unsigned int digestsize = crypto_ahash_digestsize(tfm);
crypto/testmgr.c:1086:	const unsigned int statesize = crypto_ahash_statesize(tfm);
crypto/testmgr.c:1100:		err = crypto_ahash_setkey(tfm, vec->key, vec->ksize);
crypto/testmgr.c:1106:			       crypto_ahash_get_flags(tfm));
crypto/testmgr.c:1130:	testmgr_poison(req->__ctx, crypto_ahash_reqsize(tfm));
crypto/testmgr.c:1139:		err = do_ahash_op(crypto_ahash_digest, req, &wait, cfg->nosimd);
crypto/testmgr.c:1160:	err = do_ahash_op(crypto_ahash_init, req, &wait, cfg->nosimd);
crypto/testmgr.c:1176:			err = do_ahash_op(crypto_ahash_update, req, &wait,
crypto/testmgr.c:1190:			err = crypto_ahash_export(req, hashstate);
crypto/testmgr.c:1203:			testmgr_poison(req->__ctx, crypto_ahash_reqsize(tfm));
crypto/testmgr.c:1204:			err = crypto_ahash_import(req, hashstate);
crypto/testmgr.c:1220:		err = do_ahash_op(crypto_ahash_update, req, &wait, cfg->nosimd);
crypto/testmgr.c:1225:		err = do_ahash_op(crypto_ahash_final, req, &wait, cfg->nosimd);
crypto/testmgr.c:1233:		err = do_ahash_op(crypto_ahash_finup, req, &wait, cfg->nosimd);
crypto/testmgr.c:1349:	struct crypto_ahash *tfm = crypto_ahash_reqtfm(req);
crypto/testmgr.c:1350:	const unsigned int digestsize = crypto_ahash_digestsize(tfm);
crypto/testmgr.c:1351:	const unsigned int blocksize = crypto_ahash_blocksize(tfm);
crypto/testmgr.c:1456:	struct crypto_ahash *tfm;
crypto/testmgr.c:1488:	hashstate = kmalloc(crypto_ahash_statesize(tfm) + TESTMGR_POISON_LEN,
 


crypto/adiantum.c:28: * to wrap with the crypto_shash API.  Rather, some details need to be handled
crypto/adiantum.c:67:	struct crypto_shash_spawn hash_spawn;
crypto/adiantum.c:73:	struct crypto_shash *hash;
crypto/adiantum.c:180:	crypto_shash_clear_flags(tctx->hash, CRYPTO_TFM_REQ_MASK);
crypto/adiantum.c:181:	crypto_shash_set_flags(tctx->hash, crypto_skcipher_get_flags(tfm) &
crypto/adiantum.c:183:	err = crypto_shash_setkey(tctx->hash, keyp, NHPOLY1305_KEY_SIZE);
crypto/adiantum.c:184:	crypto_skcipher_set_flags(tfm, crypto_shash_get_flags(tctx->hash) &
crypto/adiantum.c:269:	err = crypto_shash_init(hash_desc);
crypto/adiantum.c:278:		err = crypto_shash_update(hash_desc, miter.addr, n);
crypto/adiantum.c:286:	return crypto_shash_final(hash_desc, (u8 *)digest);
crypto/adiantum.c:412:	struct crypto_shash *hash;
crypto/adiantum.c:440:			  crypto_shash_descsize(hash),
crypto/adiantum.c:567:	hash_alg = __crypto_shash_alg(_hash_alg);
crypto/ahash.c:512:		return sizeof(struct crypto_shash *);
crypto/ahash.c:684:		return crypto_shash_alg_has_setkey(__crypto_shash_alg(alg));
Binary file crypto/ahash.o matches
grep: crypto/asymmetric_keys: Is a directory
grep: crypto/async_tx: Is a directory
crypto/ccm.c:837:static int crypto_cbcmac_digest_setkey(struct crypto_shash *parent,
crypto/ccm.c:840:	struct cbcmac_tfm_ctx *ctx = crypto_shash_ctx(parent);
crypto/ccm.c:848:	int bs = crypto_shash_digestsize(pdesc->tfm);
crypto/ccm.c:849:	u8 *dg = (u8 *)ctx + crypto_shash_descsize(pdesc->tfm) - bs;
crypto/ccm.c:860:	struct crypto_shash *parent = pdesc->tfm;
crypto/ccm.c:861:	struct cbcmac_tfm_ctx *tctx = crypto_shash_ctx(parent);
crypto/ccm.c:864:	int bs = crypto_shash_digestsize(parent);
crypto/ccm.c:865:	u8 *dg = (u8 *)ctx + crypto_shash_descsize(parent) - bs;
crypto/ccm.c:886:	struct crypto_shash *parent = pdesc->tfm;
crypto/ccm.c:887:	struct cbcmac_tfm_ctx *tctx = crypto_shash_ctx(parent);
crypto/ccm.c:890:	int bs = crypto_shash_digestsize(parent);
crypto/ccm.c:891:	u8 *dg = (u8 *)ctx + crypto_shash_descsize(parent) - bs;
Binary file crypto/ccm.ko matches
Binary file crypto/ccm.o matches
crypto/cmac.c:54:static int crypto_cmac_digest_setkey(struct crypto_shash *parent,
crypto/cmac.c:57:	unsigned long alignmask = crypto_shash_alignmask(parent);
crypto/cmac.c:58:	struct cmac_tfm_ctx *ctx = crypto_shash_ctx(parent);
crypto/cmac.c:59:	unsigned int bs = crypto_shash_blocksize(parent);
crypto/cmac.c:111:	unsigned long alignmask = crypto_shash_alignmask(pdesc->tfm);
crypto/cmac.c:113:	int bs = crypto_shash_blocksize(pdesc->tfm);
crypto/cmac.c:125:	struct crypto_shash *parent = pdesc->tfm;
crypto/cmac.c:126:	unsigned long alignmask = crypto_shash_alignmask(parent);
crypto/cmac.c:127:	struct cmac_tfm_ctx *tctx = crypto_shash_ctx(parent);
crypto/cmac.c:130:	int bs = crypto_shash_blocksize(parent);
crypto/cmac.c:171:	struct crypto_shash *parent = pdesc->tfm;
crypto/cmac.c:172:	unsigned long alignmask = crypto_shash_alignmask(parent);
crypto/cmac.c:173:	struct cmac_tfm_ctx *tctx = crypto_shash_ctx(parent);
crypto/cmac.c:176:	int bs = crypto_shash_blocksize(parent);
crypto/crc32c_generic.c:64:	struct chksum_ctx *mctx = crypto_shash_ctx(desc->tfm);
crypto/crc32c_generic.c:77:static int chksum_setkey(struct crypto_shash *tfm, const u8 *key,
crypto/crc32c_generic.c:80:	struct chksum_ctx *mctx = crypto_shash_ctx(tfm);
crypto/crc32c_generic.c:83:		crypto_shash_set_flags(tfm, CRYPTO_TFM_RES_BAD_KEY_LEN);
crypto/crc32c_generic.c:124:	struct chksum_ctx *mctx = crypto_shash_ctx(desc->tfm);
Binary file crypto/crc32c_generic.o matches
crypto/crc32_generic.c:58:static int crc32_setkey(struct crypto_shash *hash, const u8 *key,
crypto/crc32_generic.c:61:	u32 *mctx = crypto_shash_ctx(hash);
crypto/crc32_generic.c:64:		crypto_shash_set_flags(hash, CRYPTO_TFM_RES_BAD_KEY_LEN);
crypto/crc32_generic.c:73:	u32 *mctx = crypto_shash_ctx(desc->tfm);
crypto/crc32_generic.c:115:	return __crc32_finup(crypto_shash_ctx(desc->tfm), data, len,
crypto/cryptd.c:59:	struct crypto_shash_spawn spawn;
crypto/cryptd.c:79:	struct crypto_shash *child;
crypto/cryptd.c:469:	struct crypto_shash_spawn *spawn = &ictx->spawn;
crypto/cryptd.c:471:	struct crypto_shash *hash;
crypto/cryptd.c:480:				 crypto_shash_descsize(hash));
crypto/cryptd.c:495:	struct crypto_shash *child = ctx->child;
crypto/cryptd.c:498:	crypto_shash_clear_flags(child, CRYPTO_TFM_REQ_MASK);
crypto/cryptd.c:499:	crypto_shash_set_flags(child, crypto_ahash_get_flags(parent) &
crypto/cryptd.c:501:	err = crypto_shash_setkey(child, key, keylen);
crypto/cryptd.c:502:	crypto_ahash_set_flags(parent, crypto_shash_get_flags(child) &
crypto/cryptd.c:539:	struct crypto_shash *child = ctx->child;
crypto/cryptd.c:549:	err = crypto_shash_init(desc);
crypto/cryptd.c:593:	err = crypto_shash_final(&rctx->desc, req->result);
crypto/cryptd.c:630:	struct crypto_shash *child = ctx->child;
crypto/cryptd.c:657:	return crypto_shash_export(&rctx->desc, out);
crypto/cryptd.c:668:	return crypto_shash_import(desc, in);
crypto/cryptd.c:720:	if (crypto_shash_alg_has_setkey(salg))
crypto/cryptd.c:1040:struct crypto_shash *cryptd_ahash_child(struct cryptd_ahash *tfm)
Binary file crypto/cryptd.ko matches
Binary file crypto/cryptd.o matches
crypto/crypto_null.c:64:static int null_hash_setkey(struct crypto_shash *tfm, const u8 *key,
Binary file crypto/crypto_null.o matches
crypto/drbg.c:1573:	struct crypto_shash *tfm;
crypto/drbg.c:1581:	BUG_ON(drbg_blocklen(drbg) != crypto_shash_digestsize(tfm));
crypto/drbg.c:1582:	sdesc = kzalloc(sizeof(struct shash_desc) + crypto_shash_descsize(tfm),
crypto/drbg.c:1592:	return crypto_shash_alignmask(tfm);
crypto/drbg.c:1611:	crypto_shash_setkey(sdesc->shash.tfm, key, drbg_statelen(drbg));
crypto/drbg.c:1620:	crypto_shash_init(&sdesc->shash);
crypto/drbg.c:1622:		crypto_shash_update(&sdesc->shash, input->buf, input->len);
crypto/drbg.c:1623:	return crypto_shash_final(&sdesc->shash, outval);
Binary file crypto/drbg.o matches
crypto/ghash-generic.c:33:static int ghash_setkey(struct crypto_shash *tfm,
crypto/ghash-generic.c:36:	struct ghash_ctx *ctx = crypto_shash_ctx(tfm);
crypto/ghash-generic.c:39:		crypto_shash_set_flags(tfm, CRYPTO_TFM_RES_BAD_KEY_LEN);
crypto/ghash-generic.c:56:	struct ghash_ctx *ctx = crypto_shash_ctx(desc->tfm);
crypto/ghash-generic.c:108:	struct ghash_ctx *ctx = crypto_shash_ctx(desc->tfm);
Binary file crypto/ghash-generic.o matches
crypto/hmac.c:30:	struct crypto_shash *hash;
crypto/hmac.c:38:static inline struct hmac_ctx *hmac_ctx(struct crypto_shash *tfm)
crypto/hmac.c:40:	return align_ptr(crypto_shash_ctx_aligned(tfm) +
crypto/hmac.c:41:			 crypto_shash_statesize(tfm) * 2,
crypto/hmac.c:45:static int hmac_setkey(struct crypto_shash *parent,
crypto/hmac.c:48:	int bs = crypto_shash_blocksize(parent);
crypto/hmac.c:49:	int ds = crypto_shash_digestsize(parent);
crypto/hmac.c:50:	int ss = crypto_shash_statesize(parent);
crypto/hmac.c:51:	char *ipad = crypto_shash_ctx_aligned(parent);
crypto/hmac.c:55:	struct crypto_shash *hash = ctx->hash;
crypto/hmac.c:64:		err = crypto_shash_digest(shash, inkey, keylen, ipad);
crypto/hmac.c:80:	return crypto_shash_init(shash) ?:
crypto/hmac.c:81:	       crypto_shash_update(shash, ipad, bs) ?:
crypto/hmac.c:82:	       crypto_shash_export(shash, ipad) ?:
crypto/hmac.c:83:	       crypto_shash_init(shash) ?:
crypto/hmac.c:84:	       crypto_shash_update(shash, opad, bs) ?:
crypto/hmac.c:85:	       crypto_shash_export(shash, opad);
crypto/hmac.c:92:	return crypto_shash_export(desc, out);
crypto/hmac.c:102:	return crypto_shash_import(desc, in);
crypto/hmac.c:107:	return hmac_import(pdesc, crypto_shash_ctx_aligned(pdesc->tfm));
crypto/hmac.c:115:	return crypto_shash_update(desc, data, nbytes);
crypto/hmac.c:120:	struct crypto_shash *parent = pdesc->tfm;
crypto/hmac.c:121:	int ds = crypto_shash_digestsize(parent);
crypto/hmac.c:122:	int ss = crypto_shash_statesize(parent);
crypto/hmac.c:123:	char *opad = crypto_shash_ctx_aligned(parent) + ss;
crypto/hmac.c:126:	return crypto_shash_final(desc, out) ?:
crypto/hmac.c:127:	       crypto_shash_import(desc, opad) ?:
crypto/hmac.c:128:	       crypto_shash_finup(desc, out, ds, out);
crypto/hmac.c:135:	struct crypto_shash *parent = pdesc->tfm;
crypto/hmac.c:136:	int ds = crypto_shash_digestsize(parent);
crypto/hmac.c:137:	int ss = crypto_shash_statesize(parent);
crypto/hmac.c:138:	char *opad = crypto_shash_ctx_aligned(parent) + ss;
crypto/hmac.c:141:	return crypto_shash_finup(desc, data, nbytes, out) ?:
crypto/hmac.c:142:	       crypto_shash_import(desc, opad) ?:
crypto/hmac.c:143:	       crypto_shash_finup(desc, out, ds, out);
crypto/hmac.c:148:	struct crypto_shash *parent = __crypto_shash_cast(tfm);
crypto/hmac.c:149:	struct crypto_shash *hash;
crypto/hmac.c:151:	struct crypto_shash_spawn *spawn = crypto_instance_ctx(inst);
crypto/hmac.c:159:			   crypto_shash_descsize(hash);
crypto/hmac.c:167:	struct hmac_ctx *ctx = hmac_ctx(__crypto_shash_cast(tfm));
crypto/hmac.c:191:	if (crypto_shash_alg_has_setkey(salg))
crypto/michael_mic.c:53:	struct michael_mic_ctx *ctx = crypto_shash_ctx(desc->tfm);
crypto/michael_mic.c:136:static int michael_setkey(struct crypto_shash *tfm, const u8 *key,
crypto/michael_mic.c:139:	struct michael_mic_ctx *mctx = crypto_shash_ctx(tfm);
crypto/michael_mic.c:144:		crypto_shash_set_flags(tfm, CRYPTO_TFM_RES_BAD_KEY_LEN);
crypto/nhpoly1305.c:124:int crypto_nhpoly1305_setkey(struct crypto_shash *tfm,
crypto/nhpoly1305.c:127:	struct nhpoly1305_key *ctx = crypto_shash_ctx(tfm);
crypto/nhpoly1305.c:159:	const struct nhpoly1305_key *key = crypto_shash_ctx(desc->tfm);
crypto/nhpoly1305.c:200:	const struct nhpoly1305_key *key = crypto_shash_ctx(desc->tfm);
crypto/sha3_generic.c:169:	unsigned int digest_size = crypto_shash_digestsize(desc->tfm);
crypto/sha3_generic.c:222:	unsigned int digest_size = crypto_shash_digestsize(desc->tfm);
crypto/shash.c:26:static const struct crypto_type crypto_shash_type;
crypto/shash.c:28:int shash_no_setkey(struct crypto_shash *tfm, const u8 *key,
crypto/shash.c:35:static int shash_setkey_unaligned(struct crypto_shash *tfm, const u8 *key,
crypto/shash.c:38:	struct shash_alg *shash = crypto_shash_alg(tfm);
crypto/shash.c:39:	unsigned long alignmask = crypto_shash_alignmask(tfm);
crypto/shash.c:56:static void shash_set_needkey(struct crypto_shash *tfm, struct shash_alg *alg)
crypto/shash.c:58:	if (crypto_shash_alg_has_setkey(alg) &&
crypto/shash.c:60:		crypto_shash_set_flags(tfm, CRYPTO_TFM_NEED_KEY);
crypto/shash.c:63:int crypto_shash_setkey(struct crypto_shash *tfm, const u8 *key,
crypto/shash.c:66:	struct shash_alg *shash = crypto_shash_alg(tfm);
crypto/shash.c:67:	unsigned long alignmask = crypto_shash_alignmask(tfm);
crypto/shash.c:80:	crypto_shash_clear_flags(tfm, CRYPTO_TFM_NEED_KEY);
crypto/shash.c:83:EXPORT_SYMBOL_GPL(crypto_shash_setkey);
crypto/shash.c:88:	struct crypto_shash *tfm = desc->tfm;
crypto/shash.c:89:	struct shash_alg *shash = crypto_shash_alg(tfm);
crypto/shash.c:90:	unsigned long alignmask = crypto_shash_alignmask(tfm);
crypto/shash.c:115:int crypto_shash_update(struct shash_desc *desc, const u8 *data,
crypto/shash.c:118:	struct crypto_shash *tfm = desc->tfm;
crypto/shash.c:119:	struct shash_alg *shash = crypto_shash_alg(tfm);
crypto/shash.c:120:	unsigned long alignmask = crypto_shash_alignmask(tfm);
crypto/shash.c:127:EXPORT_SYMBOL_GPL(crypto_shash_update);
crypto/shash.c:131:	struct crypto_shash *tfm = desc->tfm;
crypto/shash.c:132:	unsigned long alignmask = crypto_shash_alignmask(tfm);
crypto/shash.c:133:	struct shash_alg *shash = crypto_shash_alg(tfm);
crypto/shash.c:134:	unsigned int ds = crypto_shash_digestsize(tfm);
crypto/shash.c:157:int crypto_shash_final(struct shash_desc *desc, u8 *out)
crypto/shash.c:159:	struct crypto_shash *tfm = desc->tfm;
crypto/shash.c:160:	struct shash_alg *shash = crypto_shash_alg(tfm);
crypto/shash.c:161:	unsigned long alignmask = crypto_shash_alignmask(tfm);
crypto/shash.c:168:EXPORT_SYMBOL_GPL(crypto_shash_final);
crypto/shash.c:173:	return crypto_shash_update(desc, data, len) ?:
crypto/shash.c:174:	       crypto_shash_final(desc, out);
crypto/shash.c:177:int crypto_shash_finup(struct shash_desc *desc, const u8 *data,
crypto/shash.c:180:	struct crypto_shash *tfm = desc->tfm;
crypto/shash.c:181:	struct shash_alg *shash = crypto_shash_alg(tfm);
crypto/shash.c:182:	unsigned long alignmask = crypto_shash_alignmask(tfm);
crypto/shash.c:189:EXPORT_SYMBOL_GPL(crypto_shash_finup);
crypto/shash.c:194:	return crypto_shash_init(desc) ?:
crypto/shash.c:195:	       crypto_shash_finup(desc, data, len, out);
crypto/shash.c:198:int crypto_shash_digest(struct shash_desc *desc, const u8 *data,
crypto/shash.c:201:	struct crypto_shash *tfm = desc->tfm;
crypto/shash.c:202:	struct shash_alg *shash = crypto_shash_alg(tfm);
crypto/shash.c:203:	unsigned long alignmask = crypto_shash_alignmask(tfm);
crypto/shash.c:205:	if (crypto_shash_get_flags(tfm) & CRYPTO_TFM_NEED_KEY)
crypto/shash.c:213:EXPORT_SYMBOL_GPL(crypto_shash_digest);
crypto/shash.c:217:	memcpy(out, shash_desc_ctx(desc), crypto_shash_descsize(desc->tfm));
crypto/shash.c:223:	memcpy(shash_desc_ctx(desc), in, crypto_shash_descsize(desc->tfm));
crypto/shash.c:230:	struct crypto_shash **ctx = crypto_ahash_ctx(tfm);
crypto/shash.c:232:	return crypto_shash_setkey(*ctx, key, keylen);
crypto/shash.c:237:	struct crypto_shash **ctx = crypto_ahash_ctx(crypto_ahash_reqtfm(req));
crypto/shash.c:242:	return crypto_shash_init(desc);
crypto/shash.c:252:		nbytes = crypto_shash_update(desc, walk.data, nbytes);
crypto/shash.c:265:	return crypto_shash_final(ahash_request_ctx(req), req->result);
crypto/shash.c:275:		return crypto_shash_final(desc, req->result);
crypto/shash.c:279:			 crypto_shash_finup(desc, walk.data, nbytes,
crypto/shash.c:281:			 crypto_shash_update(desc, walk.data, nbytes);
crypto/shash.c:291:	struct crypto_shash **ctx = crypto_ahash_ctx(crypto_ahash_reqtfm(req));
crypto/shash.c:312:		err = crypto_shash_digest(desc, data + offset, nbytes,
crypto/shash.c:316:		err = crypto_shash_init(desc) ?:
crypto/shash.c:325:	struct crypto_shash **ctx = crypto_ahash_ctx(crypto_ahash_reqtfm(req));
crypto/shash.c:335:	return crypto_shash_export(ahash_request_ctx(req), out);
crypto/shash.c:340:	struct crypto_shash **ctx = crypto_ahash_ctx(crypto_ahash_reqtfm(req));
crypto/shash.c:345:	return crypto_shash_import(desc, in);
crypto/shash.c:350:	struct crypto_shash **ctx = crypto_tfm_ctx(tfm);
crypto/shash.c:358:	struct shash_alg *alg = __crypto_shash_alg(calg);
crypto/shash.c:360:	struct crypto_shash **ctx = crypto_tfm_ctx(tfm);
crypto/shash.c:361:	struct crypto_shash *shash;
crypto/shash.c:366:	shash = crypto_create_tfm(calg, &crypto_shash_type);
crypto/shash.c:380:	if (crypto_shash_alg_has_setkey(alg))
crypto/shash.c:383:	crypto_ahash_set_flags(crt, crypto_shash_get_flags(shash) &
crypto/shash.c:389:	crt->reqsize = sizeof(struct shash_desc) + crypto_shash_descsize(shash);
crypto/shash.c:394:static int crypto_shash_init_tfm(struct crypto_tfm *tfm)
crypto/shash.c:396:	struct crypto_shash *hash = __crypto_shash_cast(tfm);
crypto/shash.c:397:	struct shash_alg *alg = crypto_shash_alg(hash);
crypto/shash.c:407:static int crypto_shash_report(struct sk_buff *skb, struct crypto_alg *alg)
crypto/shash.c:410:	struct shash_alg *salg = __crypto_shash_alg(alg);
crypto/shash.c:422:static int crypto_shash_report(struct sk_buff *skb, struct crypto_alg *alg)
crypto/shash.c:428:static void crypto_shash_show(struct seq_file *m, struct crypto_alg *alg)
crypto/shash.c:430:static void crypto_shash_show(struct seq_file *m, struct crypto_alg *alg)
crypto/shash.c:432:	struct shash_alg *salg = __crypto_shash_alg(alg);
crypto/shash.c:439:static const struct crypto_type crypto_shash_type = {
crypto/shash.c:441:	.init_tfm = crypto_shash_init_tfm,
crypto/shash.c:443:	.show = crypto_shash_show,
crypto/shash.c:445:	.report = crypto_shash_report,
crypto/shash.c:449:	.tfmsize = offsetof(struct crypto_shash, base),
crypto/shash.c:452:struct crypto_shash *crypto_alloc_shash(const char *alg_name, u32 type,
crypto/shash.c:455:	return crypto_alloc_tfm(alg_name, &crypto_shash_type, type, mask);
crypto/shash.c:471:	base->cra_type = &crypto_shash_type;
crypto/shash.c:565:int crypto_init_shash_spawn(struct crypto_shash_spawn *spawn,
crypto/shash.c:570:				  &crypto_shash_type);
crypto/shash.c:578:	alg = crypto_attr_alg2(rta, &crypto_shash_type, type, mask);
crypto/streebog_generic.c:957:	unsigned int digest_size = crypto_shash_digestsize(desc->tfm);
crypto/streebog_generic.c:1088:	if (crypto_shash_digestsize(desc->tfm) == STREEBOG256_DIGEST_SIZE)
crypto/testmgr.c:1298:static void generate_random_hash_testvec(struct crypto_shash *tfm,
crypto/testmgr.c:1322:		vec->setkey_error = crypto_shash_setkey(tfm, vec->key,
crypto/testmgr.c:1331:	vec->digest_error = crypto_shash_digest(desc, vec->plaintext,
crypto/testmgr.c:1355:	struct crypto_shash *generic_tfm = NULL;
crypto/testmgr.c:1391:	if (digestsize != crypto_shash_digestsize(generic_tfm)) {
crypto/testmgr.c:1394:		       crypto_shash_digestsize(generic_tfm));
crypto/testmgr.c:1399:	if (blocksize != crypto_shash_blocksize(generic_tfm)) {
crypto/testmgr.c:1401:		       driver, blocksize, crypto_shash_blocksize(generic_tfm));
crypto/testmgr.c:3001:	struct crypto_shash *tfm;
crypto/testmgr.c:3031:		err = crypto_shash_final(shash, (u8 *)&val);
crypto/vmac.c:429:static int vmac_setkey(struct crypto_shash *tfm,
crypto/vmac.c:432:	struct vmac_tfm_ctx *tctx = crypto_shash_ctx(tfm);
crypto/vmac.c:439:		crypto_shash_set_flags(tfm, CRYPTO_TFM_RES_BAD_KEY_LEN);
crypto/vmac.c:483:	const struct vmac_tfm_ctx *tctx = crypto_shash_ctx(desc->tfm);
crypto/vmac.c:495:	const struct vmac_tfm_ctx *tctx = crypto_shash_ctx(desc->tfm);
crypto/vmac.c:565:	const struct vmac_tfm_ctx *tctx = crypto_shash_ctx(desc->tfm);
crypto/xcbc.c:62:static int crypto_xcbc_digest_setkey(struct crypto_shash *parent,
crypto/xcbc.c:65:	unsigned long alignmask = crypto_shash_alignmask(parent);
crypto/xcbc.c:66:	struct xcbc_tfm_ctx *ctx = crypto_shash_ctx(parent);
crypto/xcbc.c:85:	unsigned long alignmask = crypto_shash_alignmask(pdesc->tfm);
crypto/xcbc.c:87:	int bs = crypto_shash_blocksize(pdesc->tfm);
crypto/xcbc.c:99:	struct crypto_shash *parent = pdesc->tfm;
crypto/xcbc.c:100:	unsigned long alignmask = crypto_shash_alignmask(parent);
crypto/xcbc.c:101:	struct xcbc_tfm_ctx *tctx = crypto_shash_ctx(parent);
crypto/xcbc.c:104:	int bs = crypto_shash_blocksize(parent);
crypto/xcbc.c:145:	struct crypto_shash *parent = pdesc->tfm;
crypto/xcbc.c:146:	unsigned long alignmask = crypto_shash_alignmask(parent);
crypto/xcbc.c:147:	struct xcbc_tfm_ctx *tctx = crypto_shash_ctx(parent);
crypto/xcbc.c:150:	int bs = crypto_shash_blocksize(parent);
 


crypto/aead.c:299:	err = crypto_rng_get_bytes(crypto_default_rng, ctx->salt,
Binary file crypto/aead.o matches
crypto/algif_rng.c:55:	struct crypto_rng *drng;
crypto/algif_rng.c:85:	genlen = crypto_rng_get_bytes(ctx->drng, result, len);
crypto/algif_rng.c:166:	return crypto_rng_reset(private, seed, seedlen);
crypto/ansi_cprng.c:354:static int cprng_get_random(struct crypto_rng *tfm,
crypto/ansi_cprng.c:358:	struct prng_context *prng = crypto_rng_ctx(tfm);
crypto/ansi_cprng.c:369:static int cprng_reset(struct crypto_rng *tfm,
crypto/ansi_cprng.c:372:	struct prng_context *prng = crypto_rng_ctx(tfm);
crypto/ansi_cprng.c:390:static int fips_cprng_get_random(struct crypto_rng *tfm,
crypto/ansi_cprng.c:394:	struct prng_context *prng = crypto_rng_ctx(tfm);
crypto/ansi_cprng.c:399:static int fips_cprng_reset(struct crypto_rng *tfm,
crypto/ansi_cprng.c:406:	struct prng_context *prng = crypto_rng_ctx(tfm);
crypto/drbg.c:53: * struct crypto_rng *drng;
crypto/drbg.c:58: * err = crypto_rng_get_bytes(drng, &data, DATALEN);
crypto/drbg.c:64: * struct crypto_rng *drng;
crypto/drbg.c:74: * err = crypto_rng_reset(drng, &personalization, strlen(personalization));
crypto/drbg.c:75: * err = crypto_rng_get_bytes(drng, &data, DATALEN);
crypto/drbg.c:81: * struct crypto_rng *drng;
crypto/drbg.c:89: * // The following call is a wrapper to crypto_rng_get_bytes() and returns
crypto/drbg.c:1092:			ret = crypto_rng_get_bytes(drbg->jent,
crypto/drbg.c:1550:static void drbg_kcapi_set_entropy(struct crypto_rng *tfm,
crypto/drbg.c:1553:	struct drbg_state *drbg = crypto_rng_ctx(tfm);
crypto/drbg.c:1841:static int drbg_kcapi_random(struct crypto_rng *tfm,
crypto/drbg.c:1845:	struct drbg_state *drbg = crypto_rng_ctx(tfm);
crypto/drbg.c:1861:static int drbg_kcapi_seed(struct crypto_rng *tfm,
crypto/drbg.c:1864:	struct drbg_state *drbg = crypto_rng_ctx(tfm);
crypto/drbg.c:1865:	struct crypto_tfm *tfm_base = crypto_rng_tfm(tfm);
crypto/ecc.c:1369:	err = crypto_rng_get_bytes(crypto_default_rng, (u8 *)priv, nbytes);
crypto/jitterentropy-kcapi.c:148:static int jent_kcapi_random(struct crypto_rng *tfm,
crypto/jitterentropy-kcapi.c:152:	struct jitterentropy *rng = crypto_rng_ctx(tfm);
crypto/jitterentropy-kcapi.c:162:static int jent_kcapi_reset(struct crypto_rng *tfm,
Binary file crypto/jitterentropy-kcapi.o matches
crypto/rng.c:32:struct crypto_rng *crypto_default_rng;
crypto/rng.c:36:int crypto_rng_reset(struct crypto_rng *tfm, const u8 *seed, unsigned int slen)
crypto/rng.c:54:	err = crypto_rng_alg(tfm)->seed(tfm, seed, slen);
crypto/rng.c:60:EXPORT_SYMBOL_GPL(crypto_rng_reset);
crypto/rng.c:62:static int crypto_rng_init_tfm(struct crypto_tfm *tfm)
crypto/rng.c:75:static int crypto_rng_report(struct sk_buff *skb, struct crypto_alg *alg)
crypto/rng.c:88:static int crypto_rng_report(struct sk_buff *skb, struct crypto_alg *alg)
crypto/rng.c:94:static void crypto_rng_show(struct seq_file *m, struct crypto_alg *alg)
crypto/rng.c:96:static void crypto_rng_show(struct seq_file *m, struct crypto_alg *alg)
crypto/rng.c:102:static const struct crypto_type crypto_rng_type = {
crypto/rng.c:104:	.init_tfm = crypto_rng_init_tfm,
crypto/rng.c:106:	.show = crypto_rng_show,
crypto/rng.c:108:	.report = crypto_rng_report,
crypto/rng.c:112:	.tfmsize = offsetof(struct crypto_rng, base),
crypto/rng.c:115:struct crypto_rng *crypto_alloc_rng(const char *alg_name, u32 type, u32 mask)
crypto/rng.c:117:	return crypto_alloc_tfm(alg_name, &crypto_rng_type, type, mask);
crypto/rng.c:123:	struct crypto_rng *rng;
crypto/rng.c:133:		err = crypto_rng_reset(rng, NULL, crypto_rng_seedsize(rng));
crypto/rng.c:189:	base->cra_type = &crypto_rng_type;
crypto/testmgr.c:2876:static int test_cprng(struct crypto_rng *tfm,
crypto/testmgr.c:2880:	const char *algo = crypto_tfm_alg_driver_name(crypto_rng_tfm(tfm));
crypto/testmgr.c:2885:	seedsize = crypto_rng_seedsize(tfm);
crypto/testmgr.c:2903:		err = crypto_rng_reset(tfm, seed, seedsize);
crypto/testmgr.c:2911:			err = crypto_rng_get_bytes(tfm, result,
crypto/testmgr.c:3053:	struct crypto_rng *rng;
crypto/testmgr.c:3075:	struct crypto_rng *drng;


crypto/akcipher.c:29:static int crypto_akcipher_report(struct sk_buff *skb, struct crypto_alg *alg)
crypto/akcipher.c:41:static int crypto_akcipher_report(struct sk_buff *skb, struct crypto_alg *alg)
crypto/akcipher.c:47:static void crypto_akcipher_show(struct seq_file *m, struct crypto_alg *alg)
crypto/akcipher.c:50:static void crypto_akcipher_show(struct seq_file *m, struct crypto_alg *alg)
crypto/akcipher.c:55:static void crypto_akcipher_exit_tfm(struct crypto_tfm *tfm)
crypto/akcipher.c:57:	struct crypto_akcipher *akcipher = __crypto_akcipher_tfm(tfm);
crypto/akcipher.c:58:	struct akcipher_alg *alg = crypto_akcipher_alg(akcipher);
crypto/akcipher.c:63:static int crypto_akcipher_init_tfm(struct crypto_tfm *tfm)
crypto/akcipher.c:65:	struct crypto_akcipher *akcipher = __crypto_akcipher_tfm(tfm);
crypto/akcipher.c:66:	struct akcipher_alg *alg = crypto_akcipher_alg(akcipher);
crypto/akcipher.c:69:		akcipher->base.exit = crypto_akcipher_exit_tfm;
crypto/akcipher.c:77:static void crypto_akcipher_free_instance(struct crypto_instance *inst)
crypto/akcipher.c:84:static const struct crypto_type crypto_akcipher_type = {
crypto/akcipher.c:86:	.init_tfm = crypto_akcipher_init_tfm,
crypto/akcipher.c:87:	.free = crypto_akcipher_free_instance,
crypto/akcipher.c:89:	.show = crypto_akcipher_show,
crypto/akcipher.c:91:	.report = crypto_akcipher_report,
crypto/akcipher.c:95:	.tfmsize = offsetof(struct crypto_akcipher, base),
crypto/akcipher.c:98:int crypto_grab_akcipher(struct crypto_akcipher_spawn *spawn, const char *name,
crypto/akcipher.c:101:	spawn->base.frontend = &crypto_akcipher_type;
crypto/akcipher.c:106:struct crypto_akcipher *crypto_alloc_akcipher(const char *alg_name, u32 type,
crypto/akcipher.c:109:	return crypto_alloc_tfm(alg_name, &crypto_akcipher_type, type, mask);
crypto/akcipher.c:117:	base->cra_type = &crypto_akcipher_type;
Binary file crypto/akcipher.o matches
grep: crypto/asymmetric_keys: Is a directory
grep: crypto/async_tx: Is a directory
crypto/ecrdsa.c:72:	struct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);
crypto/ecrdsa.c:190:static int ecrdsa_set_pub_key(struct crypto_akcipher *tfm, const void *key,
crypto/ecrdsa.c:251:static unsigned int ecrdsa_max_size(struct crypto_akcipher *tfm)
crypto/ecrdsa.c:262:static void ecrdsa_exit_tfm(struct crypto_akcipher *tfm)
crypto/rsa.c:53:static inline struct rsa_mpi_key *rsa_get_key(struct crypto_akcipher *tfm)
crypto/rsa.c:60:	struct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);
crypto/rsa.c:99:	struct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);
crypto/rsa.c:160:static int rsa_set_pub_key(struct crypto_akcipher *tfm, const void *key,
crypto/rsa.c:194:static int rsa_set_priv_key(struct crypto_akcipher *tfm, const void *key,
crypto/rsa.c:232:static unsigned int rsa_max_size(struct crypto_akcipher *tfm)
crypto/rsa.c:239:static void rsa_exit_tfm(struct crypto_akcipher *tfm)
Binary file crypto/rsa.o matches
crypto/rsa-pkcs1pad.c:95:	struct crypto_akcipher *child;
crypto/rsa-pkcs1pad.c:100:	struct crypto_akcipher_spawn spawn;
crypto/rsa-pkcs1pad.c:110:static int pkcs1pad_set_pub_key(struct crypto_akcipher *tfm, const void *key,
crypto/rsa-pkcs1pad.c:118:	err = crypto_akcipher_set_pub_key(ctx->child, key, keylen);
crypto/rsa-pkcs1pad.c:123:	err = crypto_akcipher_maxsize(ctx->child);
crypto/rsa-pkcs1pad.c:131:static int pkcs1pad_set_priv_key(struct crypto_akcipher *tfm, const void *key,
crypto/rsa-pkcs1pad.c:139:	err = crypto_akcipher_set_priv_key(ctx->child, key, keylen);
crypto/rsa-pkcs1pad.c:144:	err = crypto_akcipher_maxsize(ctx->child);
crypto/rsa-pkcs1pad.c:152:static unsigned int pkcs1pad_get_max_size(struct crypto_akcipher *tfm)
crypto/rsa-pkcs1pad.c:179:	struct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);
crypto/rsa-pkcs1pad.c:226:	async_req.tfm = crypto_akcipher_tfm(crypto_akcipher_reqtfm(req));
crypto/rsa-pkcs1pad.c:234:	struct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);
crypto/rsa-pkcs1pad.c:273:	err = crypto_akcipher_encrypt(&req_ctx->child_req);
crypto/rsa-pkcs1pad.c:282:	struct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);
crypto/rsa-pkcs1pad.c:344:	async_req.tfm = crypto_akcipher_tfm(crypto_akcipher_reqtfm(req));
crypto/rsa-pkcs1pad.c:351:	struct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);
crypto/rsa-pkcs1pad.c:375:	err = crypto_akcipher_decrypt(&req_ctx->child_req);
crypto/rsa-pkcs1pad.c:384:	struct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);
crypto/rsa-pkcs1pad.c:432:	err = crypto_akcipher_decrypt(&req_ctx->child_req);
crypto/rsa-pkcs1pad.c:441:	struct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);
crypto/rsa-pkcs1pad.c:522:	async_req.tfm = crypto_akcipher_tfm(crypto_akcipher_reqtfm(req));
crypto/rsa-pkcs1pad.c:537:	struct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);
crypto/rsa-pkcs1pad.c:563:	err = crypto_akcipher_encrypt(&req_ctx->child_req);
crypto/rsa-pkcs1pad.c:570:static int pkcs1pad_init_tfm(struct crypto_akcipher *tfm)
crypto/rsa-pkcs1pad.c:575:	struct crypto_akcipher *child_tfm;
crypto/rsa-pkcs1pad.c:585:static void pkcs1pad_exit_tfm(struct crypto_akcipher *tfm)
crypto/rsa-pkcs1pad.c:595:	struct crypto_akcipher_spawn *spawn = &ctx->spawn;
crypto/rsa-pkcs1pad.c:607:	struct crypto_akcipher_spawn *spawn;
crypto/testmgr.c:3348:static int test_akcipher_one(struct crypto_akcipher *tfm,
crypto/testmgr.c:3384:		err = crypto_akcipher_set_pub_key(tfm, key, vecs->key_len);
crypto/testmgr.c:3386:		err = crypto_akcipher_set_priv_key(tfm, key, vecs->key_len);
crypto/testmgr.c:3395:	out_len_max = crypto_akcipher_maxsize(tfm);
crypto/testmgr.c:3440:			      crypto_akcipher_verify(req) :
crypto/testmgr.c:3442:			      crypto_akcipher_encrypt(req), &wait);
crypto/testmgr.c:3490:			      crypto_akcipher_sign(req) :
crypto/testmgr.c:3492:			      crypto_akcipher_decrypt(req), &wait);
crypto/testmgr.c:3522:static int test_akcipher(struct crypto_akcipher *tfm, const char *alg,
crypto/testmgr.c:3527:		crypto_tfm_alg_driver_name(crypto_akcipher_tfm(tfm));
crypto/testmgr.c:3545:	struct crypto_akcipher *tfm

crypto/dh.c:46:static inline struct dh_ctx *dh_get_ctx(struct crypto_kpp *tfm)
crypto/dh.c:78:static int dh_set_secret(struct crypto_kpp *tfm, const void *buf,
crypto/dh.c:155:	struct crypto_kpp *tfm = crypto_kpp_reqtfm(req);
crypto/dh.c:200:static unsigned int dh_max_size(struct crypto_kpp *tfm)
crypto/dh.c:207:static void dh_exit_tfm(struct crypto_kpp *tfm)
crypto/dh_helper.c:111:	 * crypto_kpp_maxsize() returning 0.
Binary file crypto/dh.o matches
crypto/ecdh.c:25:static inline struct ecdh_ctx *ecdh_get_ctx(struct crypto_kpp *tfm)
crypto/ecdh.c:39:static int ecdh_set_secret(struct crypto_kpp *tfm, const void *buf,
crypto/ecdh.c:71:	struct crypto_kpp *tfm = crypto_kpp_reqtfm(req);
crypto/ecdh.c:137:static unsigned int ecdh_max_size(struct crypto_kpp *tfm)
crypto/kpp.c:29:static int crypto_kpp_report(struct sk_buff *skb, struct crypto_alg *alg)
crypto/kpp.c:40:static int crypto_kpp_report(struct sk_buff *skb, struct crypto_alg *alg)
crypto/kpp.c:46:static void crypto_kpp_show(struct seq_file *m, struct crypto_alg *alg)
crypto/kpp.c:49:static void crypto_kpp_show(struct seq_file *m, struct crypto_alg *alg)
crypto/kpp.c:54:static void crypto_kpp_exit_tfm(struct crypto_tfm *tfm)
crypto/kpp.c:56:	struct crypto_kpp *kpp = __crypto_kpp_tfm(tfm);
crypto/kpp.c:57:	struct kpp_alg *alg = crypto_kpp_alg(kpp);
crypto/kpp.c:62:static int crypto_kpp_init_tfm(struct crypto_tfm *tfm)
crypto/kpp.c:64:	struct crypto_kpp *kpp = __crypto_kpp_tfm(tfm);
crypto/kpp.c:65:	struct kpp_alg *alg = crypto_kpp_alg(kpp);
crypto/kpp.c:68:		kpp->base.exit = crypto_kpp_exit_tfm;
crypto/kpp.c:76:static const struct crypto_type crypto_kpp_type = {
crypto/kpp.c:78:	.init_tfm = crypto_kpp_init_tfm,
crypto/kpp.c:80:	.show = crypto_kpp_show,
crypto/kpp.c:82:	.report = crypto_kpp_report,
crypto/kpp.c:86:	.tfmsize = offsetof(struct crypto_kpp, base),
crypto/kpp.c:89:struct crypto_kpp *crypto_alloc_kpp(const char *alg_name, u32 type, u32 mask)
crypto/kpp.c:91:	return crypto_alloc_tfm(alg_name, &crypto_kpp_type, type, mask);
crypto/kpp.c:99:	base->cra_type = &crypto_kpp_type;
crypto/testmgr.c:3164:static int do_test_kpp(struct crypto_kpp *tfm, const struct kpp_testvec *vec,
crypto/testmgr.c:3184:	err = crypto_kpp_set_secret(tfm, vec->secret, vec->secret_size);
crypto/testmgr.c:3188:	out_len_max = crypto_kpp_maxsize(tfm);
crypto/testmgr.c:3203:	err = crypto_wait_req(crypto_kpp_generate_public_key(req), &wait);
crypto/testmgr.c:3241:	err = crypto_wait_req(crypto_kpp_compute_shared_secret(req), &wait);
crypto/testmgr.c:3260:		err = crypto_kpp_set_secret(tfm, vec->b_secret,
crypto/testmgr.c:3271:		err = crypto_wait_req(crypto_kpp_compute_shared_secret(req),
crypto/testmgr.c:3306:static int test_kpp(struct crypto_kpp *tfm, const char *alg,
crypto/testmgr.c:3325:	struct crypto_kpp *tfm;


